<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PyTorch: torch::nn::parallel Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PyTorch
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetorch.html">torch</a></li><li class="navelem"><a class="el" href="namespacetorch_1_1nn.html">nn</a></li><li class="navelem"><a class="el" href="namespacetorch_1_1nn_1_1parallel.html">parallel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">torch::nn::parallel Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3fb9b74758c39b577bbaf9c9444922ad"><td class="memTemplParams" colspan="2">template&lt;typename ModuleType &gt; </td></tr>
<tr class="memitem:a3fb9b74758c39b577bbaf9c9444922ad"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; ModuleType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetorch_1_1nn_1_1parallel.html#a3fb9b74758c39b577bbaf9c9444922ad">replicate</a> (const std::shared_ptr&lt; ModuleType &gt; &amp;module, const std::vector&lt; <a class="el" href="structat_1_1_device.html">Device</a> &gt; &amp;devices)</td></tr>
<tr class="separator:a3fb9b74758c39b577bbaf9c9444922ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d09f760ffa82af211c7658d4eee806"><td class="memTemplParams" colspan="2">template&lt;typename ModuleType &gt; </td></tr>
<tr class="memitem:a78d09f760ffa82af211c7658d4eee806"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classtorch_1_1nn_1_1_module_holder.html">ModuleHolder</a>&lt; ModuleType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetorch_1_1nn_1_1parallel.html#a78d09f760ffa82af211c7658d4eee806">replicate</a> (const <a class="el" href="classtorch_1_1nn_1_1_module_holder.html">ModuleHolder</a>&lt; ModuleType &gt; &amp;module, const std::vector&lt; <a class="el" href="structat_1_1_device.html">Device</a> &gt; &amp;devices)</td></tr>
<tr class="separator:a78d09f760ffa82af211c7658d4eee806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1ca8a32ab74f67b9152295264014e1"><td class="memTemplParams" colspan="2">template&lt;typename ModuleType &gt; </td></tr>
<tr class="memitem:a2d1ca8a32ab74f67b9152295264014e1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structat_1_1_tensor.html">Tensor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetorch_1_1nn_1_1parallel.html#a2d1ca8a32ab74f67b9152295264014e1">parallel_apply</a> (std::vector&lt; ModuleType &gt; &amp;modules, const std::vector&lt; <a class="el" href="structat_1_1_tensor.html">Tensor</a> &gt; &amp;inputs, const at::optional&lt; std::vector&lt; <a class="el" href="structat_1_1_device.html">Device</a> &gt;&gt; &amp;devices=at::nullopt)</td></tr>
<tr class="separator:a2d1ca8a32ab74f67b9152295264014e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02c6f48854e0d662033e3a0a997a904"><td class="memTemplParams" colspan="2">template&lt;typename ModuleType &gt; </td></tr>
<tr class="memitem:ac02c6f48854e0d662033e3a0a997a904"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structat_1_1_tensor.html">Tensor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetorch_1_1nn_1_1parallel.html#ac02c6f48854e0d662033e3a0a997a904">data_parallel</a> (ModuleType module, <a class="el" href="structat_1_1_tensor.html">Tensor</a> input, at::optional&lt; std::vector&lt; <a class="el" href="structat_1_1_device.html">Device</a> &gt;&gt; devices=at::nullopt, at::optional&lt; <a class="el" href="structat_1_1_device.html">Device</a> &gt; output_device=at::nullopt, int64_t dim=0)</td></tr>
<tr class="separator:ac02c6f48854e0d662033e3a0a997a904"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac02c6f48854e0d662033e3a0a997a904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02c6f48854e0d662033e3a0a997a904">&#9670;&nbsp;</a></span>data_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ModuleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structat_1_1_tensor.html">Tensor</a> torch::nn::parallel::data_parallel </td>
          <td>(</td>
          <td class="paramtype">ModuleType&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structat_1_1_tensor.html">Tensor</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">at::optional&lt; std::vector&lt; <a class="el" href="structat_1_1_device.html">Device</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>devices</em> = <code>at::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">at::optional&lt; <a class="el" href="structat_1_1_device.html">Device</a> &gt;&#160;</td>
          <td class="paramname"><em>output_device</em> = <code>at::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluates <code>module(input)</code> in parallel across the given <code>devices</code>. If <code>devices</code> is not supplied, the invocation is parallelized across all available CUDA devices. If <code>output_device</code> is supplied, the final, combined tensor will be placed on this device. If not, it defaults to the first device in <code>devices</code>.</p>
<p>In detail, this method performs the following four distinct steps:</p><ol type="1">
<li><em>Scatter</em> the input to the given devices,</li>
<li><em>Replicate</em> (deep clone) the model on each device,</li>
<li><em>Evaluate</em> each module with its input on its device,</li>
<li><em>Gather</em> the outputs of each replica into a single output tensor, located on the <code>output_device</code>. </li>
</ol>

</div>
</div>
<a id="a2d1ca8a32ab74f67b9152295264014e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1ca8a32ab74f67b9152295264014e1">&#9670;&nbsp;</a></span>parallel_apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ModuleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structat_1_1_tensor.html">Tensor</a>&gt; torch::nn::parallel::parallel_apply </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; ModuleType &gt; &amp;&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structat_1_1_tensor.html">Tensor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const at::optional&lt; std::vector&lt; <a class="el" href="structat_1_1_device.html">Device</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>devices</em> = <code>at::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies the given inputs to the given modules in a parallel fashion. Conceptually, a thread is spawned for each <code>(module, input)</code> pair, in which <code>forward()</code> is called on the module with its corresponding input. The outputs of the individual calls are stored in a vector and returned.</p>
<p>The first exception caught by any thread is stashed and rethrown after all threads have completed their operation.</p>
<p>Further remarks:</p><ol type="1">
<li>The length of the module container must match the length of the inputs.</li>
<li>If a list of devices is supplied, it must match the list of modules in length. Each device will be set to the current default device during the invocation of the respective module. This means any tensors allocated on the default device inside the module will be constructed on this device. </li>
</ol>

</div>
</div>
<a id="a3fb9b74758c39b577bbaf9c9444922ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb9b74758c39b577bbaf9c9444922ad">&#9670;&nbsp;</a></span>replicate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ModuleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;ModuleType&gt; &gt; torch::nn::parallel::replicate </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; ModuleType &gt; &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structat_1_1_device.html">Device</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>devices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replicates a module on the given list of devices. A replica is created by calling <code><a class="el" href="namespaceat.html#ae95ab7c4c78aa08fb714021ceda2b375">clone()</a></code> on the module. For this, the module must inherit from <code><a class="el" href="classtorch_1_1nn_1_1_cloneable.html">nn::Cloneable</a></code>, or define its own <code><a class="el" href="namespaceat.html#ae95ab7c4c78aa08fb714021ceda2b375">clone()</a></code> method, which is expected to perform a deep copy of the module. </p>

</div>
</div>
<a id="a78d09f760ffa82af211c7658d4eee806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d09f760ffa82af211c7658d4eee806">&#9670;&nbsp;</a></span>replicate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ModuleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classtorch_1_1nn_1_1_module_holder.html">ModuleHolder</a>&lt;ModuleType&gt; &gt; torch::nn::parallel::replicate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtorch_1_1nn_1_1_module_holder.html">ModuleHolder</a>&lt; ModuleType &gt; &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structat_1_1_device.html">Device</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>devices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replicates a module holder on the given list of devices. This method allows calling <code><a class="el" href="namespacetorch_1_1nn_1_1parallel.html#a3fb9b74758c39b577bbaf9c9444922ad">replicate()</a></code> with a module holder, such as <code>Linear</code>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
