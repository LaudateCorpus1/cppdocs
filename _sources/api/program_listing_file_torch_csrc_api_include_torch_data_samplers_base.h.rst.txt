:github_url: https://github.com/pytorch/pytorch


.. _program_listing_file_torch_csrc_api_include_torch_data_samplers_base.h:

Program Listing for File base.h
===============================

|exhale_lsh| :ref:`Return to documentation for file <file_torch_csrc_api_include_torch_data_samplers_base.h>` (``torch/csrc/api/include/torch/data/samplers/base.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: none

   #pragma once
   
   #include <torch/csrc/WindowsTorchApiMacro.h>
   #include <torch/types.h>
   
   #include <cstddef>
   #include <vector>
   #include <mutex>
   
   namespace torch {
   namespace serialize {
   class OutputArchive;
   class InputArchive;
   } // namespace serialize
   } // namespace torch
   
   namespace torch {
   namespace data {
   namespace samplers {
   template <typename BatchRequest = std::vector<size_t>>
   class Sampler {
    public:
     using BatchRequestType = BatchRequest;
   
     virtual ~Sampler() = default;
   
     TORCH_API virtual void reset(optional<size_t> new_size) = 0;
   
     TORCH_API virtual optional<BatchRequest> next(size_t batch_size) = 0;
   
     TORCH_API virtual void save(serialize::OutputArchive& archive) const = 0;
   
     TORCH_API virtual void load(serialize::InputArchive& archive) = 0;
   };
   
   template <typename OriginalSampler>
   class LockedSampler
       : public Sampler<typename OriginalSampler::BatchRequestType> {
    public:
     using BatchRequestType = typename OriginalSampler::BatchRequestType;
   
     explicit LockedSampler(OriginalSampler sampler) : sampler_(std::move(sampler)) {}
   
     void reset(optional<size_t> new_size) override {
       std::lock_guard<std::mutex> lock(this->mutex_);
       sampler_.reset(new_size);
     }
   
     optional<BatchRequestType> next(size_t batch_size) override {
       std::lock_guard<std::mutex> lock(this->mutex_);
       return sampler_.next(batch_size);
     }
   
     void save(serialize::OutputArchive& archive) const override {
       std::lock_guard<std::mutex> lock(this->mutex_);
       sampler_.save(archive);
     }
   
     void load(serialize::InputArchive& archive) override {
       std::lock_guard<std::mutex> lock(this->mutex_);
       sampler_.load(archive);
     }
   
    private:
     // member variable for multi-threading lock.
     // declare it to be mutable for locking in const member function.
     mutable std::mutex mutex_;
     OriginalSampler sampler_;
   };
   } // namespace samplers
   } // namespace data
   } // namespace torch
