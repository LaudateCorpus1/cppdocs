:github_url: https://github.com/pytorch/pytorch


.. _program_listing_file__Users_psag_home_pytorch_pytorch_aten_src_ATen_Device.h:

Program Listing for File Device.h
=================================

- Return to documentation for :ref:`file__Users_psag_home_pytorch_pytorch_aten_src_ATen_Device.h`

.. code-block:: cpp

   #pragma once
   
   #include <ATen/ScalarType.h>
   #include <ATen/core/Error.h>
   #include <ATen/core/DeviceType.h>
   #include <ATen/core/Error.h>
   
   #include <cstddef>
   #include <iosfwd>
   #include <string>
   #include <functional>
   
   namespace at {
   
   struct Device {
     using Type = at::DeviceType;
   
     static DeviceType backend_to_type(Backend backend) {
       switch (backend) {
         case kCPU:
         case kSparseCPU:
           return DeviceType::CPU;
         case kCUDA:
         case kSparseCUDA:
           return DeviceType::CUDA;
         default:
           AT_ERROR(
               "Invalid backend ", toString(backend), " for Device construction");
       }
     }
   
     /* implicit */ Device(DeviceType type, int32_t index = -1)
         : type_(type), index_(index) {
       AT_CHECK(
           index == -1 || index >= 0,
           "Device index must be -1 or non-negative, got ",
           index);
       AT_CHECK(
           !is_cpu() || index <= 0,
           "CPU device index must be -1 or zero, got ",
           index);
     }
   
     /* implicit */ Device(const std::string& device_string);
   
     /* implicit */ Device(Backend backend, int32_t index = -1)
         : Device(backend_to_type(backend), index) {}
   
     bool operator==(const Device& other) const noexcept {
       return this->type_ == other.type_ && this->index_ == other.index_;
     }
   
     bool operator!=(const Device& other) const noexcept {
       return !(*this == other);
     }
   
     void set_index(int32_t index) {
       index_ = index;
     }
   
     DeviceType type() const noexcept {
       return type_;
     }
   
     const int32_t& index() const noexcept {
       return index_;
     }
   
     bool has_index() const noexcept {
       return index_ != -1;
     }
   
     bool is_cuda() const noexcept {
       return type_ == DeviceType::CUDA;
     }
   
     bool is_cpu() const noexcept {
       return type_ == DeviceType::CPU;
     }
   
    private:
     DeviceType type_;
     int32_t index_ = -1;
   };
   
   AT_API std::ostream& operator<<(std::ostream& stream, const at::Device& device);
   
   } // namespace at
   
   
   namespace std {
     template<> struct hash<at::Device>
     {
       size_t operator()(const at::Device& device) const noexcept {
         size_t hash_val = static_cast<size_t>(device.index() + 1);
         if (device.is_cuda()) {
           hash_val += 2;
         }
         return hash_val;
       }
     };
   } // namespace std
