:github_url: https://github.com/pytorch/pytorch


.. _program_listing_file_torch_csrc_api_include_torch_python.h:

Program Listing for File python.h
=================================

|exhale_lsh| :ref:`Return to documentation for file <file_torch_csrc_api_include_torch_python.h>` (``torch/csrc/api/include/torch/python.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: none

   #pragma once
   
   #include <torch/detail/static.h>
   #include <torch/types.h>
   
   #include <torch/csrc/python_headers.h>
   #include <torch/csrc/utils/pybind.h>
   #include <torch/types.h>
   #include <torch/ordered_dict.h>
   
   #include <iterator>
   #include <string>
   #include <unordered_map>
   #include <utility>
   #include <vector>
   
   namespace torch {
   namespace python {
   namespace detail {
   inline std::unordered_map<std::string, Tensor> ordered_dict_to_map(
       const OrderedDict<std::string, torch::Tensor>& dict) {
     auto pairs = dict.pairs();
     return {pairs.begin(), pairs.end()};
   }
   } // namespace detail
   
   template <typename M, typename... Extra>
   py::class_<M, Extra...> add_module_bindings(py::class_<M, Extra...> module) {
     return module.def("train", [](M& module) { module.train(); })
         .def("eval", [](M& module) { module.eval(); })
         .def("clone", [](M& module) { return module.clone(); })
         .def_property_readonly(
             "training", [](M& module) { return module.is_training(); })
         .def("zero_grad", [](M& module) { module.zero_grad(); })
         .def("cuda", [](M& module) { module.to(torch::kCUDA); })
         .def("cpu", [](M& module) { module.to(torch::kCPU); })
         .def("parameters", [](M& module) { return module.parameters(); })
         .def(
             "named_parameters",
             [](M& module) {
               return detail::ordered_dict_to_map(module.named_parameters());
             })
         .def("buffers", [](M& module) { return module.buffers(); })
         .def("named_buffers", [](M& module) {
           return detail::ordered_dict_to_map(module.named_buffers());
         });
   }
   
   template <typename M>
   py::class_<M, std::shared_ptr<M>> bind_module(
       py::module module,
       const char* name) {
     return add_module_bindings(py::class_<M, std::shared_ptr<M>>(module, name));
   }
   } // namespace python
   } // namespace torch
