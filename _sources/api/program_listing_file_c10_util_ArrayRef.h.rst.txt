:github_url: https://github.com/pytorch/pytorch


.. _program_listing_file_c10_util_ArrayRef.h:

Program Listing for File ArrayRef.h
===================================

|exhale_lsh| :ref:`Return to documentation for file <file_c10_util_ArrayRef.h>` (``c10/util/ArrayRef.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: none

   //===--- ArrayRef.h - Array Reference Wrapper -------------------*- C++ -*-===//
   //
   //                     The LLVM Compiler Infrastructure
   //
   // This file is distributed under the University of Illinois Open Source
   // License. See LICENSE.TXT for details.
   //
   //===----------------------------------------------------------------------===//
   
   // ATen: modified from llvm::ArrayRef.
   // removed llvm-specific functionality
   // removed some implicit const -> non-const conversions that rely on
   // complicated std::enable_if meta-programming
   // removed a bunch of slice variants for simplicity...
   
   #pragma once
   
   #include <c10/util/SmallVector.h>
   #include <c10/util/C++17.h>
   #include <c10/util/Exception.h>
   #include <c10/util/Deprecated.h>
   
   #include <array>
   #include <iterator>
   #include <vector>
   
   namespace c10 {
   
   template <typename T>
   class ArrayRef final {
    public:
     using iterator = const T*;
     using const_iterator = const T*;
     using size_type = size_t;
   
     using reverse_iterator = std::reverse_iterator<iterator>;
   
    private:
     const T* Data;
   
     size_type Length;
   
    public:
   
     /* implicit */ constexpr ArrayRef() : Data(nullptr), Length(0) {}
   
     // TODO Make this explicit
     constexpr ArrayRef(const T& OneElt) : Data(&OneElt), Length(1) {}
   
     constexpr ArrayRef(const T* data, size_t length)
         : Data(data), Length(length) {}
   
     constexpr ArrayRef(const T* begin, const T* end)
         : Data(begin), Length(end - begin) {}
   
     template <typename U>
     /* implicit */ ArrayRef(const SmallVectorTemplateCommon<T, U>& Vec)
         : Data(Vec.data()), Length(Vec.size()) {}
   
     template <typename A>
     /* implicit */ ArrayRef(const std::vector<T, A>& Vec)
         : Data(Vec.data()), Length(Vec.size()) {}
   
     template <size_t N>
     /* implicit */ constexpr ArrayRef(const std::array<T, N>& Arr)
         : Data(Arr.data()), Length(N) {}
   
     template <size_t N>
     /* implicit */ constexpr ArrayRef(const T (&Arr)[N]) : Data(Arr), Length(N) {}
   
     /* implicit */ constexpr ArrayRef(const std::initializer_list<T>& Vec)
         : Data(Vec.begin() == Vec.end() ? static_cast<T*>(nullptr) : Vec.begin()),
           Length(Vec.size()) {}
   
   
     constexpr iterator begin() const {
       return Data;
     }
     constexpr iterator end() const {
       return Data + Length;
     }
   
     // These are actually the same as iterator, since ArrayRef only
     // gives you const iterators.
     constexpr const_iterator cbegin() const {
       return Data;
     }
     constexpr const_iterator cend() const {
       return Data + Length;
     }
   
     constexpr reverse_iterator rbegin() const {
       return reverse_iterator(end());
     }
     constexpr reverse_iterator rend() const {
       return reverse_iterator(begin());
     }
   
     constexpr bool empty() const {
       return Length == 0;
     }
   
     constexpr const T* data() const {
       return Data;
     }
   
     constexpr size_t size() const {
       return Length;
     }
   
     AT_CPP14_CONSTEXPR const T& front() const {
       AT_CHECK(!empty(), "ArrayRef: attempted to access front() of empty list");
       return Data[0];
     }
   
     AT_CPP14_CONSTEXPR const T& back() const {
       AT_CHECK(!empty(), "ArrayRef: attempted to access back() of empty list");
       return Data[Length - 1];
     }
   
     constexpr bool equals(ArrayRef RHS) const {
       return Length == RHS.Length && std::equal(begin(), end(), RHS.begin());
     }
   
     AT_CPP14_CONSTEXPR ArrayRef<T> slice(size_t N, size_t M) const {
       AT_CHECK(
           N + M <= size(),
           "ArrayRef: invalid slice, N = ",
           N,
           "; M = ",
           M,
           "; size = ",
           size());
       return ArrayRef<T>(data() + N, M);
     }
   
     constexpr ArrayRef<T> slice(size_t N) const {
       return slice(N, size() - N);
     }
   
     constexpr const T& operator[](size_t Index) const {
       return Data[Index];
     }
   
     AT_CPP14_CONSTEXPR const T& at(size_t Index) const {
       AT_CHECK(
           Index < Length,
           "ArrayRef: invalid index Index = ",
           Index,
           "; Length = ",
           Length);
       return Data[Index];
     }
   
     template <typename U>
     typename std::enable_if<std::is_same<U, T>::value, ArrayRef<T>>::type&
     operator=(U&& Temporary) = delete;
   
     template <typename U>
     typename std::enable_if<std::is_same<U, T>::value, ArrayRef<T>>::type&
     operator=(std::initializer_list<U>) = delete;
   
     std::vector<T> vec() const {
       return std::vector<T>(Data, Data + Length);
     }
   
   };
   
   template <typename T>
   std::ostream& operator<<(std::ostream & out, ArrayRef<T> list) {
     int i = 0;
     out << "[";
     for(auto e : list) {
       if (i++ > 0)
         out << ", ";
       out << e;
     }
     out << "]";
     return out;
   }
   
   // WARNING: Template instantiation will NOT be willing to do an implicit
   // conversions to get you to an c10::ArrayRef, which is why we need so
   // many overloads.
   
   template <typename T>
   bool operator==(c10::ArrayRef<T> a1, c10::ArrayRef<T> a2) {
     return a1.equals(a2);
   }
   
   template <typename T>
   bool operator!=(c10::ArrayRef<T> a1, c10::ArrayRef<T> a2) {
     return !a1.equals(a2);
   }
   
   template <typename T>
   bool operator==(std::vector<T> a1, c10::ArrayRef<T> a2) {
     return c10::ArrayRef<T>(a1).equals(a2);
   }
   
   template <typename T>
   bool operator!=(std::vector<T> a1, c10::ArrayRef<T> a2) {
     return !c10::ArrayRef<T>(a1).equals(a2);
   }
   
   template <typename T>
   bool operator==(c10::ArrayRef<T> a1, std::vector<T> a2) {
     return a1.equals(c10::ArrayRef<T>(a2));
   }
   
   template <typename T>
   bool operator!=(c10::ArrayRef<T> a1, std::vector<T> a2) {
     return !a1.equals(c10::ArrayRef<T>(a2));
   }
   
   using IntArrayRef = ArrayRef<int64_t>;
   
   // This alias is deprecated because it doesn't make ownership
   // semantics obvious.  Use IntArrayRef instead!
   using IntList C10_DEPRECATED_USING = ArrayRef<int64_t>;
   
   } // namespace c10
