:github_url: https://github.com/pytorch/pytorch


.. _program_listing_file__Users_psag_home_pytorch_pytorch_build_aten_src_ATen_Tensor.h:

Program Listing for File Tensor.h
=================================

- Return to documentation for :ref:`file__Users_psag_home_pytorch_pytorch_build_aten_src_ATen_Tensor.h`

.. code-block:: cpp

   #pragma once
   
   // @generated by aten/src/ATen/gen.py
   
   #include "ATen/Device.h"
   #include "ATen/Layout.h"
   #include "ATen/Scalar.h"
   #include "ATen/ScalarType.h"
   #include "ATen/SparseTensorRef.h"
   #include "ATen/Storage.h"
   #include "ATen/TensorAccessor.h"
   #include "ATen/TensorBase.h"
   #include "ATen/TensorImpl.h"
   #include "ATen/core/optional.h"
   
   namespace at {
   struct Generator;
   struct Type;
   struct Tensor;
   struct TensorOptions;
   namespace detail {
   void set_data(Tensor& tensor, Tensor new_data);
   } // namespace detail
   } // namespace at
   
   namespace at {
   // Tensor is a "generic" object holding a pointer to the underlying TensorImpl object, which
   // has an embedded reference count. In this way, Tensor is similar to boost::intrusive_ptr.
   //
   // For example:
   //
   // void func(Tensor a) {
   //   Tensor b = a;
   //   ...
   // }
   //
   // In this example, when we say Tensor b = a, we are creating a new object that points to the
   // same underlying TensorImpl, and bumps its reference count. When b goes out of scope, the
   // destructor decrements the reference count by calling release() on the TensorImpl it points to.
   // The existing constructors, operator overloads, etc. take care to implement the correct semantics.
   //
   // Note that Tensor can also be NULL, i.e. it is not associated with any underlying TensorImpl, and
   // special care must be taken to handle this.
   struct Tensor : public detail::TensorBase {
     using TensorBase = detail::TensorBase;
     Tensor() : TensorBase() {}
     Tensor(TensorImpl * self, bool retain) : TensorBase(self, retain) {}
     Tensor(const TensorBase & rhs) : TensorBase(rhs) {}
     Tensor(const Tensor & rhs) = default;
     Tensor(Tensor && rhs) noexcept = default;
   
     // reimplemented from TensorBase so the return type is Tensor rather than TensorBase
     Tensor & operator=(Tensor && rhs) & {
       rhs.swap(*this);
       return *this;
     }
     Tensor & operator=(Tensor const & rhs) & {
         //Tensor ctor retains original rhs.pImpl
         //then rhs.pImpl is swapped with this->pImpl
         //finally Tensor dtor releases rhs.pImpl, which was originally this->pImpl
         Tensor(rhs).swap(*this);
         return *this;
     }
   
     inline Tensor & operator=(Tensor const & rhs) &&;
     Tensor & operator=(Scalar v) &&;
     const char * toString() const {
       return pImpl->toString();
     }
     IntList sizes() const {
       return pImpl->sizes();
     }
     IntList strides() const {
       return pImpl->strides();
     }
     int64_t ndimension() const {
       return dim();
     }
     Type & type() const {
       return pImpl->type();
     }
     std::unique_ptr<Storage> storage() const {
       return pImpl->storage();
     }
     inline Tensor toType(const Type & t, bool non_blocking=false) const;
     inline Tensor & copy_(const Tensor & src, bool non_blocking=false);
     inline Tensor toType(ScalarType t) const;
     inline Tensor toBackend(Backend b) const;
   
     Tensor to(Device device, ScalarType dtype, bool non_blocking = false) const;
     Tensor to(ScalarType dtype, bool non_blocking = false) const;
     Tensor to(Device device, bool non_blocking = false) const;
   
     bool is_variable() const noexcept;
   
     Layout layout() const noexcept;
   
     ScalarType dtype() const noexcept;
   
     Device device() const;
   
     TensorOptions options() const;
   
     template<typename T>
     T * data() const;
   
     void * unsafeGetTH(bool retain) const {
       return pImpl->unsafeGetTH(retain);
     }
   
     // non-retaining
     TensorImpl * unsafeGetTensorImpl() const {
       return pImpl;
     }
   
     // Purposely not defined here to avoid inlining
     void print() const;
   
     //toLongData(), toFloatData() etc.
     #define TO_TYPE_DATA(T,name,_) \
     T * to##name##Data() const;
     AT_FORALL_SCALAR_TYPES(TO_TYPE_DATA)
     #undef TO_TYPE_DATA
   
     #define TO_C_TYPE(T,name,_) \
     T toC##name () const;
     AT_FORALL_SCALAR_TYPES(TO_C_TYPE)
     #undef TO_C_TYPE
   
     template<typename T, size_t N>
     TensorAccessor<T,N> accessor() const& {
       static_assert(N > 0, "accessor is used for indexing tensor, for scalars use *data<T>()");
       AT_CHECK(dim() == N, "expected ", N, " dims but tensor has ", dim());
       return TensorAccessor<T,N>(data<T>(),sizes().data(),strides().data());
     }
     template<typename T, size_t N>
     TensorAccessor<T,N> accessor() && = delete;
   
     Tensor operator-() const;
     Tensor& operator+=(const Tensor & other);
     Tensor& operator+=(Scalar other);
     Tensor& operator-=(const Tensor & other);
     Tensor& operator-=(Scalar other);
     Tensor& operator*=(const Tensor & other);
     Tensor& operator*=(Scalar other);
     Tensor& operator/=(const Tensor & other);
     Tensor& operator/=(Scalar other);
     Tensor operator[](Scalar index) const;
     Tensor operator[](Tensor index) const;
     Tensor operator[](int64_t index) const;
   
     // ~~~~~ Autograd API ~~~~~
   
     Tensor& set_requires_grad(bool requires_grad) {
       pImpl->set_requires_grad(requires_grad);
       return *this;
     }
     bool requires_grad() const {
       return pImpl->requires_grad();
     }
   
     Tensor& grad() {
       return pImpl->grad();
     }
     const Tensor& grad() const {
       return pImpl->grad();
     }
   
     Tensor detach() const {
       return pImpl->detach();
     }
     void detach_() {
       pImpl->detach_();
     }
   
     void backward(
         at::optional<Tensor> gradient = at::nullopt,
         bool keep_graph = false,
         bool create_graph = false);
   
     friend void detail::set_data(Tensor& tensor, Tensor new_data);
   
     // STOP.  Thinking of adding a method here, which only makes use
     // of other ATen methods?  Define it in native_functions.yaml.
   
     //example
     //Tensor * add(Tensor & b);
     AT_API int64_t storage_offset() const;
     AT_API Tensor & resize_(IntList size);
     AT_API Tensor & set_(Storage & source);
     AT_API Tensor & set_(Storage & source, int64_t storage_offset, IntList size, IntList stride={});
     AT_API Tensor & set_(const Tensor & source);
     AT_API Tensor & set_();
     AT_API Tensor & _fill_(Scalar value);
     AT_API Tensor & _fill_(const Tensor & value);
     AT_API bool is_contiguous() const;
     AT_API bool is_set_to(const Tensor & tensor) const;
     AT_API Tensor & masked_fill_(const Tensor & mask, Scalar value);
     AT_API Tensor & masked_fill_(const Tensor & mask, const Tensor & value);
     AT_API Tensor & masked_scatter_(const Tensor & mask, const Tensor & source);
     AT_API Tensor masked_select(const Tensor & mask) const;
     AT_API Tensor nonzero() const;
     AT_API Tensor contiguous() const;
     AT_API Tensor view(IntList size) const;
     AT_API Tensor index_select(int64_t dim, const Tensor & index) const;
     AT_API Tensor & _indexCopy_(int64_t dim, const Tensor & index, const Tensor & source);
     AT_API Tensor take(const Tensor & index) const;
     AT_API Tensor & put_(const Tensor & index, const Tensor & source, bool accumulate=false);
     AT_API Tensor & index_add_(int64_t dim, const Tensor & index, const Tensor & source);
     AT_API Tensor & index_fill_(int64_t dim, const Tensor & index, Scalar value);
     AT_API Tensor & index_fill_(int64_t dim, const Tensor & index, const Tensor & value);
     AT_API Tensor unfold(int64_t dimension, int64_t size, int64_t step) const;
     AT_API Tensor & scatter_(int64_t dim, const Tensor & index, const Tensor & src);
     AT_API Tensor & scatter_(int64_t dim, const Tensor & index, Scalar value);
     AT_API Tensor & scatter_add_(int64_t dim, const Tensor & index, const Tensor & src);
     AT_API Tensor gather(int64_t dim, const Tensor & index) const;
     AT_API void* data_ptr() const;
     AT_API bool equal(const Tensor & other) const;
     AT_API Tensor __and__(Scalar other) const;
     AT_API Tensor __and__(const Tensor & other) const;
     AT_API Tensor & __iand__(Scalar other);
     AT_API Tensor & __iand__(const Tensor & other);
     AT_API Tensor __or__(Scalar other) const;
     AT_API Tensor __or__(const Tensor & other) const;
     AT_API Tensor & __ior__(Scalar other);
     AT_API Tensor & __ior__(const Tensor & other);
     AT_API Tensor __xor__(Scalar other) const;
     AT_API Tensor __xor__(const Tensor & other) const;
     AT_API Tensor & __ixor__(Scalar other);
     AT_API Tensor & __ixor__(const Tensor & other);
     AT_API Tensor __lshift__(Scalar other) const;
     AT_API Tensor __lshift__(const Tensor & other) const;
     AT_API Tensor & __ilshift__(Scalar other);
     AT_API Tensor & __ilshift__(const Tensor & other);
     AT_API Tensor __rshift__(Scalar other) const;
     AT_API Tensor __rshift__(const Tensor & other) const;
     AT_API Tensor & __irshift__(Scalar other);
     AT_API Tensor & __irshift__(const Tensor & other);
     AT_API Tensor lt(Scalar other) const;
     AT_API Tensor lt(const Tensor & other) const;
     AT_API Tensor & lt_(Scalar other);
     AT_API Tensor & lt_(const Tensor & other);
     AT_API Tensor gt(Scalar other) const;
     AT_API Tensor gt(const Tensor & other) const;
     AT_API Tensor & gt_(Scalar other);
     AT_API Tensor & gt_(const Tensor & other);
     AT_API Tensor le(Scalar other) const;
     AT_API Tensor le(const Tensor & other) const;
     AT_API Tensor & le_(Scalar other);
     AT_API Tensor & le_(const Tensor & other);
     AT_API Tensor ge(Scalar other) const;
     AT_API Tensor ge(const Tensor & other) const;
     AT_API Tensor & ge_(Scalar other);
     AT_API Tensor & ge_(const Tensor & other);
     AT_API Tensor eq(Scalar other) const;
     AT_API Tensor eq(const Tensor & other) const;
     AT_API Tensor & eq_(Scalar other);
     AT_API Tensor & eq_(const Tensor & other);
     AT_API Tensor ne(Scalar other) const;
     AT_API Tensor ne(const Tensor & other) const;
     AT_API Tensor & ne_(Scalar other);
     AT_API Tensor & ne_(const Tensor & other);
     AT_API Tensor min(const Tensor & other) const;
     AT_API Tensor min() const;
     AT_API std::tuple<Tensor,Tensor> _th_min(int64_t dim, bool keepdim=false) const;
     AT_API Tensor max(const Tensor & other) const;
     AT_API Tensor max() const;
     AT_API std::tuple<Tensor,Tensor> _th_max(int64_t dim, bool keepdim=false) const;
     AT_API std::tuple<Tensor,Tensor> _th_kthvalue(int64_t k, int64_t dim=-1, bool keepdim=false) const;
     AT_API std::tuple<Tensor,Tensor> _th_mode(int64_t dim=-1, bool keepdim=false) const;
     AT_API Tensor median() const;
     AT_API std::tuple<Tensor,Tensor> _th_median(int64_t dim, bool keepdim=false) const;
     AT_API std::tuple<Tensor,Tensor> sort(int64_t dim=-1, bool descending=false) const;
     AT_API std::tuple<Tensor,Tensor> topk(int64_t k, int64_t dim=-1, bool largest=true, bool sorted=true) const;
     AT_API Tensor all() const;
     AT_API Tensor _th_all(int64_t dim, bool keepdim=false) const;
     AT_API Tensor any() const;
     AT_API Tensor _th_any(int64_t dim, bool keepdim=false) const;
     AT_API Tensor _abs() const;
     AT_API Tensor _th_sigmoid() const;
     AT_API Tensor _log() const;
     AT_API Tensor _log10() const;
     AT_API Tensor _log1p() const;
     AT_API Tensor _log2() const;
     AT_API Tensor lgamma() const;
     AT_API Tensor & lgamma_();
     AT_API Tensor digamma() const;
     AT_API Tensor & digamma_();
     AT_API Tensor polygamma(int64_t n) const;
     AT_API Tensor & polygamma_(int64_t n);
     AT_API Tensor _exp() const;
     AT_API Tensor _expm1() const;
     AT_API Tensor _cos() const;
     AT_API Tensor _acos() const;
     AT_API Tensor _cosh() const;
     AT_API Tensor _sin() const;
     AT_API Tensor _asin() const;
     AT_API Tensor _sinh() const;
     AT_API Tensor _tan() const;
     AT_API Tensor _atan() const;
     AT_API Tensor _th_tanh() const;
     AT_API Tensor _erf() const;
     AT_API Tensor _erfc() const;
     AT_API Tensor & erfinv_();
     AT_API Tensor erfinv() const;
     AT_API Tensor _sqrt() const;
     AT_API Tensor _rsqrt() const;
     AT_API Tensor _ceil() const;
     AT_API Tensor _floor() const;
     AT_API Tensor _round() const;
     AT_API Tensor _trunc() const;
     AT_API Tensor & frac_();
     AT_API Tensor frac() const;
     AT_API Tensor _th_var(int64_t dim, bool unbiased=true, bool keepdim=false) const;
     AT_API Tensor _th_var(bool unbiased=true) const;
     AT_API Tensor _th_std(int64_t dim, bool unbiased=true, bool keepdim=false) const;
     AT_API Tensor _th_std(bool unbiased=true) const;
     AT_API Tensor _th_norm(Scalar p, int64_t dim, bool keepdim=false) const;
     AT_API Tensor renorm(Scalar p, int64_t dim, Scalar maxnorm) const;
     AT_API Tensor & renorm_(Scalar p, int64_t dim, Scalar maxnorm);
     AT_API Tensor dist(const Tensor & other, Scalar p=2) const;
     AT_API Tensor reciprocal() const;
     AT_API Tensor & reciprocal_();
     AT_API Tensor neg() const;
     AT_API Tensor & neg_();
     AT_API Tensor atan2(const Tensor & other) const;
     AT_API Tensor & atan2_(const Tensor & other);
     AT_API Tensor pow(const Tensor & exponent) const;
     AT_API Tensor & pow_(Scalar exponent);
     AT_API Tensor & pow_(const Tensor & exponent);
     AT_API Tensor lerp(const Tensor & end, Scalar weight) const;
     AT_API Tensor & lerp_(const Tensor & end, Scalar weight);
     AT_API Tensor histc(int64_t bins=100, Scalar min=0, Scalar max=0) const;
     AT_API Tensor _sumall() const;
     AT_API Tensor _th_sum(int64_t dim, bool keepdim=false) const;
     AT_API Tensor _prodall() const;
     AT_API Tensor _th_prod(int64_t dim, bool keepdim=false) const;
     AT_API Tensor _cumsum(int64_t dim) const;
     AT_API Tensor _cumprod(int64_t dim) const;
     AT_API Tensor sign() const;
     AT_API Tensor & sign_();
     AT_API Tensor trace() const;
     AT_API Tensor fmod(Scalar other) const;
     AT_API Tensor fmod(const Tensor & other) const;
     AT_API Tensor & fmod_(Scalar other);
     AT_API Tensor & fmod_(const Tensor & other);
     AT_API Tensor remainder(Scalar other) const;
     AT_API Tensor remainder(const Tensor & other) const;
     AT_API Tensor & remainder_(Scalar other);
     AT_API Tensor & remainder_(const Tensor & other);
     AT_API Tensor _th_clamp(Scalar min, Scalar max) const;
     AT_API Tensor _th_clamp_min(Scalar min) const;
     AT_API Tensor _th_clamp_max(Scalar max) const;
     AT_API Tensor _dot(const Tensor & tensor) const;
     AT_API Tensor tril(int64_t diagonal=0) const;
     AT_API Tensor & tril_(int64_t diagonal=0);
     AT_API Tensor triu(int64_t diagonal=0) const;
     AT_API Tensor & triu_(int64_t diagonal=0);
     AT_API Tensor cross(const Tensor & other, int64_t dim=-1) const;
     AT_API Tensor diag(int64_t diagonal=0) const;
     AT_API Tensor _addmv(const Tensor & mat, const Tensor & vec, Scalar beta=1, Scalar alpha=1) const;
     AT_API Tensor & _addmv_(const Tensor & mat, const Tensor & vec, Scalar beta=1, Scalar alpha=1);
     AT_API Tensor _addr(const Tensor & vec1, const Tensor & vec2, Scalar beta=1, Scalar alpha=1) const;
     AT_API Tensor & _addr_(const Tensor & vec1, const Tensor & vec2, Scalar beta=1, Scalar alpha=1);
     AT_API Tensor _ger(const Tensor & vec2) const;
     AT_API Tensor _mv(const Tensor & vec) const;
     AT_API Tensor _mm(const Tensor & mat2) const;
     AT_API Tensor bmm(const Tensor & mat2) const;
     AT_API Tensor addbmm(const Tensor & batch1, const Tensor & batch2, Scalar beta=1, Scalar alpha=1) const;
     AT_API Tensor & addbmm_(const Tensor & batch1, const Tensor & batch2, Scalar beta=1, Scalar alpha=1);
     AT_API Tensor baddbmm(const Tensor & batch1, const Tensor & batch2, Scalar beta=1, Scalar alpha=1) const;
     AT_API Tensor & baddbmm_(const Tensor & batch1, const Tensor & batch2, Scalar beta=1, Scalar alpha=1);
     AT_API Tensor addcmul(const Tensor & tensor1, const Tensor & tensor2, Scalar value=1) const;
     AT_API Tensor & addcmul_(const Tensor & tensor1, const Tensor & tensor2, Scalar value=1);
     AT_API Tensor addcdiv(const Tensor & tensor1, const Tensor & tensor2, Scalar value=1) const;
     AT_API Tensor & addcdiv_(const Tensor & tensor1, const Tensor & tensor2, Scalar value=1);
     AT_API std::tuple<Tensor,Tensor> _gesv_single(const Tensor & A) const;
     AT_API std::tuple<Tensor,Tensor> gels(const Tensor & A) const;
     AT_API std::tuple<Tensor,Tensor> trtrs(const Tensor & A, bool upper=true, bool transpose=false, bool unitriangular=false) const;
     AT_API std::tuple<Tensor,Tensor> symeig(bool eigenvectors=false, bool upper=true) const;
     AT_API std::tuple<Tensor,Tensor> eig(bool eigenvectors=false) const;
     AT_API std::tuple<Tensor,Tensor,Tensor> svd(bool some=true) const;
     AT_API Tensor _getri() const;
     AT_API Tensor potrf(bool upper=true) const;
     AT_API Tensor potrs(const Tensor & input2, bool upper=true) const;
     AT_API Tensor potri(bool upper=true) const;
     AT_API std::tuple<Tensor,Tensor> pstrf(bool upper=true, Scalar tol=-1) const;
     AT_API std::tuple<Tensor,Tensor> qr() const;
     AT_API std::tuple<Tensor,Tensor> geqrf() const;
     AT_API Tensor orgqr(const Tensor & input2) const;
     AT_API Tensor ormqr(const Tensor & input2, const Tensor & input3, bool left=true, bool transpose=false) const;
     AT_API std::tuple<Tensor,Tensor> btrifact(bool pivot=true) const;
     AT_API std::tuple<Tensor,Tensor,Tensor> btrifact_with_info(bool pivot=true) const;
     AT_API Tensor btrisolve(const Tensor & LU_data, const Tensor & LU_pivots) const;
     AT_API Tensor & random_(int64_t from, int64_t to, Generator * generator=nullptr);
     AT_API Tensor & random_(int64_t to, Generator * generator=nullptr);
     AT_API Tensor & random_(Generator * generator=nullptr);
     AT_API Tensor multinomial(int64_t num_samples, bool replacement=false, Generator * generator=nullptr) const;
     AT_API Tensor & uniform_(double from=0, double to=1, Generator * generator=nullptr);
     AT_API Tensor & normal_(double mean=0, double std=1, Generator * generator=nullptr);
     AT_API Tensor & cauchy_(double median=0, double sigma=1, Generator * generator=nullptr);
     AT_API Tensor & log_normal_(double mean=1, double std=2, Generator * generator=nullptr);
     AT_API Tensor & exponential_(double lambd=1, Generator * generator=nullptr);
     AT_API Tensor & geometric_(double p, Generator * generator=nullptr);
     AT_API Tensor & _bernoulli_(double p, Generator * generator=nullptr);
     AT_API Tensor _th_bernoulli(Generator * generator=nullptr) const;
     AT_API Tensor & _copy_ignoring_overlaps_(const Tensor & src);
     AT_API Tensor _cast_Byte(bool non_blocking=false) const;
     AT_API Tensor _cast_Char(bool non_blocking=false) const;
     AT_API Tensor _cast_Double(bool non_blocking=false) const;
     AT_API Tensor _cast_Float(bool non_blocking=false) const;
     AT_API Tensor _cast_Int(bool non_blocking=false) const;
     AT_API Tensor _cast_Long(bool non_blocking=false) const;
     AT_API Tensor _cast_Short(bool non_blocking=false) const;
     AT_API Tensor _cast_Half(bool non_blocking=false) const;
     AT_API std::tuple<Tensor,Tensor> _fused_dropout(double p, Generator * generator=nullptr) const;
     AT_API Tensor _masked_scale(const Tensor & mask, double scale) const;
     AT_API Tensor abs() const;
     AT_API Tensor & abs_();
     AT_API Tensor acos() const;
     AT_API Tensor & acos_();
     AT_API Tensor add(const Tensor & other, Scalar alpha=1) const;
     AT_API Tensor & add_(const Tensor & other, Scalar alpha=1);
     AT_API Tensor add(Scalar other, Scalar alpha=1) const;
     AT_API Tensor & add_(Scalar other, Scalar alpha=1);
     AT_API Tensor addmv(const Tensor & mat, const Tensor & vec, Scalar beta=1, Scalar alpha=1) const;
     AT_API Tensor & addmv_(const Tensor & mat, const Tensor & vec, Scalar beta=1, Scalar alpha=1);
     AT_API Tensor addr(const Tensor & vec1, const Tensor & vec2, Scalar beta=1, Scalar alpha=1) const;
     AT_API Tensor & addr_(const Tensor & vec1, const Tensor & vec2, Scalar beta=1, Scalar alpha=1);
     AT_API Tensor all(int64_t dim, bool keepdim=false) const;
     AT_API bool allclose(const Tensor & other, double rtol=1e-05, double atol=1e-08, bool equal_nan=false) const;
     AT_API Tensor any(int64_t dim, bool keepdim=false) const;
     AT_API Tensor argmax(int64_t dim, bool keepdim=false) const;
     AT_API Tensor argmax() const;
     AT_API Tensor _argmax(int64_t dim, bool keepdim=false) const;
     AT_API Tensor argmin(int64_t dim, bool keepdim=false) const;
     AT_API Tensor argmin() const;
     AT_API Tensor _argmin(int64_t dim, bool keepdim=false) const;
     AT_API Tensor as_strided(IntList size, IntList stride) const;
     AT_API Tensor & as_strided_(IntList size, IntList stride);
     AT_API Tensor as_strided(IntList size, IntList stride, int64_t storage_offset) const;
     AT_API Tensor & as_strided_(IntList size, IntList stride, int64_t storage_offset);
     AT_API Tensor asin() const;
     AT_API Tensor & asin_();
     AT_API Tensor atan() const;
     AT_API Tensor & atan_();
     AT_API Tensor bernoulli(const Tensor & p, Generator * generator=nullptr) const;
     AT_API Tensor bernoulli(double p, Generator * generator=nullptr) const;
     AT_API Tensor bernoulli() const;
     AT_API Tensor & bernoulli_(const Tensor & p, Generator * generator=nullptr);
     AT_API Tensor & bernoulli_(double p, Generator * generator=nullptr);
     AT_API Tensor & bernoulli_();
     AT_API Tensor bincount(const Tensor & weights={}, int64_t minlength=0) const;
     AT_API Tensor ceil() const;
     AT_API Tensor & ceil_();
     AT_API std::vector<Tensor> chunk(int64_t chunks, int64_t dim=0) const;
     AT_API Tensor clamp(Scalar min, Scalar max) const;
     AT_API Tensor & clamp_(Scalar min, Scalar max);
     AT_API Tensor clamp_max(Scalar max) const;
     AT_API Tensor & clamp_max_(Scalar max);
     AT_API Tensor clamp_min(Scalar min) const;
     AT_API Tensor & clamp_min_(Scalar min);
     AT_API Tensor cos() const;
     AT_API Tensor & cos_();
     AT_API Tensor cosh() const;
     AT_API Tensor & cosh_();
     AT_API Tensor cumsum(int64_t dim, ScalarType dtype) const;
     AT_API Tensor cumsum(int64_t dim) const;
     AT_API Tensor cumprod(int64_t dim, ScalarType dtype) const;
     AT_API Tensor cumprod(int64_t dim) const;
     AT_API Tensor det() const;
     AT_API Tensor diagflat(int64_t offset=0) const;
     AT_API Tensor diagonal(int64_t offset=0, int64_t dim1=0, int64_t dim2=1) const;
     AT_API Tensor div(const Tensor & other) const;
     AT_API Tensor & div_(const Tensor & other);
     AT_API Tensor div(Scalar other) const;
     AT_API Tensor & div_(Scalar other);
     AT_API Tensor dot(const Tensor & tensor) const;
     AT_API Tensor erf() const;
     AT_API Tensor & erf_();
     AT_API Tensor erfc() const;
     AT_API Tensor & erfc_();
     AT_API Tensor exp() const;
     AT_API Tensor & exp_();
     AT_API Tensor expm1() const;
     AT_API Tensor & expm1_();
     AT_API Tensor expand(IntList size, bool implicit=false) const;
     AT_API Tensor expand_as(const Tensor & other) const;
     AT_API Tensor flatten(int64_t start_dim=0, int64_t end_dim=-1) const;
     AT_API Tensor & fill_(Scalar value);
     AT_API Tensor & fill_(const Tensor & value);
     AT_API Tensor floor() const;
     AT_API Tensor & floor_();
     AT_API Tensor ger(const Tensor & vec2) const;
     AT_API std::tuple<Tensor,Tensor> gesv(const Tensor & A) const;
     AT_API std::tuple<Tensor,Tensor> _gesv_helper(const Tensor & A) const;
     AT_API Tensor fft(int64_t signal_ndim, bool normalized=false) const;
     AT_API Tensor ifft(int64_t signal_ndim, bool normalized=false) const;
     AT_API Tensor rfft(int64_t signal_ndim, bool normalized=false, bool onesided=true) const;
     AT_API Tensor irfft(int64_t signal_ndim, bool normalized=false, bool onesided=true, IntList signal_sizes={}) const;
     AT_API Tensor _fft_with_size(int64_t signal_ndim, bool complex_input, bool complex_output, bool inverse, IntList checked_signal_sizes, bool normalized, bool onesided, IntList output_sizes) const;
     AT_API Tensor index(TensorList indices) const;
     AT_API Tensor & index_copy_(int64_t dim, const Tensor & index, const Tensor & source);
     AT_API Tensor index_put(TensorList indices, const Tensor & values) const;
     AT_API Tensor & index_put_(TensorList indices, const Tensor & values);
     AT_API Tensor inverse() const;
     AT_API Tensor isclose(const Tensor & other, double rtol=1e-05, double atol=1e-08, bool equal_nan=false) const;
     AT_API bool is_cuda() const;
     AT_API bool is_distributed() const;
     AT_API bool is_floating_point() const;
     AT_API bool is_nonzero() const;
     AT_API bool is_same_size(const Tensor & other) const;
     AT_API bool is_signed() const;
     AT_API bool is_sparse() const;
     AT_API std::tuple<Tensor,Tensor> kthvalue(int64_t k, int64_t dim=-1, bool keepdim=false) const;
     AT_API Tensor log() const;
     AT_API Tensor & log_();
     AT_API Tensor log10() const;
     AT_API Tensor & log10_();
     AT_API Tensor log1p() const;
     AT_API Tensor & log1p_();
     AT_API Tensor log2() const;
     AT_API Tensor & log2_();
     AT_API Tensor logdet() const;
     AT_API Tensor log_softmax(int64_t dim) const;
     AT_API Tensor logsumexp(int64_t dim, bool keepdim=false) const;
     AT_API Tensor matmul(const Tensor & other) const;
     AT_API std::tuple<Tensor,Tensor> max(int64_t dim, bool keepdim=false) const;
     AT_API Tensor max_values(int64_t dim, bool keepdim=false) const;
     AT_API Tensor mean(ScalarType dtype) const;
     AT_API Tensor mean() const;
     AT_API Tensor mean(int64_t dim, bool keepdim, ScalarType dtype) const;
     AT_API Tensor mean(int64_t dim, bool keepdim=false) const;
     AT_API Tensor mean(int64_t dim, ScalarType dtype) const;
     AT_API std::tuple<Tensor,Tensor> median(int64_t dim, bool keepdim=false) const;
     AT_API std::tuple<Tensor,Tensor> min(int64_t dim, bool keepdim=false) const;
     AT_API Tensor min_values(int64_t dim, bool keepdim=false) const;
     AT_API Tensor mm(const Tensor & mat2) const;
     AT_API std::tuple<Tensor,Tensor> mode(int64_t dim=-1, bool keepdim=false) const;
     AT_API Tensor mul(const Tensor & other) const;
     AT_API Tensor & mul_(const Tensor & other);
     AT_API Tensor mul(Scalar other) const;
     AT_API Tensor & mul_(Scalar other);
     AT_API Tensor mv(const Tensor & vec) const;
     AT_API Tensor mvlgamma(int64_t p) const;
     AT_API Tensor & mvlgamma_(int64_t p);
     AT_API Tensor narrow(int64_t dim, int64_t start, int64_t length) const;
     AT_API Tensor permute(IntList dims) const;
     AT_API Tensor pin_memory() const;
     AT_API Tensor pinverse(double rcond=1e-15) const;
     AT_API Tensor repeat(IntList repeats) const;
     AT_API Tensor reshape(IntList shape) const;
     AT_API Tensor reshape_as(const Tensor & other) const;
     AT_API Tensor round() const;
     AT_API Tensor & round_();
     AT_API Tensor relu() const;
     AT_API Tensor & relu_();
     AT_API Tensor hardshrink(Scalar lambd=0.5) const;
     AT_API Tensor hardshrink_backward(const Tensor & grad_out, Scalar lambd) const;
     AT_API Tensor rsqrt() const;
     AT_API Tensor & rsqrt_();
     AT_API Tensor select(int64_t dim, int64_t index) const;
     AT_API Tensor sigmoid() const;
     AT_API Tensor & sigmoid_();
     AT_API Tensor sin() const;
     AT_API Tensor & sin_();
     AT_API Tensor sinh() const;
     AT_API Tensor & sinh_();
     AT_API int64_t size(int64_t dim) const;
     AT_API Tensor slice(int64_t dim=0, int64_t start=0, int64_t end=9223372036854775807, int64_t step=1) const;
     AT_API std::tuple<Tensor,Tensor> slogdet() const;
     AT_API Tensor smm(const Tensor & mat2) const;
     AT_API Tensor softmax(int64_t dim) const;
     AT_API std::vector<Tensor> split(int64_t split_size, int64_t dim=0) const;
     AT_API std::vector<Tensor> split_with_sizes(IntList split_sizes, int64_t dim=0) const;
     AT_API Tensor squeeze() const;
     AT_API Tensor squeeze(int64_t dim) const;
     AT_API Tensor & squeeze_();
     AT_API Tensor & squeeze_(int64_t dim);
     AT_API Tensor sspaddmm(const Tensor & mat1, const Tensor & mat2, Scalar beta=1, Scalar alpha=1) const;
     AT_API Tensor stft(int64_t n_fft, int64_t hop_length, int64_t win_length, const Tensor & window={}, bool normalized=false, bool onesided=true) const;
     AT_API int64_t stride(int64_t dim) const;
     AT_API Tensor sum(ScalarType dtype) const;
     AT_API Tensor sum() const;
     AT_API Tensor _sum() const;
     AT_API Tensor sum(IntList dim, bool keepdim, ScalarType dtype) const;
     AT_API Tensor sum(IntList dim, bool keepdim=false) const;
     AT_API Tensor sum(IntList dim, ScalarType dtype) const;
     AT_API Tensor _sum(IntList dim, bool keepdim=false) const;
     AT_API Tensor sqrt() const;
     AT_API Tensor & sqrt_();
     AT_API Tensor std(bool unbiased=true) const;
     AT_API Tensor std(int64_t dim, bool unbiased=true, bool keepdim=false) const;
     AT_API Tensor prod(ScalarType dtype) const;
     AT_API Tensor prod() const;
     AT_API Tensor _prod() const;
     AT_API Tensor prod(int64_t dim, bool keepdim, ScalarType dtype) const;
     AT_API Tensor prod(int64_t dim, bool keepdim=false) const;
     AT_API Tensor prod(int64_t dim, ScalarType dtype) const;
     AT_API Tensor _prod(int64_t dim, bool keepdim=false) const;
     AT_API Tensor t() const;
     AT_API Tensor & t_();
     AT_API Tensor tan() const;
     AT_API Tensor & tan_();
     AT_API Tensor tanh() const;
     AT_API Tensor & tanh_();
     AT_API Tensor transpose(int64_t dim0, int64_t dim1) const;
     AT_API Tensor & transpose_(int64_t dim0, int64_t dim1);
     AT_API Tensor flip(IntList dims) const;
     AT_API Tensor rot90(int64_t k=1, IntList dims={0,1}) const;
     AT_API Tensor trunc() const;
     AT_API Tensor & trunc_();
     AT_API Tensor type_as(const Tensor & other) const;
     AT_API std::tuple<Tensor,Tensor> _unique(bool sorted=false, bool return_inverse=false) const;
     AT_API Tensor unsqueeze(int64_t dim) const;
     AT_API Tensor & unsqueeze_(int64_t dim);
     AT_API Tensor var(bool unbiased=true) const;
     AT_API Tensor var(int64_t dim, bool unbiased=true, bool keepdim=false) const;
     AT_API Tensor view_as(const Tensor & other) const;
     AT_API Tensor where(const Tensor & condition, const Tensor & other) const;
     AT_API Tensor _s_where(const Tensor & condition, const Tensor & other) const;
     AT_API Tensor _standard_gamma_grad(const Tensor & output) const;
     AT_API Tensor _standard_gamma(Generator * generator=nullptr) const;
     AT_API Tensor norm(Scalar p=2) const;
     AT_API Tensor norm(Scalar p, int64_t dim, bool keepdim=false) const;
     AT_API Tensor clone() const;
     AT_API Tensor & resize_as_(const Tensor & the_template);
     AT_API Tensor pow(Scalar exponent) const;
     AT_API Tensor & zero_();
     AT_API Tensor sub(const Tensor & other, Scalar alpha=1) const;
     AT_API Tensor & sub_(const Tensor & other, Scalar alpha=1);
     AT_API Tensor sub(Scalar other, Scalar alpha=1) const;
     AT_API Tensor & sub_(Scalar other, Scalar alpha=1);
     AT_API Tensor addmm(const Tensor & mat1, const Tensor & mat2, Scalar beta=1, Scalar alpha=1) const;
     AT_API Tensor & addmm_(const Tensor & mat1, const Tensor & mat2, Scalar beta=1, Scalar alpha=1);
     AT_API Tensor & sparse_raw_resize_(IntList size, int64_t sparseDims, int64_t denseDims);
     AT_API Tensor _sparse_mask(SparseTensorRef mask) const;
     AT_API Tensor to_dense() const;
     AT_API int64_t _sparseDims() const;
     AT_API int64_t _dimI() const;
     AT_API int64_t _denseDims() const;
     AT_API int64_t _dimV() const;
     AT_API int64_t _nnz() const;
     AT_API Tensor coalesce() const;
     AT_API bool is_coalesced() const;
     AT_API Tensor _indices() const;
     AT_API Tensor _values() const;
     AT_API int64_t numel() const;
     AT_API std::vector<Tensor> unbind(int64_t dim=0) const;
     AT_API int64_t get_device() const;
     AT_API Scalar _local_scalar() const;
   
     template <typename F, typename... Args>
     auto m(F func, Args&&... params) const -> decltype(func(*this, std::forward<Args>(params)...)) {
       return func(*this, std::forward<Args>(params)...);
     }
   
     friend struct WeakTensor;
   };
   
   struct WeakTensor : public detail::WeakTensorBase {
     using WeakTensorBase = detail::WeakTensorBase;
     WeakTensor() : WeakTensorBase() {}
     WeakTensor(TensorImpl * self, bool retain) : WeakTensorBase(self, retain) {}
     WeakTensor(const WeakTensor & rhs) = default;
     WeakTensor(WeakTensor && rhs) noexcept = default;
     WeakTensor(const Tensor& t) : WeakTensorBase(t.pImpl, true) {}
   
     // reimplemented from TensorBase so the return type is WeakTensor rather than TensorBase
     WeakTensor & operator=(WeakTensor && rhs) & {
       rhs.swap(*this);
       return *this;
     }
     WeakTensor & operator=(WeakTensor const & rhs) & {
       //Tensor ctor retains original rhs.pImpl
       //then rhs.pImpl is swapped with this->pImpl
       //finally Tensor dtor releases rhs.pImpl, which was originally this->pImpl
       WeakTensor(rhs).swap(*this);
       return *this;
     }
   
     WeakTensor & operator=(const Tensor& t) {
       WeakTensor(t.pImpl, true).swap(*this);
       return *this;
     }
   
     // non-retaining
     TensorImpl * unsafeGetTensorImpl() const {
       return pImpl;
     }
   
     // XXX: this can return undefined tensors
     // Ideally it would be at::optional<Tensor>, but MSVC is too cool for that
     Tensor lock() const {
       return pImpl->weak_lock() ? Tensor(pImpl, false) : Tensor();
     }
   };
   
   namespace detail {
   inline void set_data(Tensor& tensor, Tensor new_data) {
     tensor.pImpl->set_data(new_data);
   }
   } // namespace detail
   } // namespace at
