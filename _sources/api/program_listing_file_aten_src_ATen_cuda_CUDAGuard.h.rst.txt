:github_url: https://github.com/pytorch/pytorch


.. _program_listing_file_aten_src_ATen_cuda_CUDAGuard.h:

Program Listing for File CUDAGuard.h
====================================

|exhale_lsh| :ref:`Return to documentation for file <file_aten_src_ATen_cuda_CUDAGuard.h>` (``aten/src/ATen/cuda/CUDAGuard.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: none

   #pragma once
   
   #include <ATen/DeviceGuard.h>
   #include <c10/util/ArrayRef.h>
   #include <ATen/cuda/CUDAContext.h>
   #include <ATen/cuda/detail/CUDAGuardImpl.h>
   #include <c10/DeviceType.h>
   #include <c10/impl/InlineDeviceGuard.h>
   #include <c10/impl/InlineStreamGuard.h>
   
   #include <cstddef>
   #include <vector>
   
   namespace at { namespace cuda {
   
   // This code is kind of boilerplatey.  See Note [Whither the DeviceGuard boilerplate]
   
   struct CUDAGuard {
     explicit CUDAGuard() = delete;
   
     explicit CUDAGuard(DeviceIndex device_index) : guard_(device_index) {}
   
     explicit CUDAGuard(Device device) : guard_(device) {}
   
     // Copy is not allowed
     CUDAGuard(const CUDAGuard&) = delete;
     CUDAGuard& operator=(const CUDAGuard&) = delete;
   
     // Move is not allowed (there is no uninitialized state)
     CUDAGuard(CUDAGuard&& other) = delete;
     CUDAGuard& operator=(CUDAGuard&& other) = delete;
   
     void set_device(Device device) { guard_.set_device(device); }
   
     void reset_device(Device device) { guard_.reset_device(device); }
   
     void set_index(DeviceIndex device_index) { guard_.set_index(device_index); }
   
     Device original_device() const { return guard_.original_device(); }
   
     Device current_device() const { return guard_.current_device(); }
   
    private:
     c10::impl::InlineDeviceGuard<at::cuda::detail::CUDAGuardImpl> guard_;
   };
   
   struct OptionalCUDAGuard {
     explicit OptionalCUDAGuard() : guard_() {}
   
     explicit OptionalCUDAGuard(optional<Device> device_opt) : guard_(device_opt) {}
   
     explicit OptionalCUDAGuard(optional<DeviceIndex> device_index_opt) : guard_(device_index_opt) {}
   
     // Copy is not allowed
     OptionalCUDAGuard(const OptionalCUDAGuard&) = delete;
     OptionalCUDAGuard& operator=(const OptionalCUDAGuard&) = delete;
   
     // See Note [Move construction for RAII guards is tricky]
     OptionalCUDAGuard(OptionalCUDAGuard&& other) = delete;
   
     // See Note [Move assignment for RAII guards is tricky]
     OptionalCUDAGuard& operator=(OptionalCUDAGuard&& other) = delete;
   
     void set_device(Device device) { guard_.set_device(device); }
   
     void reset_device(Device device) { guard_.reset_device(device); }
   
     void set_index(DeviceIndex device_index) { guard_.set_index(device_index); }
   
     optional<Device> original_device() const { return guard_.original_device(); }
   
     optional<Device> current_device() const { return guard_.current_device(); }
   
     void reset() { guard_.reset(); }
   
   private:
     c10::impl::InlineOptionalDeviceGuard<at::cuda::detail::CUDAGuardImpl> guard_;
   };
   
   struct CUDAStreamGuard {
     explicit CUDAStreamGuard() = delete;
   
     explicit CUDAStreamGuard(Stream stream) : guard_(stream) {}
   
     CUDAStreamGuard(const CUDAStreamGuard&) = delete;
     CUDAStreamGuard& operator=(const CUDAStreamGuard&) = delete;
   
     CUDAStreamGuard(CUDAStreamGuard&& other) = delete;
     CUDAStreamGuard& operator=(CUDAStreamGuard&& other) = delete;
   
     void reset_stream(Stream stream) { guard_.reset_stream(stream); }
   
     CUDAStream original_stream() const {
       return CUDAStream(CUDAStream::UNCHECKED, guard_.original_stream());
     }
   
     CUDAStream current_stream() const {
       return CUDAStream(CUDAStream::UNCHECKED, guard_.current_stream());
     }
   
     Device current_device() const { return guard_.current_device(); }
   
     Device original_device() const { return guard_.original_device(); }
   
   private:
     c10::impl::InlineStreamGuard<at::cuda::detail::CUDAGuardImpl> guard_;
   };
   
   struct OptionalCUDAStreamGuard {
     explicit OptionalCUDAStreamGuard() : guard_() {}
   
     explicit OptionalCUDAStreamGuard(Stream stream) : guard_(stream) {}
   
     explicit OptionalCUDAStreamGuard(optional<Stream> stream_opt) : guard_(stream_opt) {}
   
     OptionalCUDAStreamGuard(const OptionalCUDAStreamGuard&) = delete;
     OptionalCUDAStreamGuard& operator=(const OptionalCUDAStreamGuard&) = delete;
   
     // See Note [Move construction for RAII guards is tricky]
     OptionalCUDAStreamGuard(OptionalCUDAStreamGuard&& other) = delete;
   
     // See Note [Move assignment for RAII guards is tricky]
     OptionalCUDAStreamGuard& operator=(OptionalCUDAStreamGuard&& other) = delete;
   
     void reset_stream(Stream stream) { guard_.reset_stream(stream); }
   
     optional<CUDAStream> original_stream() const {
       auto r = guard_.original_stream();
       if (r.has_value()) {
         return make_optional(CUDAStream(CUDAStream::UNCHECKED, r.value()));
       } else {
         return nullopt;
       }
     }
   
     optional<CUDAStream> current_stream() const {
       auto r = guard_.current_stream();
       if (r.has_value()) {
         return make_optional(CUDAStream(CUDAStream::UNCHECKED, r.value()));
       } else {
         return nullopt;
       }
     }
   
     void reset() { guard_.reset(); }
   
   private:
     c10::impl::InlineOptionalStreamGuard<at::cuda::detail::CUDAGuardImpl> guard_;
   };
   
   // TODO: Implement this generically in c10.  You'll need some way to get
   // the number of GPUs from the GuardImpl, in that case.
   struct CUDAMultiStreamGuard {
     explicit CUDAMultiStreamGuard(ArrayRef<CUDAStream> streams) : CUDAMultiStreamGuard() {
       for (const auto& s : streams) {
         setCurrentCUDAStream(s);
       }
     }
   
     CUDAMultiStreamGuard() {
       const size_t device_count = getNumGPUs();
       original_streams_.reserve(device_count);
       for (size_t device = 0; device < device_count; ++device) {
         original_streams_.push_back(getCurrentCUDAStream(device));
       }
     }
   
     CUDAMultiStreamGuard(const CUDAGuard&) = delete;
     CUDAMultiStreamGuard& operator=(const CUDAGuard&) = delete;
   
     // See Note [Move construction for RAII guards is tricky]
     CUDAMultiStreamGuard(CUDAGuard&& other) = delete;
   
     // See Note [Move assignment for RAII guards is tricky]
     CUDAMultiStreamGuard& operator=(CUDAGuard&& other) = delete;
   
     ArrayRef<CUDAStream> original_streams() const {
       return original_streams_;
     }
   
     ~CUDAMultiStreamGuard() {
       for (const auto& s : original_streams_) {
         uncheckedSetCurrentCUDAStream(s);
       }
     }
   
   private:
     std::vector<CUDAStream> original_streams_;
   };
   
   } // namespace cuda
   } // namespace at
