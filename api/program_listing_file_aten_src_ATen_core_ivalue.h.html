


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File ivalue.h &mdash; PyTorch master documentation</title>
  

  
  
  
  
    <link rel="canonical" href="https://pytorch.org/docs/stable/api/program_listing_file_aten_src_ATen_core_ivalue.h.html"/>
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File jit.h" href="file_torch_csrc_api_include_torch_jit.h.html" />
    <link rel="prev" title="File ivalue.h" href="file_aten_src_ATen_core_ivalue.h.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>
</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>
          <li>
            <a href="https://pytorch.org/get-started">Get Started</a>
          </li>

          <li>
            <a href="https://pytorch.org/features">Features</a>
          </li>

          <li>
            <a href="https://pytorch.org/ecosystem">Ecosystem</a>
          </li>

          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>

          <li>
            <a href="https://pytorch.org/tutorials">Tutorials</a>
          </li>

          <li class="active">
            <a href="https://pytorch.org/docs/stable/index.html">Docs</a>
          </li>

          <li>
            <a href="https://pytorch.org/resources">Resources</a>
          </li>

          <li>
            <a href="https://github.com/pytorch/pytorch">Github</a>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>

  </div>
</div>


<body class="pytorch-body">

   

    

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">
            

            
              
              
                <div class="version">
                  master
                </div>
              
            

            


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

            
          </div>

          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installing.html">Installing C++ Distributions of PyTorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../frontend.html">The C++ Frontend</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing to PyTorch</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="library_root.html">Library API</a></li>
</ul>
<p class="caption"><span class="caption-text">Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../notes/faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notes/tensor_basics.html">Tensor Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notes/tensor_creation.html">Tensor Creation API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="../index.html">
          
            Docs
          
        </a> &gt;
      </li>

        
          <li><a href="library_root.html">Library API</a> &gt;</li>
        
          <li><a href="file_aten_src_ATen_core_ivalue.h.html">File ivalue.h</a> &gt;</li>
        
      <li>Program Listing for File ivalue.h</li>
    
    
      <li class="pytorch-breadcrumbs-aside">
        
            
            
              <!-- User defined GitHub URL -->
              <a href="https://github.com/pytorch/pytorch" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">
          
          <div class="rst-content">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
              
  <div class="section" id="program-listing-for-file-ivalue-h">
<span id="program-listing-file-aten-src-aten-core-ivalue-h"></span><h1>Program Listing for File ivalue.h<a class="headerlink" href="#program-listing-for-file-ivalue-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_aten_src_ATen_core_ivalue.h.html#file-aten-src-aten-core-ivalue-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">aten/src/ATen/core/ivalue.h</span></code>)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#pragma once

#include &lt;condition_variable&gt;
#include &lt;type_traits&gt;

#include &lt;c10/core/Scalar.h&gt;
#include &lt;c10/core/TensorImpl.h&gt;
#include &lt;c10/core/UndefinedTensorImpl.h&gt;
#include &lt;ATen/core/blob.h&gt;
#include &lt;c10/util/intrusive_ptr.h&gt;

#include &lt;ATen/core/Tensor.h&gt;

namespace c10 {
struct IValue;

namespace ivalue {

template &lt;typename T&gt;
using Shared = c10::intrusive_ptr&lt;T&gt;;

// string
struct CAFFE2_API ConstantString final : c10::intrusive_ptr_target {
 private:
  const std::string str_;
 public:
  ConstantString(std::string str)
  : str_(std::move(str)) {}
  static c10::intrusive_ptr&lt;ConstantString&gt; create(std::string str_);
  const std::string &amp; string() const {
    return str_;
  }
  operator const std::string &amp; () const {
    return string();
  }
  CAFFE2_API friend std::ostream&amp; operator&lt;&lt;(
      std::ostream&amp; out,
      const ConstantString&amp; v);
};

template &lt;typename Elem&gt;
struct CAFFE2_API List : c10::intrusive_ptr_target {
 private:
  std::vector&lt;Elem&gt; elements_;

 public:
  typedef Elem ElemType;

  List(std::vector&lt;Elem&gt; elements_) : elements_(std::move(elements_)) {}
  static c10::intrusive_ptr&lt;List&lt;Elem&gt;&gt; create(std::vector&lt;Elem&gt; elements_) {
    return c10::make_intrusive&lt;List&lt;Elem&gt;&gt;(std::move(elements_));
  }
  const std::vector&lt;Elem&gt;&amp; elements() const {
    return elements_;
  }
  operator const std::vector&lt;Elem&gt;&amp;() const {
    return elements();
  }

  std::vector&lt;Elem&gt;&amp; elements() {
    return elements_;
  }
  operator std::vector&lt;Elem&gt;&amp;() {
    return elements();
  }
};

struct DictHash {
  size_t operator()(const IValue&amp; ivalue) const;
};

struct DictEqualTo {
  bool operator()(const IValue&amp; lhs, const IValue&amp; rhs) const;
};

template &lt;typename Key, typename Value&gt;
using DictUnorderedMap = std::unordered_map&lt;Key, Value, DictHash, DictEqualTo&gt;;

template &lt;typename Key, typename Value&gt;
struct CAFFE2_API Dict : c10::intrusive_ptr_target {
 private:
  DictUnorderedMap&lt;Key, Value&gt; elements_;

 public:
  Dict(DictUnorderedMap&lt;Key, Value&gt; elements_)
      : elements_(std::move(elements_)) {}
  static c10::intrusive_ptr&lt;Dict&gt; create(
      DictUnorderedMap&lt;Key, Value&gt; elements_) {
    return c10::make_intrusive&lt;Dict&gt;(std::move(elements_));
  }
  const DictUnorderedMap&lt;Key, Value&gt;&amp; elements() const {
    return elements_;
  }
  operator const DictUnorderedMap&lt;Key, Value&gt;&amp;() const {
    return elements();
  }

  DictUnorderedMap&lt;Key, Value&gt;&amp; elements() {
    return elements_;
  }
  operator DictUnorderedMap&lt;Key, Value&gt;&amp;() {
    return elements();
  }
};

struct Future;

struct CAFFE2_API Tuple : public List&lt;IValue&gt; {
  using List&lt;IValue&gt;::List;
  static c10::intrusive_ptr&lt;Tuple&gt; create(std::vector&lt;IValue&gt; elements_) {
    return c10::make_intrusive&lt;Tuple&gt;(std::move(elements_));
  }
};
using IntList = List&lt;int64_t&gt;;
using TensorList = List&lt;at::Tensor&gt;;
using DoubleList = List&lt;double&gt;;
using BoolList = List&lt;bool&gt;;
using GenericList = List&lt;IValue&gt;;
using GenericDict = Dict&lt;IValue, IValue&gt;;


}

// IValue is the generic tagged union used by the interpreter to hold
// all value types.
// It is a 16-byte object with an 8-byte payload and an 8-byte tag.
// The tag is currently 4 bytes to determine the type, and 1 byte
// to mark whether that type is a subtype of c10::intrusive_ptr_target and needs
// retain/release calls.

#define TORCH_FORALL_TAGS(_) \
  _(None) \
  _(Tensor) \
  _(Double) \
  _(Int) \
  _(Bool) \
  _(Tuple) \
  _(IntList) \
  _(DoubleList) \
  _(BoolList) \
  _(String) \
  _(TensorList) \
  _(Blob) \
  _(GenericList) \
  _(GenericDict) \
  _(Future) \
  _(Device)

struct CAFFE2_API IValue final {
  IValue()
  : payload{0}
  , tag(Tag::None)
  , is_intrusive_ptr(false) {}
  IValue(const IValue&amp; rhs)
      : payload(rhs.payload),
        tag(rhs.tag),
        is_intrusive_ptr(rhs.is_intrusive_ptr) {
    if (is_intrusive_ptr) {
      c10::raw::intrusive_ptr::incref(payload.as_intrusive_ptr);
    }
  }
  IValue(IValue&amp;&amp; rhs) noexcept : IValue() {
    swap(rhs);
  }
  ~IValue() {
    if (is_intrusive_ptr) {
      c10::raw::intrusive_ptr::decref(payload.as_intrusive_ptr);
    }
  }
  IValue &amp; operator=(IValue &amp;&amp; rhs) &amp; noexcept {
    IValue(std::move(rhs)).swap(*this); // this also sets rhs to None
    return *this;
  }
  IValue &amp; operator=(IValue const &amp; rhs) &amp; {
    IValue(rhs).swap(*this);
    return *this;
  }

  void dump() const;

  bool isAliasOf(const IValue&amp; rhs) const {
    if (this-&gt;tag != rhs.tag) {
      // Trivially don&#39;t alias if the type is different
      return false;
    }

    if (!this-&gt;is_intrusive_ptr) {
      // Primitive types don&#39;t alias anything
      return false;
    }

    AT_ASSERT(rhs.is_intrusive_ptr);

    // Tensors should be compared based on internal storage
    if (this-&gt;isTensor()) {
      const auto thisTensor = this-&gt;toTensor();
      const auto rhsTensor = rhs.toTensor();
      return thisTensor.is_alias_of(rhsTensor);
    }

    // Other types can be compared by their ptr value
    return this-&gt;payload.as_intrusive_ptr == rhs.payload.as_intrusive_ptr;
  }
  void swap(IValue &amp; rhs) noexcept {
    std::swap(payload, rhs.payload);
    std::swap(is_intrusive_ptr, rhs.is_intrusive_ptr);
    std::swap(tag, rhs.tag);
  }

  // Accessors for subtypes are arranged together below
  // While some of these accessors could be generated through templates,
  // we prefer to write them manually for clarity

  // Tensor
  IValue(at::Tensor t)
  : tag(Tag::Tensor), is_intrusive_ptr(t.defined())  {
    // Note: the undefined tensor is not refcounted, so while it
    // is tagged as a tensor, is_intrusive_ptr is set to false.
    // This is not an optional optimization: our incref call
    // *will not* do the right thing when called on an
    // undefined tensor.
    payload.as_intrusive_ptr = t.unsafeReleaseTensorImpl();
  }
  bool isTensor() const { return Tag::Tensor == tag; }
  at::Tensor toTensor() &amp;&amp; {
    AT_ASSERT(isTensor());
    return at::Tensor(moveToIntrusivePtr&lt;at::TensorImpl, at::UndefinedTensorImpl&gt;());
  }
  at::Tensor toTensor() const &amp; {
    AT_ASSERT(isTensor());
    return at::Tensor(toIntrusivePtr&lt;at::TensorImpl, at::UndefinedTensorImpl&gt;());
  }

  const IValue&amp; toIValue() const {
    return *this;
  }
  IValue&amp; toIValue() {
    return *this;
  }

  IValue(intrusive_ptr&lt;caffe2::Blob&gt; blob)
  : tag(Tag::Blob), is_intrusive_ptr(true) {
    // TODO (after Tensor merge) If we pass in a Blob holding a Tensor, extract
    // and store it as a Tensor instead.
    payload.as_intrusive_ptr = blob.release();
  }
  bool isBlob() const {
    return Tag::Blob == tag;
  }
  c10::intrusive_ptr&lt;caffe2::Blob&gt; toBlob() &amp;&amp; {
    AT_ASSERT(isBlob());
    return moveToIntrusivePtr&lt;caffe2::Blob&gt;();
  }
  c10::intrusive_ptr&lt;caffe2::Blob&gt; toBlob() const &amp; {
    AT_ASSERT(isBlob());
    return toIntrusivePtr&lt;caffe2::Blob&gt;();;
  }

  // Tuple
  IValue(c10::intrusive_ptr&lt;ivalue::Tuple&gt; v);
  bool isTuple() const { return Tag::Tuple == tag; }
  c10::intrusive_ptr&lt;ivalue::Tuple&gt; toTuple() &amp;&amp; {
    AT_ASSERT(isTuple());
    return moveToIntrusivePtr&lt;ivalue::Tuple&gt;();
  }
  c10::intrusive_ptr&lt;ivalue::Tuple&gt; toTuple() const &amp; {
    AT_ASSERT(isTuple());
    return toIntrusivePtr&lt;ivalue::Tuple&gt;();
  }

  // Double
  IValue(double d)
  : tag(Tag::Double), is_intrusive_ptr(false) {
    payload.as_double = d;
  }
  bool isDouble() const { return Tag::Double == tag; }
  double toDouble() const {
    AT_ASSERT(isDouble());
    return payload.as_double;
  }

  // Future
  IValue(c10::intrusive_ptr&lt;ivalue::Future&gt; v);
  bool isFuture() const { return Tag::Future == tag; }
  c10::intrusive_ptr&lt;ivalue::Future&gt; toFuture() &amp;&amp; {
    AT_ASSERT(isFuture());
    return moveToIntrusivePtr&lt;ivalue::Future&gt;();
  }
  c10::intrusive_ptr&lt;ivalue::Future&gt; toFuture() const &amp; {
    AT_ASSERT(isFuture());
    return toIntrusivePtr&lt;ivalue::Future&gt;();
  }

  // Int
  IValue(int64_t i)
  : tag(Tag::Int), is_intrusive_ptr(false) {
    payload.as_int = i;
  }

  // allow you to pass literals (3, 4) without ambiguity
  IValue(int32_t i)
  : IValue(static_cast&lt;int64_t&gt;(i)) {}

  bool isInt() const { return Tag::Int == tag; }

  int64_t toInt() const {
    AT_ASSERT(isInt());
    return payload.as_int;
  }

  // Bool
  IValue(bool b)
  : tag(Tag::Bool), is_intrusive_ptr(false) {
    payload.as_bool = b;
  }
   bool isBool() const { return Tag::Bool == tag; }
   bool toBool() const {
    AT_ASSERT(isBool());
    return payload.as_bool;
  }

  // IntList
  IValue(c10::intrusive_ptr&lt;ivalue::IntList&gt; v);
  IValue(std::vector&lt;int64_t&gt; v);
  IValue(at::ArrayRef&lt;int64_t&gt; v)
  : IValue(v.vec()) {}
  bool isIntList() const { return Tag::IntList == tag; }
  c10::intrusive_ptr&lt;ivalue::IntList&gt; toIntList() &amp;&amp; {
    AT_ASSERT(isIntList());
    return moveToIntrusivePtr&lt;ivalue::IntList&gt;();
  }
  c10::intrusive_ptr&lt;ivalue::IntList&gt; toIntList() const &amp; {
    AT_ASSERT(isIntList());
    return toIntrusivePtr&lt;ivalue::IntList&gt;();
  }

  const std::vector&lt;int64_t&gt;&amp; toIntListRef() const;
  const std::vector&lt;double&gt;&amp; toDoubleListRef() const;
  const std::vector&lt;bool&gt;&amp; toBoolListRef() const;
  const std::vector&lt;at::Tensor&gt;&amp; toTensorListRef() const;
  const std::vector&lt;IValue&gt;&amp; toGenericListRef() const;
  const ivalue::DictUnorderedMap&lt;IValue, IValue&gt;&amp; toGenericDictRef() const;
  const std::string&amp; toStringRef() const;

  // ConstantString
  IValue(c10::intrusive_ptr&lt;ivalue::ConstantString&gt; v);
  IValue(std::string v);
  bool isString() const { return Tag::String == tag; }
  c10::intrusive_ptr&lt;ivalue::ConstantString&gt; toString() &amp;&amp; {
    AT_ASSERT(isString());
    return moveToIntrusivePtr&lt;ivalue::ConstantString&gt;();
  }
  c10::intrusive_ptr&lt;ivalue::ConstantString&gt; toString() const &amp; {
    AT_ASSERT(isString());
    return toIntrusivePtr&lt;ivalue::ConstantString&gt;();
  }

  // DoubleList
  IValue(c10::intrusive_ptr&lt;ivalue::DoubleList&gt; v);
  IValue(std::vector&lt;double&gt; v);
  bool isDoubleList() const { return Tag::DoubleList == tag; }
  c10::intrusive_ptr&lt;ivalue::DoubleList&gt; toDoubleList() &amp;&amp; {
    AT_ASSERT(isDoubleList());
    return moveToIntrusivePtr&lt;ivalue::DoubleList&gt;();
  }
  c10::intrusive_ptr&lt;ivalue::DoubleList&gt; toDoubleList() const &amp; {
    AT_ASSERT(isDoubleList());
    return toIntrusivePtr&lt;ivalue::DoubleList&gt;();
  }

  // BoolList
  IValue(c10::intrusive_ptr&lt;ivalue::BoolList&gt; v);
  IValue(std::vector&lt;bool&gt; v);
  bool isBoolList() const { return Tag::BoolList == tag; }
  c10::intrusive_ptr&lt;ivalue::BoolList&gt; toBoolList() &amp;&amp; {
    AT_ASSERT(isBoolList());
    return moveToIntrusivePtr&lt;ivalue::BoolList&gt;();
  }
  c10::intrusive_ptr&lt;ivalue::BoolList&gt; toBoolList() const &amp; {
    AT_ASSERT(isBoolList());
    return toIntrusivePtr&lt;ivalue::BoolList&gt;();
  }

  //TensorList
  IValue(c10::intrusive_ptr&lt;ivalue::TensorList&gt; v);
  IValue(std::vector&lt;at::Tensor&gt; v);
  bool isTensorList() const { return Tag::TensorList == tag; }
  c10::intrusive_ptr&lt;ivalue::TensorList&gt; toTensorList() &amp;&amp; {
    AT_ASSERT(isTensorList());
    return moveToIntrusivePtr&lt;ivalue::TensorList&gt;();
  }
  c10::intrusive_ptr&lt;ivalue::TensorList&gt; toTensorList() const &amp; {
    AT_ASSERT(isTensorList());
    return toIntrusivePtr&lt;ivalue::TensorList&gt;();
  }

  //GenericList
  IValue(c10::intrusive_ptr&lt;ivalue::GenericList&gt; v);
  IValue(std::vector&lt;IValue&gt; v);
  bool isGenericList() const { return Tag::GenericList == tag; }
  c10::intrusive_ptr&lt;ivalue::GenericList&gt; toGenericList() &amp;&amp; {
    AT_ASSERT(isGenericList());
    return moveToIntrusivePtr&lt;ivalue::GenericList&gt;();
  }
  c10::intrusive_ptr&lt;ivalue::GenericList&gt; toGenericList() const &amp; {
    AT_ASSERT(isGenericList());
    return toIntrusivePtr&lt;ivalue::GenericList&gt;();
  }

  // GenericDict
  IValue(c10::intrusive_ptr&lt;ivalue::GenericDict&gt; v);
  IValue(ivalue::DictUnorderedMap&lt;IValue, IValue&gt; v);
  bool isGenericDict() const { return Tag::GenericDict == tag; }
  c10::intrusive_ptr&lt;ivalue::GenericDict&gt; toGenericDict() &amp;&amp; {
    AT_ASSERT(isGenericDict());
    return moveToIntrusivePtr&lt;ivalue::GenericDict&gt;();
  }
  c10::intrusive_ptr&lt;ivalue::GenericDict&gt; toGenericDict() const &amp; {
    AT_ASSERT(isGenericDict());
    return toIntrusivePtr&lt;ivalue::GenericDict&gt;();
  }

  // None
  bool isNone() const {
    return Tag::None == tag;
  }
  std::string toNone() const {
    AT_ASSERT(isNone());
    return &quot;None&quot;;
  }
  // Scalar, which gets encoded as either an Int or a Double
  IValue(at::Scalar s)
  : IValue() {
    if(s.isFloatingPoint()) {
      *this = s.toDouble();
    } else {
      *this = s.toLong();
    }
  }
  bool isScalar() const {
    return isDouble() || isInt() || isBool();
  }
  at::Scalar toScalar() const {
    if(isDouble())
      return toDouble();
    else if(isInt())
      return toInt();
    else if (isBool())
      return int(toBool());
    throw std::runtime_error(&quot;IValue is not a Scalar&quot;);
  }

  // Device
  IValue(c10::Device d)
  : tag(Tag::Device), is_intrusive_ptr(false) {
    payload.as_device.type = d.type();
    payload.as_device.index = d.index();
  }
  bool isDevice() const { return Tag::Device == tag; }
  c10::Device toDevice() const {
    AT_ASSERT(isDevice());
    return c10::Device(payload.as_device.type, payload.as_device.index);
  }

  // ScalarType
  at::ScalarType toScalarType() const {
    return static_cast&lt;at::ScalarType&gt;(toInt());
  }

  // Layout
  at::Layout toLayout() const {
    return static_cast&lt;at::Layout&gt;(toInt());
  }

  // for debugging
  std::string tagKind() const {
    switch(tag) {
      #define DEFINE_CASE(x) case Tag::x: return #x;
      TORCH_FORALL_TAGS(DEFINE_CASE)
      #undef DEFINE_CASE
    }
    return &quot;Invalid Tag&quot;;
  }

  // generic v.to&lt;at::Tensor&gt;() implementations
  // that can be used in special functions like pop/push
  // that use template meta-programming.
  // prefer the directly named methods when you can,
  // since they are simpler to understand

  // Note: if you get linker errors saying one of these is missing,
  // change it to ... &amp;&amp; = delete; and you will see better error messages for why
  // However, we cannot commit this because some compiler versions barf on it.
  template&lt;typename T&gt;
  T to() &amp;&amp;;
  template&lt;typename T&gt;
  T to() const &amp;;

  // ToOptional: convert a IValue to the Optional obj that accepts both T and None
  template&lt;typename T&gt;
  optional&lt;T&gt; toOptional();

  // this is a shallow comparison of two IValues to test the object identity
  bool isSameIdentity(IValue&amp; rhs);

  CAFFE2_API friend std::ostream&amp; operator&lt;&lt;(
      std::ostream&amp; out,
      const IValue&amp; v);

  bool isPtrType() const {
    return is_intrusive_ptr;
  }

 private:
  // NOTE: IValue tags are intentionally private. In the future we may encode
  // this value different (e.g. using NaN boxing), and this would make it more
  // costly to determine the tag for all types vs just determining if something
  // is a particular type. Instead we want clients to use the `isX` methods when
  // possible. If for perf. reasons you really, absolutely, must have a jump
  // table, then we can revisit this.
  enum class Tag : uint32_t {
#define DEFINE_TAG(x) x,
    TORCH_FORALL_TAGS(DEFINE_TAG)
#undef DEFINE_TAG
  };

  template&lt;class T, class NullType = c10::detail::intrusive_target_default_null_type&lt;T&gt;&gt;
  c10::intrusive_ptr&lt;T, NullType&gt; moveToIntrusivePtr() {
    auto t = c10::intrusive_ptr&lt;T, NullType&gt;::reclaim(static_cast&lt;T*&gt;(payload.as_intrusive_ptr));
    clearToNone();
    return t;
  }
  template&lt;typename T, class NullType = c10::detail::intrusive_target_default_null_type&lt;T&gt;&gt;
  c10::intrusive_ptr&lt;T, NullType&gt; toIntrusivePtr() const {
    auto r = c10::intrusive_ptr&lt;T, NullType&gt;::reclaim(static_cast&lt;T*&gt;(payload.as_intrusive_ptr));
    auto p = r;
    r.release();
    return p;
  }
  void clearToNone() {
    payload.as_int = 0;
    tag = Tag::None;
    is_intrusive_ptr = false;
  }
  union {
    int64_t as_int;
    double as_double;
    bool as_bool;
    c10::intrusive_ptr_target* as_intrusive_ptr;
    struct {
      DeviceType type;
      DeviceIndex index;
    } as_device;
  } payload;
  Tag tag;
  bool is_intrusive_ptr;
};

// Future
struct C10_EXPORT ivalue::Future final : c10::intrusive_ptr_target {
 private:
  c10::intrusive_ptr&lt;Future&gt; intrusive_from_this() {
    c10::raw::intrusive_ptr::incref(this); // we are creating a new pointer
                                           // from a raw `this` pointer
                                           // so we need to bump the refcount
                                           // to account for this ownership
    return c10::intrusive_ptr&lt;Future&gt;::reclaim(this);
  }

 public:
  struct CAFFE2_API FutureError final : public std::exception {
    FutureError(std::string&amp;&amp; error_msg_)
        : error_msg(std::move(error_msg_)) {}

    FutureError() = default;

    const char* what() const noexcept override {
      return error_msg.c_str();
    }

    std::string error_msg;
  };

  void wait() {
    if (completed()) {
      return;
    }
    std::condition_variable finished;
    bool fired = false;

    // Add a callback to notify the current thread
    // when the current future completes.
    addCallback([&amp;] {
      std::unique_lock&lt;std::mutex&gt; lock(mutex_);
      finished.notify_all();
      fired = true;
    });

    // The current thread will be blocked unless the above callback is fired.
    std::unique_lock&lt;std::mutex&gt; lock(mutex_);
    while (!fired) {
      finished.wait(lock);
    }

    AT_ASSERT(completed());
  }

  void markCompleted(IValue value) {
    {
      // This is not to protect completed_ but to create a barrier
      // from possible addCallback() calls
      std::unique_lock&lt;std::mutex&gt; lock(mutex_);
      AT_ASSERT(!completed());
      completed_ = true;
      value_ = std::move(value);
    }

    fireCallbacks();
  }

  void markCompleted(FutureError&amp;&amp; error_) {
    {
      // This is not to protect completed_ but to create a barrier
      // from possible addCallback() calls
      std::unique_lock&lt;std::mutex&gt; lock(mutex_);
      AT_ASSERT(!completed());
      completed_ = true;
      has_error = true;
      error = std::move(error_);
    }

    fireCallbacks();
  }

  // Get the result of the current future.
  IValue value() {
    std::unique_lock&lt;std::mutex&gt; lock(mutex_);
    AT_ASSERT(completed());
    if (has_error) {
      throw error;
    }
    return value_;
  }

  void addCallback(std::function&lt;void(void)&gt; callback) {
    std::unique_lock&lt;std::mutex&gt; lock(mutex_);
    if (completed()) {
      lock.unlock();
      callback();
      return;
    }
    callbacks.push_back(callback);
  }

  // Check if the current future has completed
  bool completed() {
    return completed_;
  }

  CAFFE2_API friend std::ostream&amp; operator&lt;&lt;(
      std::ostream&amp; out,
      const Future&amp; v);

 private:
  void fireCallbacks() {
    AT_ASSERT(completed());
    // There is no need to protect callbacks with the lock.
    // Once completed_ is set to true, no one can add new callback to the list.
    for (auto&amp; callback : callbacks) {
      callback();
    }
    callbacks.clear();
  }

  std::mutex mutex_;
  IValue value_; // when finished the value
  std::atomic_bool completed_ = {false}; // is this future complete
  std::vector&lt;std::function&lt;void(void)&gt;&gt; callbacks;
  bool has_error = false;
  FutureError error;
};

#undef TORCH_FORALL_TAGS

namespace detail {

struct _guarded_unsigned_long_unique_dummy final {
  _guarded_unsigned_long_unique_dummy(int64_t){};
};
using _guarded_unsigned_long = c10::guts::conditional_t&lt;
    std::is_same&lt;unsigned long, uint32_t&gt;::value ||
        std::is_same&lt;unsigned long, uint64_t&gt;::value,
    _guarded_unsigned_long_unique_dummy,
    unsigned long&gt;;

} // namespace detail

#define DEFINE_TO(type, method_name) \
template&lt;&gt; \
inline type IValue::to&lt;type&gt;() &amp;&amp; { \
  return std::move(*this).method_name(); \
} \
template&lt;&gt; \
inline type IValue::to&lt;type&gt;() const &amp; { \
  return this-&gt;method_name(); \
}
DEFINE_TO(at::Tensor, toTensor)
DEFINE_TO(c10::intrusive_ptr&lt;ivalue::Tuple&gt;, toTuple)
DEFINE_TO(float, toDouble)
DEFINE_TO(double, toDouble)
DEFINE_TO(unsigned char, toInt)
DEFINE_TO(signed char, toInt)
DEFINE_TO(unsigned short, toInt)
DEFINE_TO(short, toInt)
DEFINE_TO(int, toInt)
DEFINE_TO(uint32_t, toInt)
DEFINE_TO(uint64_t, toInt)
DEFINE_TO(detail::_guarded_unsigned_long, toInt)
DEFINE_TO(int64_t, toInt)
DEFINE_TO(bool, toBool)
DEFINE_TO(c10::intrusive_ptr&lt;caffe2::Blob&gt;, toBlob);
DEFINE_TO(c10::intrusive_ptr&lt;ivalue::DoubleList&gt;, toDoubleList)
DEFINE_TO(c10::intrusive_ptr&lt;ivalue::IntList&gt;, toIntList)
DEFINE_TO(c10::intrusive_ptr&lt;ivalue::BoolList&gt;, toBoolList)
DEFINE_TO(c10::intrusive_ptr&lt;ivalue::TensorList&gt;, toTensorList)
DEFINE_TO(c10::intrusive_ptr&lt;ivalue::GenericList&gt;, toGenericList)
DEFINE_TO(c10::intrusive_ptr&lt;ivalue::GenericDict&gt;, toGenericDict)
DEFINE_TO(c10::intrusive_ptr&lt;ivalue::ConstantString&gt;, toString)
DEFINE_TO(at::Scalar, toScalar)
DEFINE_TO(std::vector&lt;int64_t&gt;, toIntListRef)
DEFINE_TO(std::vector&lt;double&gt;, toDoubleListRef)
DEFINE_TO(std::vector&lt;bool&gt;, toBoolListRef)
DEFINE_TO(std::vector&lt;at::Tensor&gt;, toTensorListRef)
DEFINE_TO(std::vector&lt;IValue&gt;, toGenericListRef)
DEFINE_TO(std::string, toStringRef)
DEFINE_TO(c10::intrusive_ptr&lt;ivalue::Future&gt;, toFuture)
DEFINE_TO(IValue, toIValue)
DEFINE_TO(c10::Device, toDevice)
DEFINE_TO(at::ScalarType, toScalarType)
DEFINE_TO(at::Layout, toLayout)

// note: when adding a DEFINE_TO case here you should also add a
// toX method to IValue. These named methods are much more discoverable
// than the to templated function.

inline IValue::IValue(c10::intrusive_ptr&lt;ivalue::Tuple&gt; v)
: tag(Tag::Tuple), is_intrusive_ptr(true) {
  payload.as_intrusive_ptr = v.release();
}

inline IValue::IValue(c10::intrusive_ptr&lt;ivalue::IntList&gt; v)
: tag(Tag::IntList), is_intrusive_ptr(true) {
  payload.as_intrusive_ptr = v.release();
}
inline IValue::IValue(std::vector&lt;int64_t&gt; v)
: IValue(ivalue::IntList::create(std::move(v))) {}

inline IValue::IValue(c10::intrusive_ptr&lt;ivalue::ConstantString&gt; v)
: tag(Tag::String), is_intrusive_ptr(true) {
  payload.as_intrusive_ptr = v.release();
}
inline IValue::IValue(std::string v)
: IValue(ivalue::ConstantString::create(std::move(v))) {}

inline IValue::IValue(c10::intrusive_ptr&lt;ivalue::DoubleList&gt; v)
: tag(Tag::DoubleList), is_intrusive_ptr(true) {
  payload.as_intrusive_ptr = v.release();
}
inline IValue::IValue(std::vector&lt;double&gt; v)
: IValue(ivalue::DoubleList::create(std::move(v))) {}

inline IValue::IValue(c10::intrusive_ptr&lt;ivalue::BoolList&gt; v)
: tag(Tag::BoolList), is_intrusive_ptr(true) {
  payload.as_intrusive_ptr = v.release();
}
inline IValue::IValue(std::vector&lt;bool&gt; v)
: IValue(ivalue::BoolList::create(std::move(v))) {}

inline IValue::IValue(c10::intrusive_ptr&lt;ivalue::TensorList&gt; v)
: tag(Tag::TensorList), is_intrusive_ptr(true) {
  payload.as_intrusive_ptr = v.release();
}
inline IValue::IValue(std::vector&lt;at::Tensor&gt; v)
: IValue(ivalue::TensorList::create(std::move(v))) {}

inline IValue::IValue(c10::intrusive_ptr&lt;ivalue::GenericList&gt; v)
: tag(Tag::GenericList), is_intrusive_ptr(true) {
  payload.as_intrusive_ptr = v.release();
}
inline IValue::IValue(std::vector&lt;IValue&gt; v)
: IValue(ivalue::GenericList::create(std::move(v))) {}

inline IValue::IValue(c10::intrusive_ptr&lt;ivalue::GenericDict&gt; v)
: tag(Tag::GenericDict), is_intrusive_ptr(true) {
  payload.as_intrusive_ptr = v.release();
}
inline IValue::IValue(ivalue::DictUnorderedMap&lt;IValue, IValue&gt; v)
: IValue(ivalue::GenericDict::create(std::move(v))) {}

inline IValue::IValue(c10::intrusive_ptr&lt;ivalue::Future&gt; v)
: tag(Tag::Future), is_intrusive_ptr(true) {
  payload.as_intrusive_ptr = v.release();
}

inline const std::vector&lt;int64_t&gt;&amp; IValue::toIntListRef() const {
  return toIntList()-&gt;elements();
}

inline const std::vector&lt;double&gt;&amp; IValue::toDoubleListRef() const {
  return toDoubleList()-&gt;elements();
}

inline const std::vector&lt;at::Tensor&gt;&amp; IValue::toTensorListRef() const {
  return toTensorList()-&gt;elements();
}

inline const std::vector&lt;bool&gt;&amp; IValue::toBoolListRef() const {
  return toBoolList()-&gt;elements();
}

inline const std::vector&lt;IValue&gt;&amp; IValue::toGenericListRef() const {
  return toGenericList()-&gt;elements();
}

inline const c10::ivalue::DictUnorderedMap&lt;IValue, IValue&gt;&amp; IValue::
    toGenericDictRef() const {
  return toGenericDict()-&gt;elements();
}

inline const std::string&amp; IValue::toStringRef() const {
  return toString()-&gt;string();
}

template&lt;typename T&gt;
inline optional&lt;T&gt; IValue::toOptional() {
  if (this-&gt;isNone()) {
    return nullopt;
  }
  return this-&gt;to&lt;T&gt;();
}

inline bool IValue::isSameIdentity(IValue&amp; rhs) {
  // We choose to not use memcmp for payload check due to potential random padding characters on union type

  // Semantics:
  // 1. None is None, False is False, and True is True are all true
  // 2. If it is a tensor type, we need to take undefined tensor into account
  // 3. Undefined_tensor is None and vice versa should be true
  // 4. If it is a reference type (i.e. is_intrusive_ptr), then is is True when the pointed-to object is the same.
  // 5. False for all other comparisons.
  if (this-&gt;isNone() &amp;&amp; rhs.isNone()) {
    return true;
  } else if (this-&gt;isBool() &amp;&amp; rhs.isBool()) {
    // for bool type, do equality check
    return this-&gt;toBool() == rhs.toBool();
  } else if (this-&gt;isTensor() &amp;&amp; rhs.isTensor()) {
    // for tensor type, just check the as_intrusive_ptr since is_intrusive_ptr is false for undefined tensor
    return this-&gt;payload.as_intrusive_ptr == rhs.payload.as_intrusive_ptr;
  } else if (this-&gt;isTensor() &amp;&amp; rhs.isNone()) {
    // special case: undefined tensor and None are the same identity
    return !this-&gt;is_intrusive_ptr;
  } else if (this-&gt;isNone() &amp;&amp; rhs.isTensor()) {
    // special case: undefined tensor and None are the same identity
    return !rhs.is_intrusive_ptr;
  } else {
    // for objects holding in IValue, do shallow compare on pointer address to testify the identity
    return this-&gt;is_intrusive_ptr &amp;&amp; rhs.is_intrusive_ptr
        &amp;&amp; this-&gt;payload.as_intrusive_ptr == rhs.payload.as_intrusive_ptr;
  }
}
} // namespace c10

inline size_t at::ivalue::DictHash::operator()(
    const c10::IValue&amp; ivalue) const {
  if (ivalue.isInt()) {
    return std::hash&lt;int&gt;()(ivalue.toInt());
  } else if (ivalue.isString()) {
    return std::hash&lt;std::string&gt;()(ivalue.toStringRef());
  } else if (ivalue.isDouble()) {
    return std::hash&lt;double&gt;()(ivalue.toDouble());
  } else {
    throw std::runtime_error(&quot;Can&#39;t hash IValues with this tag&quot;);
  }
}

inline bool at::ivalue::DictEqualTo::operator()(
    const c10::IValue&amp; lhs,
    const c10::IValue&amp; rhs) const {
  if (lhs.isInt()) {
    return lhs.toInt() == rhs.toInt();
  } else if (lhs.isString()) {
    return lhs.toStringRef() == rhs.toStringRef();
  } else if (lhs.isDouble()) {
    return lhs.toDouble() == rhs.toDouble();
  } else {
    throw std::runtime_error(&quot;Can&#39;t compare IValues with this tag&quot;);
  }
}
</pre></div>
</div>
</div>


             </article>
             
            </div>
            <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_torch_csrc_api_include_torch_jit.h.html" class="btn btn-neutral float-right" title="File jit.h" accesskey="n" rel="next">Next <img src="../_static/images/chevron-right-orange.svg" class="next-page"></a>
      
      
        <a href="file_aten_src_ATen_core_ivalue.h.html" class="btn btn-neutral" title="File ivalue.h" accesskey="p" rel="prev"><img src="../_static/images/chevron-right-orange.svg" class="previous-page"> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Torch Contributors.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

          </div>
        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              <ul>
<li><a class="reference internal" href="#">Program Listing for File ivalue.h</a></li>
</ul>

            </div>
          </div>
        </div>
      </section>
    </div>

  


  

     
       <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
         <script type="text/javascript" src="../_static/jquery.js"></script>
         <script type="text/javascript" src="../_static/underscore.js"></script>
         <script type="text/javascript" src="../_static/doctools.js"></script>
         <script type="text/javascript" src="../_static/language_data.js"></script>
         <script type="text/javascript" src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
         <script type="text/javascript" src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
     

  

  <script type="text/javascript" src="../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../_static/js/vendor/bootstrap.min.js"></script>
  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

  <!-- Begin Footer -->

  <div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
    <div class="container">
      <div class="row">
        <div class="col-md-4 text-center">
          <h2>Docs</h2>
          <p>Access comprehensive developer documentation for PyTorch</p>
          <a class="with-right-arrow" href="https://pytorch.org/docs/stable/index.html">View Docs</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Tutorials</h2>
          <p>Get in-depth tutorials for beginners and advanced developers</p>
          <a class="with-right-arrow" href="https://pytorch.org/tutorials">View Tutorials</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Resources</h2>
          <p>Find development resources and get your questions answered</p>
          <a class="with-right-arrow" href="https://pytorch.org/resources">View Resources</a>
        </div>
      </div>
    </div>
  </div>

  <footer class="site-footer">
    <div class="container footer-container">
      <div class="footer-logo-wrapper">
        <a href="https://pytorch.org/" class="footer-logo"></a>
      </div>

      <div class="footer-links-wrapper">
        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/">PyTorch</a></li>
            <li><a href="https://pytorch.org/get-started">Get Started</a></li>
            <li><a href="https://pytorch.org/features">Features</a></li>
            <li><a href="https://pytorch.org/ecosystem">Ecosystem</a></li>
            <li><a href="https://pytorch.org/blog/">Blog</a></li>
            <li><a href="https://pytorch.org/resources">Resources</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/support">Support</a></li>
            <li><a href="https://pytorch.org/tutorials">Tutorials</a></li>
            <li><a href="https://pytorch.org/docs/stable/index.html">Docs</a></li>
            <li><a href="https://discuss.pytorch.org" target="_blank">Discuss</a></li>
            <li><a href="https://github.com/pytorch/pytorch/issues" target="_blank">Github Issues</a></li>
            <li><a href="https://pytorch.slack.com" target="_blank">Slack</a></li>
            <li><a href="https://github.com/pytorch/pytorch/blob/master/CONTRIBUTING.md" target="_blank">Contributing</a></li>
          </ul>
        </div>

        <div class="footer-links-col follow-us-col">
          <ul>
            <li class="list-title">Follow Us</li>
            <li>
              <div id="mc_embed_signup">
                <form
                  action="https://twitter.us14.list-manage.com/subscribe/post?u=75419c71fe0a935e53dfa4a3f&id=91d0dccd39"
                  method="post"
                  id="mc-embedded-subscribe-form"
                  name="mc-embedded-subscribe-form"
                  class="email-subscribe-form validate"
                  target="_blank"
                  novalidate>
                  <div id="mc_embed_signup_scroll" class="email-subscribe-form-fields-wrapper">
                    <div class="mc-field-group">
                      <label for="mce-EMAIL" style="display:none;">Email Address</label>
                      <input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" placeholder="Email Address">
                    </div>

                    <div id="mce-responses" class="clear">
                      <div class="response" id="mce-error-response" style="display:none"></div>
                      <div class="response" id="mce-success-response" style="display:none"></div>
                    </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->

                    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_75419c71fe0a935e53dfa4a3f_91d0dccd39" tabindex="-1" value=""></div>

                    <div class="clear">
                      <input type="submit" value="" name="subscribe" id="mc-embedded-subscribe" class="button email-subscribe-button">
                    </div>
                  </div>
                </form>
              </div>

            </li>
          </ul>

          <div class="footer-social-icons">
            <a href="https://www.facebook.com/pytorch" target="_blank" class="facebook"></a>
            <a href="https://twitter.com/pytorch" target="_blank" class="twitter"></a>
          </div>
        </div>
      </div>
    </div>
  </footer>

  <!-- End Footer -->

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="#">Get Started</a>
          </li>

          <li>
            <a href="#">Features</a>
          </li>

          <li>
            <a href="#">Ecosystem</a>
          </li>

          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>

          <li>
            <a href="https://pytorch.org/tutorials">Tutorials</a>
          </li>

          <li class="active">
            <a href="https://pytorch.org/docs/stable/index.html">Docs</a>
          </li>

          <li>
            <a href="https://pytorch.org/resources">Resources</a>
          </li>

          <li>
            <a href="https://github.com/pytorch/pytorch">Github</a>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>