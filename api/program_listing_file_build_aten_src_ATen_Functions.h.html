


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File Functions.h &mdash; PyTorch master documentation</title>
  

  
  
  
  
    <link rel="canonical" href="https://pytorch.org/docs/stable/api/program_listing_file_build_aten_src_ATen_Functions.h.html"/>
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>
</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>
          <li>
            <a href="https://pytorch.org/get-started">Get Started</a>
          </li>

          <li>
            <a href="https://pytorch.org/features">Features</a>
          </li>

          <li>
            <a href="https://pytorch.org/ecosystem">Ecosystem</a>
          </li>

          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>

          <li>
            <a href="https://pytorch.org/tutorials">Tutorials</a>
          </li>

          <li class="active">
            <a href="https://pytorch.org/docs/stable/index.html">Docs</a>
          </li>

          <li>
            <a href="https://pytorch.org/resources">Resources</a>
          </li>

          <li>
            <a href="https://github.com/pytorch/pytorch">Github</a>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>

  </div>
</div>


<body class="pytorch-body">

   

    

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">
            

            
              
              
                <div class="version">
                  master
                </div>
              
            

            


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

            
          </div>

          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../installing.html">Installing C++ Distributions of PyTorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../frontend.html">The C++ Frontend</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing to PyTorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="library_root.html">Library API</a></li>
</ul>
<p class="caption"><span class="caption-text">Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../notes/faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notes/tensor_basics.html">Tensor Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notes/tensor_creation.html">Tensor Creation API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="../index.html">
          
            Docs
          
        </a> &gt;
      </li>

        
      <li>Program Listing for File Functions.h</li>
    
    
      <li class="pytorch-breadcrumbs-aside">
        
            
            
              <!-- User defined GitHub URL -->
              <a href="https://github.com/pytorch/pytorch" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">

        
          
          <div class="rst-content">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
              
  <div class="section" id="program-listing-for-file-functions-h">
<span id="program-listing-file-build-aten-src-aten-functions-h"></span><h1>Program Listing for File Functions.h<a class="headerlink" href="#program-listing-for-file-functions-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_build_aten_src_ATen_Functions.h.html#file-build-aten-src-aten-functions-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">build/aten/src/ATen/Functions.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>

<span class="c1">// @generated by aten/src/ATen/gen.py</span>

<span class="cp">#include</span> <span class="cpf">&lt;c10/core/Scalar.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ATen/Tensor.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;c10/core/Storage.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ATen/core/Generator.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;c10/util/Deprecated.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ATen/NativeFunctions.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ATen/DeviceGuard.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;c10/core/TensorOptions.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ATen/core/Reduction.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;c10/util/Optional.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ATen/TensorUtils.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ATen/core/ATenDispatch.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ATen/Context.h&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">at</span> <span class="p">{</span>

<span class="k">using</span> <span class="n">native</span><span class="o">::</span><span class="n">tensor</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_cast_Byte</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_cast_Char</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_cast_Double</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_cast_Float</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_cast_Int</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_cast_Long</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_cast_Short</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_cast_Half</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_cudnn_ctc_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_probs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">targets</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_lengths</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">target_lengths</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">blank</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">zero_infinity</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_cudnn_rnn_flatten_weight</span><span class="p">(</span><span class="n">TensorList</span> <span class="n">weight_arr</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">weight_stride0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">hidden_size</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_cudnn_rnn</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">weight_stride0</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight_buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cx</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">hidden_size</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">dropout_state</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;&gt;</span> <span class="n">_cudnn_rnn_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">weight_stride0</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight_buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_hy</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_cy</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">hidden_size</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">dropout_state</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_cudnn_init_dropout_state</span><span class="p">(</span><span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dropout_seed</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">_debug_has_internal_overlap</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_fused_dropout</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_masked_scale</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">double</span> <span class="n">scale</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_sobol_engine_draw</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">quasi</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sobolstate</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dimension</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_generated</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sobol_engine_ff_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sobolstate</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dimension</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_generated</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sobol_engine_scramble_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ltm</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dimension</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sobol_engine_initialize_state_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dimension</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_reshape_from_tensor</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">shape</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_shape_as_tensor</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">dropout</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">dropout_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">feature_dropout</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">feature_dropout_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">alpha_dropout</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">alpha_dropout_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">feature_alpha_dropout</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">feature_alpha_dropout_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">abs</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">abs_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">abs_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">acos</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">acos_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">acos_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">avg_pool1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">adaptive_avg_pool1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">adaptive_max_pool1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">add</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">add_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">add</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">addmv</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">addmv_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">addmv_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">addr</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">addr_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">affine_grid_generator</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">theta</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">affine_grid_generator_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">all</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">all_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">allclose</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="kt">double</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="kt">double</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">equal_nan</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">any</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">any_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">arange</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">arange</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">arange</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">step</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">arange_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">arange_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_dim_arange</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">like</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">argmax</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">dim</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">argmin</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">dim</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">as_strided</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">storage_offset</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">as_strided_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">storage_offset</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">asin</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">asin_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">asin_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">atan</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">atan_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">atan_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">baddbmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_baddbmm_mkl_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">baddbmm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">bartlett_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">bartlett_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">periodic</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">batch_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">,</span> <span class="kt">double</span> <span class="n">momentum</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cudnn_enabled</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">_batch_norm_impl_index</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">,</span> <span class="kt">double</span> <span class="n">momentum</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cudnn_enabled</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_batch_norm_impl_index_backward</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">impl_index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">save_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">save_var_transform</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">bernoulli</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bernoulli_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">bernoulli</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">bilinear</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">binary_cross_entropy_with_logits</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="o">=</span><span class="p">{},</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">pos_weight</span><span class="o">=</span><span class="p">{},</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">binary_cross_entropy_with_logits_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="o">=</span><span class="p">{},</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">pos_weight</span><span class="o">=</span><span class="p">{},</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">bincount</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weights</span><span class="o">=</span><span class="p">{},</span> <span class="kt">int64_t</span> <span class="n">minlength</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">bitwise_not</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bitwise_not_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">blackman_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">blackman_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">periodic</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">bmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bmm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">broadcast_tensors</span><span class="p">(</span><span class="n">TensorList</span> <span class="n">tensors</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cat</span><span class="p">(</span><span class="n">TensorList</span> <span class="n">tensors</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cat_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">tensors</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">ceil</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ceil_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ceil_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">chain_matmul</span><span class="p">(</span><span class="n">TensorList</span> <span class="n">matrices</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">chunk</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">chunks</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">clamp</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">min</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">max</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">clamp_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">min</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">max</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">clamp_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">min</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">max</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">clamp_max</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">clamp_max_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">clamp_max_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">clamp_min</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">clamp_min_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">clamp_min_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">cudnn_is_acceptable</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">constant_pad_nd</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">pad</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">convolution</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transposed</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_convolution</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transposed</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cudnn_enabled</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_convolution_nogroup</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transposed</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_convolution_double_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ggI</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ggW</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ggb</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">gO</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transposed</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cudnn_enabled</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">conv1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">conv2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">conv3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">conv_tbc</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">conv_tbc_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">pad</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">conv_transpose1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">conv_transpose2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">conv_transpose3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_copy_from</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cos</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cos_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cos_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cosh</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cosh_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cosh_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cosine_embedding_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">margin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cudnn_affine_grid_generator</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">theta</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">C</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">H</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">W</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cudnn_affine_grid_generator_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">C</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">H</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">W</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">cudnn_batch_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">,</span> <span class="kt">double</span> <span class="n">exponential_average_factor</span><span class="p">,</span> <span class="kt">double</span> <span class="n">epsilon</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">cudnn_batch_norm_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">save_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">save_var</span><span class="p">,</span> <span class="kt">double</span> <span class="n">epsilon</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cudnn_convolution</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cudnn_convolution_backward_input</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">self_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">cudnn_convolution_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cudnn_convolution_backward_bias</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cudnn_convolution_backward_weight</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">weight_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cudnn_convolution_transpose</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">cudnn_convolution_transpose_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cudnn_convolution_transpose_backward_bias</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cudnn_convolution_transpose_backward_input</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cudnn_convolution_transpose_backward_weight</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">weight_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cudnn_grid_sampler</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grid</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">cudnn_grid_sampler_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cumsum</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cumsum_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cumprod</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cumprod_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">ctc_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_probs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">targets</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_lengths</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">target_lengths</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">blank</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">zero_infinity</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">ctc_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_probs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">targets</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input_lengths</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target_lengths</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">blank</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">zero_infinity</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_ctc_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_probs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">targets</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_lengths</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">target_lengths</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">blank</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">zero_infinity</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_ctc_loss_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_probs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">targets</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_lengths</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">target_lengths</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">neg_log_likelihood</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_alpha</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">blank</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">zero_infinity</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">det</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">diag_embed</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim1</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim2</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">diagflat</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">diagonal</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim2</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">div</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">div_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">div</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">dot</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">dot_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">einsum</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">equation</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">tensors</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">embedding</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_idx</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sparse</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">embedding_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_weights</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_idx</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sparse</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">embedding_dense_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_weights</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_idx</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">embedding_renorm_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="kt">double</span> <span class="n">max_norm</span><span class="p">,</span> <span class="kt">double</span> <span class="n">norm_type</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">embedding_sparse_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_weights</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_idx</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">embedding_bag</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offsets</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sparse</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">per_sample_weights</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_embedding_bag</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offsets</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sparse</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">per_sample_weights</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_embedding_bag_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offsets</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offset2bag</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bag_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">maximum_indices</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_weights</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sparse</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">per_sample_weights</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_embedding_bag_sparse_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offsets</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offset2bag</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bag_size</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_weights</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">per_sample_weights</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_embedding_bag_dense_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offsets</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offset2bag</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bag_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">maximum_indices</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_weights</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">per_sample_weights</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_embedding_bag_per_sample_weights_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offsets</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offset2bag</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="cp">#ifdef BUILD_NAMEDTENSOR</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">empty</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">DimnameList</span><span class="o">&gt;</span> <span class="n">names</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">empty</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{},</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MemoryFormat</span><span class="o">&gt;</span> <span class="n">memory_format</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_empty_affine_quantized</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{},</span> <span class="kt">double</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">zero_point</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MemoryFormat</span><span class="o">&gt;</span> <span class="n">memory_format</span><span class="o">=</span><span class="n">MemoryFormat</span><span class="o">::</span><span class="n">Contiguous</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">empty_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MemoryFormat</span><span class="o">&gt;</span> <span class="n">memory_format</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">empty_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">empty_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MemoryFormat</span><span class="o">&gt;</span> <span class="n">memory_format</span><span class="o">=</span><span class="n">MemoryFormat</span><span class="o">::</span><span class="n">Contiguous</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">empty_strided</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">erf</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">erf_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">erf_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">erfc</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">erfc_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">erfc_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">exp</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">exp_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">exp_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">expm1</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">expm1_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">expm1_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">eye</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">eye</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">eye_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">eye_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">m</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">flatten</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">end_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fill_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fill_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">floor</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">floor_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">floor_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">frac</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">frac_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">frac_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">full</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">fill_value</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">full_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">fill_value</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">full_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">fill_value</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">full_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">fill_value</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">from_file</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">filename</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">shared</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">grid_sampler</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">interpolation_mode</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_mode</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">grid_sampler_2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">interpolation_mode</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_mode</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">grid_sampler_2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">interpolation_mode</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_mode</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">grid_sampler_3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">interpolation_mode</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_mode</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">grid_sampler_3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">interpolation_mode</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_mode</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">hann_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">hann_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">periodic</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">hamming_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">hamming_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">periodic</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">hamming_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">periodic</span><span class="p">,</span> <span class="kt">double</span> <span class="n">alpha</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">hamming_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">periodic</span><span class="p">,</span> <span class="kt">double</span> <span class="n">alpha</span><span class="p">,</span> <span class="kt">double</span> <span class="n">beta</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">hinge_embedding_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">margin</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">ger</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec2</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ger_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec2</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">group_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_groups</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="o">=</span><span class="p">{},</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="kt">double</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cudnn_enabled</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">fft</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">signal_ndim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">normalized</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">ifft</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">signal_ndim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">normalized</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">rfft</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">signal_ndim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">normalized</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">onesided</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">irfft</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">signal_ndim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">normalized</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">onesided</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">signal_sizes</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_fft_with_size</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">signal_ndim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">complex_input</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">complex_output</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">inverse</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">checked_signal_sizes</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">normalized</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">onesided</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_sizes</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">_cufft_get_plan_cache_size</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">device_index</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">_cufft_get_plan_cache_max_size</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">device_index</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_cufft_set_plan_cache_max_size</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">device_index</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">max_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_cufft_clear_plan_cache</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">device_index</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">index</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">indices</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">index_copy</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index_put_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">accumulate</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">index_put</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">accumulate</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_index_put_impl_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">accumulate</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unsafe</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">instance_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">use_input_stats</span><span class="p">,</span> <span class="kt">double</span> <span class="n">momentum</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cudnn_enabled</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">inverse_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_inverse_helper</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">isclose</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="kt">double</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="kt">double</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">equal_nan</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">isnan</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_distributed</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_floating_point</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_complex</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_nonzero</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_same_size</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_signed</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">kl_div</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">kl_div_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">kthvalue</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">kthvalue_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">layer_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">normalized_shape</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="o">=</span><span class="p">{},</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="kt">double</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cudnn_enable</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">native_layer_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">N</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">native_layer_norm_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rstd</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">N</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">native_layer_norm_double_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ggI</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ggW</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ggb</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">gO</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rstd</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">N</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">linear</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">mkldnn_linear</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">fbgemm_linear_int8_weight</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">weight_scale</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">weight_zero_point</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="kt">double</span><span class="p">,</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">fbgemm_linear_quantize_weight</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">fbgemm_pack_gemm_matrix_fp16</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">fbgemm_linear_fp16_weight</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">fbgemm_pack_quantized_matrix</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">K</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">N</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">fbgemm_is_cpu_supported</span><span class="p">();</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">linspace</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">steps</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">linspace_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">steps</span><span class="o">=</span><span class="mi">100</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">log</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">log10</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log10_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log10_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">log1p</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log1p_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log1p_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">log2</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log2_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log2_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">logdet</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">logspace</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">steps</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="kt">double</span> <span class="n">base</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">logspace_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">steps</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="kt">double</span> <span class="n">base</span><span class="o">=</span><span class="mf">10.0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">log_softmax</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_log_softmax</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">half_to_float</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_log_softmax_backward_data</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">logsumexp</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">logsumexp_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">margin_ranking_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">margin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">matmul</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">matmul_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">matrix_rank</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">tol</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">symmetric</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">matrix_rank</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">symmetric</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">matrix_power</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">max</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">max_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_values</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">max_values</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">max_pool1d_with_indices</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">max_pool1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">max_pool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">mkldnn_max_pool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">max_pool3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">mean</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">mean</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">median</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">median_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">min</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">min_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">min_indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">min_values</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">mkldnn_convolution</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">mkldnn_convolution_backward_input</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">self_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bias_defined</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">mkldnn_convolution_backward_weights</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">weight_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bias_defined</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">mkldnn_convolution_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">miopen_batch_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">,</span> <span class="kt">double</span> <span class="n">exponential_average_factor</span><span class="p">,</span> <span class="kt">double</span> <span class="n">epsilon</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">miopen_batch_norm_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">save_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">save_var</span><span class="p">,</span> <span class="kt">double</span> <span class="n">epsilon</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">miopen_convolution</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">miopen_convolution_backward_input</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">self_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">miopen_convolution_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">miopen_convolution_backward_bias</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">miopen_convolution_backward_weight</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">weight_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">miopen_convolution_transpose</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">miopen_convolution_transpose_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">miopen_convolution_transpose_backward_input</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">miopen_convolution_transpose_backward_weight</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">weight_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">miopen_depthwise_convolution</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">miopen_depthwise_convolution_backward_input</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">self_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">miopen_depthwise_convolution_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">miopen_depthwise_convolution_backward_weight</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">weight_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">mm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_sparse_mm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sparse</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">dense</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">mode</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">mode_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">mul</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mul_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">mul</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">mv</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mv_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">mvlgamma</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">p</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">narrow</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">length</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">native_batch_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">,</span> <span class="kt">double</span> <span class="n">momentum</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">batch_norm_stats</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">batch_norm_elemt</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">invstd</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">batch_norm_gather_stats</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">invstd</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">double</span> <span class="n">momentum</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">count</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">batch_norm_gather_stats_with_counts</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">invstd</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">double</span> <span class="n">momentum</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">counts</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">native_batch_norm_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">save_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">save_invstd</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">batch_norm_backward_reduce</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">invstd</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">input_g</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">weight_g</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bias_g</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">batch_norm_backward_elemt</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">invstd</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean_dy</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean_dy_xmu</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">batch_norm_update_stats</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">double</span> <span class="n">momentum</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">_nnpack_available</span><span class="p">();</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_nnpack_spatial_convolution</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_nnpack_spatial_convolution_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_nnpack_spatial_convolution_backward_input</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_nnpack_spatial_convolution_backward_weight</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">weightsize</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">ones</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ones_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">ones_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">ones_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">pairwise_distance</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-06</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cdist</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_cdist_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cdist</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">pdist</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_pdist_forward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_pdist_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">pdist</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cosine_similarity</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">pixel_shuffle</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">upscale_factor</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">pin_memory</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">pinverse</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">rcond</span><span class="o">=</span><span class="mf">1e-15</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">poisson_nll_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">log_input</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">full</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">scalar_tensor</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">rand</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">rand</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rand_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rand_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">rand_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">rand_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">randint</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">randint</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">randint</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">randint</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">randint_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">randint_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">randint_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">randint_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">randint_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">randint_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">randint_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">randint_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">randn</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">randn</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">randn_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">randn_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">randn_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">randn_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">randperm</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">randperm</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">randperm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">randperm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">range</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">range</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">range_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">reciprocal</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">reciprocal_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">reciprocal_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">neg</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">neg_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">neg_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">repeat_interleave</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">repeats</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">repeat_interleave</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">dim</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">repeat_interleave</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">dim</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">reshape</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">shape</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_mkldnn_reshape</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">shape</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">round</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">round_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">round_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">rrelu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lower</span><span class="o">=</span><span class="mf">0.125</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">upper</span><span class="o">=</span><span class="mf">0.3333333333333333</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rrelu_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lower</span><span class="o">=</span><span class="mf">0.125</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">upper</span><span class="o">=</span><span class="mf">0.3333333333333333</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">relu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">relu_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">prelu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">prelu_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">gelu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">gelu_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">hardshrink</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lambd</span><span class="o">=</span><span class="mf">0.5</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">hardshrink_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lambd</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">rsqrt</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rsqrt_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rsqrt_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="cp">#ifdef BUILD_NAMEDTENSOR</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">select</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Dimname</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">index</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">select</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">index</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">selu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">selu_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">celu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">celu_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sigmoid_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sigmoid_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">sin</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sin_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sin_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">sinh</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sinh_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sinh_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">detach</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">detach_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">size</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">slice</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">end</span><span class="o">=</span><span class="mi">9223372036854775807</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">slogdet</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">smm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">softmax</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_softmax</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">half_to_float</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_softmax_backward_data</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sparse_add_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sparse_dense_add_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sparse_div_zerodim_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sparse_div_scalar_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sparse_mul_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sparse_mul_zerodim_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sparse_mul_scalar_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">split</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">split_size</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">split_with_sizes</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">split_sizes</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">squeeze</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">squeeze</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">sspaddmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sspaddmm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">stack</span><span class="p">(</span><span class="n">TensorList</span> <span class="n">tensors</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">stack_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">tensors</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">stft</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n_fft</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">win_length</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">window</span><span class="o">=</span><span class="p">{},</span> <span class="kt">bool</span> <span class="n">normalized</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">onesided</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">stride</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">sum</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">sum</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sum_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">sqrt</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sqrt_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sqrt_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">std</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">std</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">std_mean</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">std_mean</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">std_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">prod</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">prod</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">prod_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">t</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">tan</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tan_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tan_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">tanh</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tanh_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tanh_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">tensordot</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dims_self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dims_other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">threshold</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">threshold_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">threshold_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">threshold_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">threshold</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">transpose</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_mkldnn_transpose</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_mkldnn_transpose_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">one_hot</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_classes</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">flip</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dims</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">roll</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dims</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">rot90</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dims</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">trapz</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">trapz</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dx</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_trilinear</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">i1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">i2</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">i3</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">expand1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">expand2</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">expand3</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">sumdim</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">unroll_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">triplet_margin_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">anchor</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">positive</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">negative</span><span class="p">,</span> <span class="kt">double</span> <span class="n">margin</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-06</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">swap</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">trunc</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">trunc_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">trunc_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">_has_same_tensorimpl_type</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_unique</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sorted</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_inverse</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">unique_dim</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sorted</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_inverse</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_counts</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">unique_consecutive</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_inverse</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_counts</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">dim</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">unique_dim_consecutive</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_inverse</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_counts</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_unique2</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sorted</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_inverse</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_counts</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_unsafe_view</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">unsqueeze</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">var</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">var</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">var_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">var_mean</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">var_mean</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">where</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">condition</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">where</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">condition</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_s_where</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">condition</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">norm_except_dim</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">pow</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_weight_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_weight_norm_cuda_interface</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_weight_norm_cuda_interface_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_w</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">saved_v</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">saved_g</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">saved_norms</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_weight_norm_differentiable_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_w</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">saved_v</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">saved_g</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">saved_norms</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">zeros</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">zeros_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">zeros_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">zeros_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_standard_gamma_grad</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_standard_gamma</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_dirichlet_grad</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">alpha</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">total</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_sample_dirichlet</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">poisson</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">native_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_sparse_sum</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_sparse_sum</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">ScalarType</span> <span class="n">dtype</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_sparse_sum</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_sparse_sum</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="n">ScalarType</span> <span class="n">dtype</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_sparse_sum_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="n">ScalarType</span> <span class="n">dtype</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">ScalarType</span> <span class="n">dtype</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">norm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">ScalarType</span> <span class="n">dtype</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">norm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">frobenius_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">frobenius_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">frobenius_norm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">nuclear_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">nuclear_norm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">nuclear_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">nuclear_norm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">clone</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">resize_as_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">the_template</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">pow_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">exponent</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">pow</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">exponent</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">zero_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sub_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">sub</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">sub</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">rsub</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">rsub</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">s_native_addmm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">s_native_addmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">s_native_addmm_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_sparse_addmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sparse</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">dense</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">addmm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">addmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">sparse_coo_tensor</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">sparse_coo_tensor</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">sparse_coo_tensor</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_sparse_coo_tensor_unsafe</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_sparse_coo_tensor_with_dims</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">sparse_dim</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dense_dim</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_sparse_coo_tensor_with_dims_and_tensors</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">sparse_dim</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dense_dim</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">to_dense_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hspmm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">hspmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">copy_sparse_to_sparse_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">numel</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">unbind</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">mkldnn_reorder_conv2d_weight</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">to_mkldnn_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">quantize_linear</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">scale</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">zero_point</span><span class="p">,</span> <span class="n">ScalarType</span> <span class="n">dtype</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">quantize_linear_per_channel</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">scales</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">zero_points</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">axis</span><span class="p">,</span> <span class="n">ScalarType</span> <span class="n">dtype</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">dequantize</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_dequantize_linear</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">scale</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">zero_point</span><span class="p">,</span> <span class="n">ScalarType</span> <span class="n">dtype</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">double</span> <span class="nf">q_scale</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">q_zero_point</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">int_repr</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_per_tensor_affine_qtensor</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">scale</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">zero_point</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">TensorList</span> <span class="n">tensors</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cartesian_prod</span><span class="p">(</span><span class="n">TensorList</span> <span class="n">tensors</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">combinations</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">with_replacement</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Scalar</span> <span class="nf">_local_scalar_dense</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_thnn_fused_lstm_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input_gates</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hidden_gates</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input_bias</span><span class="o">=</span><span class="p">{},</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hidden_bias</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_thnn_fused_lstm_cell_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_hy</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_cy</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cy</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">workspace</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_bias</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_thnn_fused_gru_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input_gates</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hidden_gates</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input_bias</span><span class="o">=</span><span class="p">{},</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hidden_bias</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_thnn_fused_gru_cell_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_hy</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">workspace</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_bias</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lstm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lstm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">gru</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">gru</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">rnn_tanh</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">rnn_tanh</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">rnn_relu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">rnn_relu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lstm_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_ih</span><span class="o">=</span><span class="p">{},</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_hh</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">gru_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_ih</span><span class="o">=</span><span class="p">{},</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_hh</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">rnn_tanh_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_ih</span><span class="o">=</span><span class="p">{},</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_hh</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">rnn_relu_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_ih</span><span class="o">=</span><span class="p">{},</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_hh</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">quantized_lstm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">quantized_lstm_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets_hh</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale_ih</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale_hh</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">zero_point_ih</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">zero_point_hh</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">quantized_gru_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets_hh</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale_ih</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale_hh</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">zero_point_ih</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">zero_point_hh</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">quantized_rnn_relu_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets_hh</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale_ih</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale_hh</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">zero_point_ih</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">zero_point_hh</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">quantized_rnn_tanh_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets_hh</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale_ih</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale_hh</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">zero_point_ih</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">zero_point_hh</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_pack_padded_sequence</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">lengths</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_pack_padded_sequence_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_pad_packed_sequence</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">padding_value</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">total_length</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">masked_fill</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">masked_fill</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">masked_scatter</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">index_add</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">index_fill</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">index_fill</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">scatter</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">src</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">scatter</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">scatter_add</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">src</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">__and__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">__and__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">__or__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">__or__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">__xor__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">__xor__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">__lshift__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">__lshift__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">__rshift__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">__rshift__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">addbmm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">addbmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">diag_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">diagonal</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">diag</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">diagonal</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cross_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">dim</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cross</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">dim</span><span class="o">=</span><span class="n">c10</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">triu_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">diagonal</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">triu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">diagonal</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tril_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">diagonal</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">tril</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">diagonal</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">tril_indices</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">col</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="n">at</span><span class="o">::</span><span class="n">kLong</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">triu_indices</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">col</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="n">at</span><span class="o">::</span><span class="n">kLong</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">trace</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ne_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">ne</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ne_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">ne</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">eq_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">eq</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">eq_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">eq</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ge_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">ge</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ge_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">ge</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">le_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">le</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">le_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">le</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">gt_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">gt</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">gt_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">gt</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">lt_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">lt</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">lt_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">lt</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">take_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">take</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index_select_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">index_select</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">masked_select_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">masked_select</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">nonzero_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">nonzero</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">nonzero_numpy</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">gather_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sparse_grad</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">gather</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sparse_grad</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_gather_sparse_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">addcmul_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">addcmul</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">addcdiv_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">addcdiv</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">gels_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">X</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">qr</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">gels</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">triangular_solve_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">X</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">M</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transpose</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unitriangular</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">triangular_solve</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transpose</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unitriangular</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_triangular_solve_helper</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transpose</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unitriangular</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">symeig_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">e</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">eigenvectors</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">symeig</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">eigenvectors</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_symeig_helper</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">eigenvectors</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">eig_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">e</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">eigenvectors</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">eig</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">eigenvectors</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">svd_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">U</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">S</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">some</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">compute_uv</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">svd</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">some</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">compute_uv</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cholesky_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cholesky</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_cholesky_helper</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cholesky_solve_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cholesky_solve</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_cholesky_solve_helper</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">solve</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">solve_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">solution</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">lu</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_solve_helper</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cholesky_inverse_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">cholesky_inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">pstrf_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">u</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">pivot</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">tol</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">pstrf</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">tol</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">qr_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">Q</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">R</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">some</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">qr</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">some</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_qr_helper</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">some</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">geqrf_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tau</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">geqrf</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">orgqr_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">orgqr</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ormqr_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input3</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">left</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transpose</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">ormqr</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input3</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">left</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transpose</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_lu_with_info</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">pivot</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">check_errors</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">lu_solve_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">LU_data</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">LU_pivots</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">lu_solve</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">LU_data</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">LU_pivots</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">multinomial_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_samples</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">replacement</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">multinomial</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_samples</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">replacement</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_multinomial_alias_setup</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">probs</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_multinomial_alias_draw</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">J</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">q</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">lgamma_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">lgamma</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">digamma_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">digamma</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">polygamma_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">polygamma</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">erfinv_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">erfinv</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">dist</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">atan2_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">atan2</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">lerp_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">end</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">weight</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">lerp_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">end</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">lerp</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">end</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">weight</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">lerp</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">end</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">histc_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">histc</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sign_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">sign</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fmod_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">fmod</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fmod_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">fmod</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">remainder_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">remainder</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">remainder_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">remainder</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">min_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">min</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">min</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">max</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">max</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">median</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">sort_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">descending</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">sort</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">descending</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">argsort</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">descending</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">topk_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">largest</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sorted</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">topk</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">largest</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sorted</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">all</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">any</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">renorm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">maxnorm</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">renorm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">maxnorm</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">equal</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">pow_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">exponent</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">pow</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">exponent</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">pow_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">exponent</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">pow</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">exponent</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">normal_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="kt">double</span> <span class="n">std</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">normal</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="kt">double</span> <span class="n">std</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">normal_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">double</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">std</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">normal</span><span class="p">(</span><span class="kt">double</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">std</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">normal_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">std</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">normal</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">std</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">normal</span><span class="p">(</span><span class="kt">double</span> <span class="n">mean</span><span class="p">,</span> <span class="kt">double</span> <span class="n">std</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="o">=</span><span class="p">{});</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">normal_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">double</span> <span class="n">mean</span><span class="p">,</span> <span class="kt">double</span> <span class="n">std</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">alias</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_addr</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_addr_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_addr_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_index_copy_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_cumsum</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_cumsum_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_cumprod</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_cumprod_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_var</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_std</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_addmm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_addmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_addmm_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_cat</span><span class="p">(</span><span class="n">TensorList</span> <span class="n">tensors</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_cat_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">tensors</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_mode</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">_mode_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_max</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">_max_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_min</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">_min_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">min_indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">binary_cross_entropy_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="o">=</span><span class="p">{},</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">binary_cross_entropy</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="o">=</span><span class="p">{},</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">binary_cross_entropy_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="o">=</span><span class="p">{},</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">binary_cross_entropy_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="o">=</span><span class="p">{},</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mse_loss_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">mse_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mse_loss_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">mse_loss_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">l1_loss_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">l1_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">l1_loss_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">l1_loss_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">multi_margin_loss_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">margin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="o">=</span><span class="p">{},</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">multi_margin_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">margin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="o">=</span><span class="p">{},</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">multi_margin_loss_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">margin</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="o">=</span><span class="p">{},</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">multi_margin_loss_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">margin</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="o">=</span><span class="p">{},</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">multilabel_margin_loss_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">multilabel_margin_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">multilabel_margin_loss_forward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">is_target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">multilabel_margin_loss_forward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">multilabel_margin_loss_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">is_target</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">multilabel_margin_loss_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">is_target</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">nll_loss_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="o">=</span><span class="p">{},</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="o">=-</span><span class="mi">100</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">nll_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="o">=</span><span class="p">{},</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="o">=-</span><span class="mi">100</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">nll_loss_forward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">total_weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">nll_loss_forward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">nll_loss_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">total_weight</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">nll_loss_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">total_weight</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">nll_loss2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="o">=</span><span class="p">{},</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="o">=-</span><span class="mi">100</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">nll_loss2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="o">=</span><span class="p">{},</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="o">=-</span><span class="mi">100</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">nll_loss2d_forward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">total_weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">nll_loss2d_forward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">nll_loss2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">total_weight</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">nll_loss2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">total_weight</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">smooth_l1_loss_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">smooth_l1_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">smooth_l1_loss_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">smooth_l1_loss_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">soft_margin_loss_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">soft_margin_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="o">=</span><span class="n">Reduction</span><span class="o">::</span><span class="n">Mean</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">soft_margin_loss_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">soft_margin_loss_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">elu_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">input_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">elu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">input_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">elu_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">input_scale</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">elu_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">input_scale</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">elu_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">input_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">glu_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">glu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">glu_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">glu_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hardtanh_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min_val</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max_val</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">hardtanh</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min_val</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max_val</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hardtanh_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max_val</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">hardtanh_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max_val</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hardtanh_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min_val</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max_val</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">leaky_relu_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">negative_slope</span><span class="o">=</span><span class="mf">0.01</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">leaky_relu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">negative_slope</span><span class="o">=</span><span class="mf">0.01</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">leaky_relu_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">negative_slope</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">leaky_relu_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">negative_slope</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">leaky_relu_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">negative_slope</span><span class="o">=</span><span class="mf">0.01</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_sigmoid_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">log_sigmoid</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">log_sigmoid_forward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">log_sigmoid_forward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_sigmoid_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">buffer</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">log_sigmoid_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">buffer</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rrelu_with_noise_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">noise</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lower</span><span class="o">=</span><span class="mf">0.125</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">upper</span><span class="o">=</span><span class="mf">0.3333333333333333</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">rrelu_with_noise</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">noise</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lower</span><span class="o">=</span><span class="mf">0.125</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">upper</span><span class="o">=</span><span class="mf">0.3333333333333333</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rrelu_with_noise_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">noise</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lower</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">upper</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">rrelu_with_noise_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">noise</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lower</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">upper</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rrelu_with_noise_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">noise</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lower</span><span class="o">=</span><span class="mf">0.125</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">upper</span><span class="o">=</span><span class="mf">0.3333333333333333</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">softplus_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">20</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">softplus</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">20</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">softplus_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">threshold</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">softplus_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">threshold</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">softshrink_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lambd</span><span class="o">=</span><span class="mf">0.5</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">softshrink</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lambd</span><span class="o">=</span><span class="mf">0.5</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">softshrink_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lambd</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">softshrink_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lambd</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">adaptive_avg_pool2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">adaptive_avg_pool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">mkldnn_adaptive_avg_pool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_adaptive_avg_pool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">_adaptive_avg_pool2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">adaptive_avg_pool3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">adaptive_avg_pool3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">adaptive_avg_pool3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">adaptive_avg_pool3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">adaptive_max_pool2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">adaptive_max_pool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">adaptive_max_pool2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">adaptive_max_pool2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">adaptive_max_pool3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">adaptive_max_pool3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">adaptive_max_pool3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">adaptive_max_pool3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">avg_pool2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">avg_pool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">avg_pool2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">avg_pool2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">avg_pool3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">avg_pool3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">avg_pool3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">avg_pool3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">fractional_max_pool2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">random_samples</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">fractional_max_pool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">random_samples</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fractional_max_pool2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">fractional_max_pool2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">fractional_max_pool3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">random_samples</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">fractional_max_pool3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">random_samples</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fractional_max_pool3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">fractional_max_pool3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">max_pool2d_with_indices_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">max_pool2d_with_indices</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_pool2d_with_indices_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">max_pool2d_with_indices_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">max_pool3d_with_indices_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">max_pool3d_with_indices</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_pool3d_with_indices_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">max_pool3d_with_indices_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_unpool2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">max_unpool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_unpool2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">max_unpool2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_unpool3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">max_unpool3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_unpool3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">max_unpool3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">reflection_pad1d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">reflection_pad1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">reflection_pad1d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">reflection_pad1d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">reflection_pad2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">reflection_pad2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">reflection_pad2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">reflection_pad2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">replication_pad1d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">replication_pad1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">replication_pad1d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">replication_pad1d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">replication_pad2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">replication_pad2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">replication_pad2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">replication_pad2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">replication_pad3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">replication_pad3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">replication_pad3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">replication_pad3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_linear1d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">upsample_linear1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_linear1d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">upsample_linear1d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_bilinear2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">upsample_bilinear2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_bilinear2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">upsample_bilinear2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_bicubic2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">upsample_bicubic2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_bicubic2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">upsample_bicubic2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_trilinear3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">upsample_trilinear3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_trilinear3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">upsample_trilinear3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_nearest1d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">upsample_nearest1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_nearest1d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">upsample_nearest1d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_nearest2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">upsample_nearest2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_nearest2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">upsample_nearest2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_nearest3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">upsample_nearest3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_nearest3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">upsample_nearest3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sigmoid_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">sigmoid_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tanh_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">tanh_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">conv_transpose2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">conv_transpose2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">conv_transpose2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_weight</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">columns</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ones</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">conv_transpose2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">columns</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ones</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">conv_transpose3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">conv_transpose3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">conv_transpose3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_weight</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">finput</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fgrad_input</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">conv_transpose3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">finput</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fgrad_input</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">thnn_conv2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">thnn_conv2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">thnn_conv2d_forward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">finput</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fgrad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">thnn_conv2d_forward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">thnn_conv2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_weight</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">finput</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fgrad_input</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">thnn_conv2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">finput</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fgrad_input</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">thnn_conv_depthwise2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">thnn_conv_depthwise2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">thnn_conv_depthwise2d_forward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">thnn_conv_depthwise2d_forward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">thnn_conv_depthwise2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">thnn_conv_depthwise2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">thnn_conv3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">thnn_conv3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">thnn_conv3d_forward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">finput</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fgrad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">thnn_conv3d_forward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">thnn_conv3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_weight</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">finput</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fgrad_input</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">thnn_conv3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">finput</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fgrad_input</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">conv_dilated2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">conv_dilated2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">conv_dilated3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="o">=</span><span class="p">{},</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">conv_dilated3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col2im_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">col2im</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col2im_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">col2im_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">im2col_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">im2col</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">im2col_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">im2col_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">);</span>

<span class="kr">inline</span> <span class="n">Tensor</span> <span class="nf">from_blob</span><span class="p">(</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span>
    <span class="n">IntArrayRef</span> <span class="n">sizes</span><span class="p">,</span>
    <span class="n">IntArrayRef</span> <span class="n">strides</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;&amp;</span> <span class="n">deleter</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">TensorOptions</span><span class="o">&amp;</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">device</span> <span class="o">=</span> <span class="n">globalContext</span><span class="p">().</span><span class="n">getDeviceFromPtr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">options</span><span class="p">.</span><span class="n">device</span><span class="p">().</span><span class="n">type</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">device</span><span class="p">().</span><span class="n">has_index</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">TORCH_CHECK</span><span class="p">(</span>
        <span class="n">options</span><span class="p">.</span><span class="n">device</span><span class="p">()</span> <span class="o">==</span> <span class="n">device</span><span class="p">,</span>
        <span class="s">&quot;Specified device &quot;</span><span class="p">,</span> <span class="n">options</span><span class="p">.</span><span class="n">device</span><span class="p">(),</span>
        <span class="s">&quot; does not match device of data &quot;</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">auto</span> <span class="n">storage</span> <span class="o">=</span> <span class="n">Storage</span><span class="p">(</span>
      <span class="n">options</span><span class="p">.</span><span class="n">dtype</span><span class="p">(),</span>
      <span class="n">detail</span><span class="o">::</span><span class="n">computeStorageSize</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">strides</span><span class="p">),</span>
      <span class="n">InefficientStdFunctionContext</span><span class="o">::</span><span class="n">makeDataPtr</span><span class="p">(</span>
          <span class="n">data</span><span class="p">,</span> <span class="n">deleter</span><span class="p">,</span> <span class="n">device</span><span class="p">),</span>
      <span class="cm">/*allocator=*/</span><span class="k">nullptr</span><span class="p">,</span>
      <span class="cm">/*resizable=*/</span><span class="nb">false</span><span class="p">);</span>
  <span class="k">return</span> <span class="nf">empty</span><span class="p">({</span><span class="mi">0</span><span class="p">},</span> <span class="n">options</span><span class="p">).</span><span class="n">set_</span><span class="p">(</span><span class="n">storage</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">strides</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">from_blob</span><span class="p">(</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span>
    <span class="n">IntArrayRef</span> <span class="n">sizes</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;&amp;</span> <span class="n">deleter</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">TensorOptions</span><span class="o">&amp;</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">from_blob</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">detail</span><span class="o">::</span><span class="n">defaultStrides</span><span class="p">(</span><span class="n">sizes</span><span class="p">),</span> <span class="n">deleter</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">from_blob</span><span class="p">(</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span>
    <span class="n">IntArrayRef</span> <span class="n">sizes</span><span class="p">,</span>
    <span class="n">IntArrayRef</span> <span class="n">strides</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">TensorOptions</span><span class="o">&amp;</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">from_blob</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="p">[](</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="p">{},</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">from_blob</span><span class="p">(</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span>
    <span class="n">IntArrayRef</span> <span class="n">sizes</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">TensorOptions</span><span class="o">&amp;</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">from_blob</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">detail</span><span class="o">::</span><span class="n">defaultStrides</span><span class="p">(</span><span class="n">sizes</span><span class="p">),</span> <span class="p">[](</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="p">{},</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">detail</span> <span class="p">{</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">Backend</span> <span class="n">infer_backend</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">TORCH_CHECK</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">defined</span><span class="p">(),</span> <span class="s">&quot;undefined Tensor&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="nf">tensorTypeIdToBackend</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">type_id</span><span class="p">());</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Backend</span> <span class="n">infer_backend</span><span class="p">(</span><span class="k">const</span> <span class="n">TensorList</span> <span class="o">&amp;</span> <span class="n">tl</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">TORCH_CHECK</span><span class="p">(</span><span class="n">tl</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;expected a non-empty list of Tensors&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="nf">tensorTypeIdToBackend</span><span class="p">(</span><span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type_id</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">infer_is_variable</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">TORCH_CHECK</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">defined</span><span class="p">(),</span> <span class="s">&quot;undefined Tensor&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">t</span><span class="p">.</span><span class="n">is_variable</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">infer_is_variable</span><span class="p">(</span><span class="k">const</span> <span class="n">TensorList</span> <span class="o">&amp;</span> <span class="n">tl</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">TORCH_CHECK</span><span class="p">(</span><span class="n">tl</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;expected a non-empty list of Tensors&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">is_variable</span><span class="p">();</span>
<span class="p">}</span>


<span class="p">}</span> <span class="c1">// namespace detail</span>

<span class="c1">// function definitions are all static inline because</span>
<span class="c1">// they are one-line statically dispatched functions that</span>
<span class="c1">// invoke the actual dynamic dispatch on the correct argument</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_cast_Byte</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cast_Byte(Tensor self, bool non_blocking=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">non_blocking</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_cast_Char</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cast_Char(Tensor self, bool non_blocking=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">non_blocking</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_cast_Double</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cast_Double(Tensor self, bool non_blocking=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">non_blocking</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_cast_Float</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cast_Float(Tensor self, bool non_blocking=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">non_blocking</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_cast_Int</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cast_Int(Tensor self, bool non_blocking=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">non_blocking</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_cast_Long</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cast_Long(Tensor self, bool non_blocking=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">non_blocking</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_cast_Short</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cast_Short(Tensor self, bool non_blocking=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">non_blocking</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_cast_Half</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cast_Half(Tensor self, bool non_blocking=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">non_blocking</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_cudnn_ctc_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_probs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">targets</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_lengths</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">target_lengths</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">blank</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">zero_infinity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cudnn_ctc_loss(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank, bool deterministic, bool zero_infinity) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">log_probs</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">log_probs</span><span class="p">))(</span><span class="n">log_probs</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">input_lengths</span><span class="p">,</span> <span class="n">target_lengths</span><span class="p">,</span> <span class="n">blank</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">zero_infinity</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_cudnn_rnn_flatten_weight</span><span class="p">(</span><span class="n">TensorList</span> <span class="n">weight_arr</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">weight_stride0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">hidden_size</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cudnn_rnn_flatten_weight(Tensor[] weight_arr, int weight_stride0, int input_size, int mode, int hidden_size, int num_layers, bool batch_first, bool bidirectional) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">TensorList</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">weight_arr</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">weight_arr</span><span class="p">))(</span><span class="n">weight_arr</span><span class="p">,</span> <span class="n">weight_stride0</span><span class="p">,</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="n">batch_first</span><span class="p">,</span> <span class="n">bidirectional</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_cudnn_rnn</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">weight_stride0</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight_buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cx</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">hidden_size</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">dropout_state</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cudnn_rnn(Tensor input, Tensor[] weight, int weight_stride0, Tensor? weight_buf, Tensor hx, Tensor? cx, int mode, int hidden_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, int[] batch_sizes, Tensor? dropout_state) -&gt; (Tensor, Tensor, Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">weight_stride0</span><span class="p">,</span> <span class="n">weight_buf</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="n">batch_first</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="n">dropout_state</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;&gt;</span> <span class="n">_cudnn_rnn_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">weight_stride0</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight_buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_hy</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_cy</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">hidden_size</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">dropout_state</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cudnn_rnn_backward(Tensor input, Tensor[] weight, int weight_stride0, Tensor weight_buf, Tensor hx, Tensor? cx, Tensor output, Tensor? grad_output, Tensor? grad_hy, Tensor? grad_cy, int mode, int hidden_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, int[] batch_sizes, Tensor? dropout_state, Tensor reserve, bool[4] output_mask) -&gt; (Tensor, Tensor, Tensor, Tensor[])&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">weight_stride0</span><span class="p">,</span> <span class="n">weight_buf</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">grad_hy</span><span class="p">,</span> <span class="n">grad_cy</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="n">batch_first</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="n">dropout_state</span><span class="p">,</span> <span class="n">reserve</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_cudnn_init_dropout_state</span><span class="p">(</span><span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dropout_seed</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cudnn_init_dropout_state(float dropout, bool train, int dropout_seed, *, ScalarType dtype, Layout layout, Device device, bool pin_memory=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">dropout</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">dropout_seed</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="n">_debug_has_internal_overlap</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_debug_has_internal_overlap(Tensor self) -&gt; int&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">int64_t</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_fused_dropout</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_fused_dropout(Tensor self, float p, Generator? generator=None) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_masked_scale</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">double</span> <span class="n">scale</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_masked_scale(Tensor self, Tensor mask, float scale) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">scale</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_sobol_engine_draw</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">quasi</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sobolstate</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dimension</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_generated</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sobol_engine_draw(Tensor quasi, int n, Tensor sobolstate, int dimension, int num_generated, ScalarType? dtype) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">quasi</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">quasi</span><span class="p">))(</span><span class="n">quasi</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">sobolstate</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">num_generated</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sobol_engine_ff_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sobolstate</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dimension</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_generated</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sobol_engine_ff_(Tensor(a!) self, int n, Tensor sobolstate, int dimension, int num_generated) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">sobolstate</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">num_generated</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sobol_engine_scramble_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ltm</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dimension</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sobol_engine_scramble_(Tensor(a!) self, Tensor ltm, int dimension) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">ltm</span><span class="p">,</span> <span class="n">dimension</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sobol_engine_initialize_state_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dimension</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sobol_engine_initialize_state_(Tensor(a!) self, int dimension) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_reshape_from_tensor</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">shape</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_reshape_from_tensor(Tensor self, Tensor shape) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_shape_as_tensor</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_shape_as_tensor(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">dropout</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::dropout(Tensor input, float p, bool train) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">train</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">dropout_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::dropout_(Tensor(a!) self, float p, bool train) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">train</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">feature_dropout</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::feature_dropout(Tensor input, float p, bool train) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">train</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">feature_dropout_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::feature_dropout_(Tensor(a!) self, float p, bool train) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">train</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">alpha_dropout</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::alpha_dropout(Tensor input, float p, bool train) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">train</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">alpha_dropout_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::alpha_dropout_(Tensor(a!) self, float p, bool train) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">train</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">feature_alpha_dropout</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::feature_alpha_dropout(Tensor input, float p, bool train) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">train</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">feature_alpha_dropout_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::feature_alpha_dropout_(Tensor(a!) self, float p, bool train) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">train</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">abs</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::abs(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">abs_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::abs_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">abs_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::abs(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">acos</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::acos(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">acos_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::acos_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">acos_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::acos(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">avg_pool1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::avg_pool1d(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, bool ceil_mode=False, bool count_include_pad=True) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="n">count_include_pad</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">adaptive_avg_pool1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::adaptive_avg_pool1d(Tensor self, int[1] output_size) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">adaptive_max_pool1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::adaptive_max_pool1d(Tensor self, int[1] output_size) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">add</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::add(Tensor self, Tensor other, *, Scalar alpha=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">add_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::add(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">add</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::add(Tensor self, Scalar other, Scalar alpha=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">addmv</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::addmv(Tensor self, Tensor mat, Tensor vec, *, Scalar beta=1, Scalar alpha=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">addmv_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::addmv_(Tensor(a!) self, Tensor mat, Tensor vec, *, Scalar beta=1, Scalar alpha=1) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">addmv_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::addmv(Tensor self, Tensor mat, Tensor vec, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">addr</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::addr(Tensor self, Tensor vec1, Tensor vec2, *, Scalar beta=1, Scalar alpha=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">addr_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::addr(Tensor self, Tensor vec1, Tensor vec2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">affine_grid_generator</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">theta</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::affine_grid_generator(Tensor theta, int[] size) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">theta</span><span class="p">))(</span><span class="n">theta</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">affine_grid_generator_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::affine_grid_generator_backward(Tensor grad, int[] size) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad</span><span class="p">))(</span><span class="n">grad</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">all</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::all(Tensor self, int dim, bool keepdim=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">all_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::all(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">allclose</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="kt">double</span> <span class="n">rtol</span><span class="p">,</span> <span class="kt">double</span> <span class="n">atol</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">equal_nan</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::allclose(Tensor self, Tensor other, float rtol=1e-05, float atol=1e-08, bool equal_nan=False) -&gt; bool&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">,</span> <span class="n">equal_nan</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">any</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::any(Tensor self, int dim, bool keepdim=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">any_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::any(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">arange</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::arange(Scalar end, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">end</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">arange</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::arange(Scalar start, Scalar end, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">arange</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">step</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::arange(Scalar start, Scalar end, Scalar step, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">arange_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::arange(Scalar end, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">arange_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">step</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::arange(Scalar start, Scalar end, Scalar step=1, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_dim_arange</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">like</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_dim_arange(Tensor like, int dim) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">like</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">like</span><span class="p">))(</span><span class="n">like</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">argmax</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::argmax(Tensor self, int? dim=None, bool keepdim=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">argmin</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::argmin(Tensor self, int? dim=None, bool keepdim=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">as_strided</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">storage_offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::as_strided(Tensor(a) self, int[] size, int[] stride, int? storage_offset=None) -&gt; Tensor(a)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">storage_offset</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">as_strided_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">storage_offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::as_strided_(Tensor(a!) self, int[] size, int[] stride, int? storage_offset=None) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">storage_offset</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">asin</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::asin(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">asin_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::asin_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">asin_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::asin(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">atan</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::atan(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">atan_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::atan_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">atan_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::atan(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">baddbmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::baddbmm(Tensor self, Tensor batch1, Tensor batch2, *, Scalar beta=1, Scalar alpha=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">batch1</span><span class="p">,</span> <span class="n">batch2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_baddbmm_mkl_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_baddbmm_mkl_(Tensor(a!) self, Tensor batch1, Tensor batch2, *, Scalar beta=1, Scalar alpha=1) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">batch1</span><span class="p">,</span> <span class="n">batch2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">baddbmm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::baddbmm(Tensor self, Tensor batch1, Tensor batch2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">batch1</span><span class="p">,</span> <span class="n">batch2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">bartlett_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::bartlett_window(int window_length, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">window_length</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">bartlett_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">periodic</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::bartlett_window(int window_length, bool periodic, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">window_length</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">batch_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">,</span> <span class="kt">double</span> <span class="n">momentum</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cudnn_enabled</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::batch_norm(Tensor input, Tensor? weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float momentum, float eps, bool cudnn_enabled) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">running_mean</span><span class="p">,</span> <span class="n">running_var</span><span class="p">,</span> <span class="n">training</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">cudnn_enabled</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">_batch_norm_impl_index</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">,</span> <span class="kt">double</span> <span class="n">momentum</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cudnn_enabled</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_batch_norm_impl_index(Tensor input, Tensor? weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float momentum, float eps, bool cudnn_enabled) -&gt; (Tensor, Tensor, Tensor, int)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">running_mean</span><span class="p">,</span> <span class="n">running_var</span><span class="p">,</span> <span class="n">training</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">cudnn_enabled</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_batch_norm_impl_index_backward</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">impl_index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">save_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">save_var_transform</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_batch_norm_impl_index_backward(int impl_index, Tensor input, Tensor grad_output, Tensor? weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var_transform, bool train, float eps, bool[3] output_mask) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">impl_index</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">running_mean</span><span class="p">,</span> <span class="n">running_var</span><span class="p">,</span> <span class="n">save_mean</span><span class="p">,</span> <span class="n">save_var_transform</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">bernoulli</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::bernoulli(Tensor self, *, Generator? generator=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bernoulli_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::bernoulli(Tensor self, *, Generator? generator=None, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">bernoulli</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::bernoulli(Tensor self, float p, *, Generator? generator=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">bilinear</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::bilinear(Tensor input1, Tensor input2, Tensor weight, Tensor? bias) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input1</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input1</span><span class="p">))(</span><span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">binary_cross_entropy_with_logits</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">pos_weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::binary_cross_entropy_with_logits(Tensor self, Tensor target, Tensor? weight=None, Tensor? pos_weight=None, int reduction=Mean) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">pos_weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">binary_cross_entropy_with_logits_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">pos_weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::binary_cross_entropy_with_logits_backward(Tensor grad_output, Tensor self, Tensor target, Tensor? weight=None, Tensor? pos_weight=None, int reduction=Mean) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">pos_weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">bincount</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weights</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">minlength</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::bincount(Tensor self, Tensor? weights=None, int minlength=0) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">minlength</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">bitwise_not</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::bitwise_not(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bitwise_not_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::bitwise_not(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">blackman_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::blackman_window(int window_length, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">window_length</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">blackman_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">periodic</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::blackman_window(int window_length, bool periodic, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">window_length</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">bmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::bmm(Tensor self, Tensor mat2) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">mat2</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bmm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::bmm(Tensor self, Tensor mat2, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">mat2</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">broadcast_tensors</span><span class="p">(</span><span class="n">TensorList</span> <span class="n">tensors</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::broadcast_tensors(Tensor[] tensors) -&gt; Tensor[]&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">TensorList</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">tensors</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">tensors</span><span class="p">))(</span><span class="n">tensors</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cat</span><span class="p">(</span><span class="n">TensorList</span> <span class="n">tensors</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cat(Tensor[] tensors, int dim=0) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">TensorList</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">tensors</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">tensors</span><span class="p">))(</span><span class="n">tensors</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cat_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">tensors</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cat(Tensor[] tensors, int dim=0, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">tensors</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">ceil</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ceil(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ceil_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ceil_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ceil_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ceil(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">chain_matmul</span><span class="p">(</span><span class="n">TensorList</span> <span class="n">matrices</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::chain_matmul(Tensor[] matrices) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">TensorList</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">matrices</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">matrices</span><span class="p">))(</span><span class="n">matrices</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">chunk</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">chunks</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::chunk(Tensor(a) self, int chunks, int dim=0) -&gt; Tensor(a)[]&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">clamp</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">min</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::clamp(Tensor self, Scalar? min=None, Scalar? max=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">clamp_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">min</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::clamp_(Tensor(a!) self, Scalar? min=None, Scalar? max=None) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">clamp_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">min</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::clamp(Tensor self, Scalar? min=None, Scalar? max=None, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">clamp_max</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::clamp_max(Tensor self, Scalar max) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">clamp_max_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::clamp_max_(Tensor(a!) self, Scalar max) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">clamp_max_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::clamp_max(Tensor self, Scalar max, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">clamp_min</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::clamp_min(Tensor self, Scalar min) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">min</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">clamp_min_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::clamp_min_(Tensor(a!) self, Scalar min) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">min</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">clamp_min_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::clamp_min(Tensor self, Scalar min, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">min</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">cudnn_is_acceptable</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cudnn_is_acceptable(Tensor self) -&gt; bool&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">constant_pad_nd</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">pad</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::constant_pad_nd(Tensor self, int[] pad, Scalar value=0) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">convolution</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transposed</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::convolution(Tensor input, Tensor weight, Tensor? bias, int[] stride, int[] padding, int[] dilation, bool transposed, int[] output_padding, int groups) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">transposed</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">groups</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_convolution</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transposed</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cudnn_enabled</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_convolution(Tensor input, Tensor weight, Tensor? bias, int[] stride, int[] padding, int[] dilation, bool transposed, int[] output_padding, int groups, bool benchmark, bool deterministic, bool cudnn_enabled) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">transposed</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">cudnn_enabled</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_convolution_nogroup</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transposed</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_convolution_nogroup(Tensor input, Tensor weight, Tensor? bias, int[] stride, int[] padding, int[] dilation, bool transposed, int[] output_padding) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">transposed</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_convolution_double_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ggI</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ggW</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ggb</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">gO</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transposed</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cudnn_enabled</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_convolution_double_backward(Tensor? ggI, Tensor? ggW, Tensor? ggb, Tensor gO, Tensor weight, Tensor self, int[] stride, int[] padding, int[] dilation, bool transposed, int[] output_padding, int groups, bool benchmark, bool deterministic, bool cudnn_enabled, bool[3] output_mask) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">ggI</span><span class="p">,</span> <span class="n">ggW</span><span class="p">,</span> <span class="n">ggb</span><span class="p">,</span> <span class="n">gO</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">transposed</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">cudnn_enabled</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">conv1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv1d(Tensor input, Tensor weight, Tensor? bias=None, int[1] stride=1, int[1] padding=0, int[1] dilation=1, int groups=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">conv2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv2d(Tensor input, Tensor weight, Tensor? bias=None, int[2] stride=1, int[2] padding=0, int[2] dilation=1, int groups=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">conv3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv3d(Tensor input, Tensor weight, Tensor? bias=None, int[3] stride=1, int[3] padding=0, int[3] dilation=1, int groups=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">conv_tbc</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">pad</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv_tbc(Tensor self, Tensor weight, Tensor bias, int pad=0) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">conv_tbc_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">pad</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv_tbc_backward(Tensor self, Tensor input, Tensor weight, Tensor bias, int pad) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">conv_transpose1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv_transpose1d(Tensor input, Tensor weight, Tensor? bias=None, int[1] stride=1, int[1] padding=0, int[1] output_padding=0, int groups=1, int[1] dilation=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">dilation</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">conv_transpose2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv_transpose2d(Tensor input, Tensor weight, Tensor? bias=None, int[2] stride=1, int[2] padding=0, int[2] output_padding=0, int groups=1, int[2] dilation=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">dilation</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">conv_transpose3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv_transpose3d(Tensor input, Tensor weight, Tensor? bias=None, int[3] stride=1, int[3] padding=0, int[3] output_padding=0, int groups=1, int[3] dilation=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">dilation</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_copy_from</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_copy_from(Tensor self, Tensor dst, bool non_blocking=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">non_blocking</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cos</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cos(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cos_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cos_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cos_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cos(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cosh</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cosh(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cosh_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cosh_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cosh_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cosh(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cosine_embedding_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">margin</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cosine_embedding_loss(Tensor input1, Tensor input2, Tensor target, float margin=0.0, int reduction=Mean) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input1</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input1</span><span class="p">))(</span><span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">margin</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cudnn_affine_grid_generator</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">theta</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">C</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">H</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">W</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cudnn_affine_grid_generator(Tensor theta, int N, int C, int H, int W) -&gt; Tensor grid&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">theta</span><span class="p">))(</span><span class="n">theta</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cudnn_affine_grid_generator_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">C</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">H</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">W</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cudnn_affine_grid_generator_backward(Tensor grad, int N, int C, int H, int W) -&gt; Tensor grad_theta&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad</span><span class="p">))(</span><span class="n">grad</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">cudnn_batch_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">,</span> <span class="kt">double</span> <span class="n">exponential_average_factor</span><span class="p">,</span> <span class="kt">double</span> <span class="n">epsilon</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cudnn_batch_norm(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">running_mean</span><span class="p">,</span> <span class="n">running_var</span><span class="p">,</span> <span class="n">training</span><span class="p">,</span> <span class="n">exponential_average_factor</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">cudnn_batch_norm_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">save_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">save_var</span><span class="p">,</span> <span class="kt">double</span> <span class="n">epsilon</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cudnn_batch_norm_backward(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">running_mean</span><span class="p">,</span> <span class="n">running_var</span><span class="p">,</span> <span class="n">save_mean</span><span class="p">,</span> <span class="n">save_var</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cudnn_convolution</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cudnn_convolution(Tensor self, Tensor weight, Tensor? bias, int[] padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cudnn_convolution_backward_input</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">self_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cudnn_convolution_backward_input(int[] self_size, Tensor grad_output, Tensor weight, int[] padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">self_size</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">cudnn_convolution_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cudnn_convolution_backward(Tensor self, Tensor grad_output, Tensor weight, int[] padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic, bool[3] output_mask) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cudnn_convolution_backward_bias</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cudnn_convolution_backward_bias(Tensor grad_output) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cudnn_convolution_backward_weight</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">weight_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cudnn_convolution_backward_weight(int[] weight_size, Tensor grad_output, Tensor self, int[] padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">weight_size</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cudnn_convolution_transpose</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cudnn_convolution_transpose(Tensor self, Tensor weight, Tensor? bias, int[] padding, int[] output_padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">cudnn_convolution_transpose_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cudnn_convolution_transpose_backward(Tensor self, Tensor grad_output, Tensor weight, int[] padding, int[] output_padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic, bool[3] output_mask) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cudnn_convolution_transpose_backward_bias</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cudnn_convolution_transpose_backward_bias(Tensor grad_output) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cudnn_convolution_transpose_backward_input</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cudnn_convolution_transpose_backward_input(Tensor grad_output, Tensor weight, int[] padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cudnn_convolution_transpose_backward_weight</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">weight_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cudnn_convolution_transpose_backward_weight(int[] weight_size, Tensor grad_output, Tensor self, int[] padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">weight_size</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cudnn_grid_sampler</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cudnn_grid_sampler(Tensor self, Tensor grid) -&gt; Tensor output&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">cudnn_grid_sampler_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cudnn_grid_sampler_backward(Tensor self, Tensor grid, Tensor grad_output) -&gt; (Tensor grad_self, Tensor grad_grid)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cumsum</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cumsum(Tensor self, int dim, *, ScalarType? dtype=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cumsum_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cumsum(Tensor self, int dim, *, ScalarType? dtype=None, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cumprod</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cumprod(Tensor self, int dim, *, ScalarType? dtype=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cumprod_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cumprod(Tensor self, int dim, *, ScalarType? dtype=None, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">ctc_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_probs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">targets</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_lengths</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">target_lengths</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">blank</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">zero_infinity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ctc_loss(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank=0, int reduction=Mean, bool zero_infinity=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">log_probs</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">log_probs</span><span class="p">))(</span><span class="n">log_probs</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">input_lengths</span><span class="p">,</span> <span class="n">target_lengths</span><span class="p">,</span> <span class="n">blank</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">zero_infinity</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">ctc_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_probs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">targets</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input_lengths</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target_lengths</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">blank</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">zero_infinity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ctc_loss(Tensor log_probs, Tensor targets, Tensor input_lengths, Tensor target_lengths, int blank=0, int reduction=Mean, bool zero_infinity=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">log_probs</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">log_probs</span><span class="p">))(</span><span class="n">log_probs</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">input_lengths</span><span class="p">,</span> <span class="n">target_lengths</span><span class="p">,</span> <span class="n">blank</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">zero_infinity</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_ctc_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_probs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">targets</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_lengths</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">target_lengths</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">blank</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">zero_infinity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_ctc_loss(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank=0, bool zero_infinity=False) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">log_probs</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">log_probs</span><span class="p">))(</span><span class="n">log_probs</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">input_lengths</span><span class="p">,</span> <span class="n">target_lengths</span><span class="p">,</span> <span class="n">blank</span><span class="p">,</span> <span class="n">zero_infinity</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_ctc_loss_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_probs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">targets</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_lengths</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">target_lengths</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">neg_log_likelihood</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_alpha</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">blank</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">zero_infinity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_ctc_loss_backward(Tensor grad, Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, Tensor neg_log_likelihood, Tensor log_alpha, int blank, bool zero_infinity=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad</span><span class="p">))(</span><span class="n">grad</span><span class="p">,</span> <span class="n">log_probs</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">input_lengths</span><span class="p">,</span> <span class="n">target_lengths</span><span class="p">,</span> <span class="n">neg_log_likelihood</span><span class="p">,</span> <span class="n">log_alpha</span><span class="p">,</span> <span class="n">blank</span><span class="p">,</span> <span class="n">zero_infinity</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">det</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::det(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">diag_embed</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim1</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::diag_embed(Tensor self, int offset=0, int dim1=-2, int dim2=-1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">diagflat</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::diagflat(Tensor self, int offset=0) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">diagonal</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim1</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::diagonal(Tensor(a) self, int offset=0, int dim1=0, int dim2=1) -&gt; Tensor(a)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">div</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::div(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">div_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::div(Tensor self, Tensor other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">div</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::div(Tensor self, Scalar other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">dot</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::dot(Tensor self, Tensor tensor) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">tensor</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">dot_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::dot(Tensor self, Tensor tensor, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">tensor</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">einsum</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">equation</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">tensors</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::einsum(str equation, Tensor[] tensors) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">tensors</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">tensors</span><span class="p">))(</span><span class="n">equation</span><span class="p">,</span> <span class="n">tensors</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">embedding</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_idx</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sparse</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::embedding(Tensor weight, Tensor indices, int padding_idx=-1, bool scale_grad_by_freq=False, bool sparse=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">weight</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">weight</span><span class="p">))(</span><span class="n">weight</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">padding_idx</span><span class="p">,</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="n">sparse</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">embedding_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_weights</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_idx</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sparse</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::embedding_backward(Tensor grad, Tensor indices, int num_weights, int padding_idx, bool scale_grad_by_freq, bool sparse) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad</span><span class="p">))(</span><span class="n">grad</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">num_weights</span><span class="p">,</span> <span class="n">padding_idx</span><span class="p">,</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="n">sparse</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">embedding_dense_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_weights</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_idx</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::embedding_dense_backward(Tensor grad_output, Tensor indices, int num_weights, int padding_idx, bool scale_grad_by_freq) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">num_weights</span><span class="p">,</span> <span class="n">padding_idx</span><span class="p">,</span> <span class="n">scale_grad_by_freq</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">embedding_renorm_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="kt">double</span> <span class="n">max_norm</span><span class="p">,</span> <span class="kt">double</span> <span class="n">norm_type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::embedding_renorm_(Tensor(a!) self, Tensor indices, float max_norm, float norm_type) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">max_norm</span><span class="p">,</span> <span class="n">norm_type</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">embedding_sparse_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_weights</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_idx</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::embedding_sparse_backward(Tensor grad, Tensor indices, int num_weights, int padding_idx, bool scale_grad_by_freq) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad</span><span class="p">))(</span><span class="n">grad</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">num_weights</span><span class="p">,</span> <span class="n">padding_idx</span><span class="p">,</span> <span class="n">scale_grad_by_freq</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">embedding_bag</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offsets</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sparse</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">per_sample_weights</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::embedding_bag(Tensor weight, Tensor indices, Tensor offsets, bool scale_grad_by_freq=False, int mode=0, bool sparse=False, Tensor? per_sample_weights=None) -&gt; (Tensor, Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">weight</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">weight</span><span class="p">))(</span><span class="n">weight</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">sparse</span><span class="p">,</span> <span class="n">per_sample_weights</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_embedding_bag</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offsets</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sparse</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">per_sample_weights</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_embedding_bag(Tensor weight, Tensor indices, Tensor offsets, bool scale_grad_by_freq=False, int mode=0, bool sparse=False, Tensor? per_sample_weights=None) -&gt; (Tensor, Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">weight</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">weight</span><span class="p">))(</span><span class="n">weight</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">sparse</span><span class="p">,</span> <span class="n">per_sample_weights</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_embedding_bag_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offsets</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offset2bag</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bag_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">maximum_indices</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_weights</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sparse</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">per_sample_weights</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_embedding_bag_backward(Tensor grad, Tensor indices, Tensor offsets, Tensor offset2bag, Tensor bag_size, Tensor maximum_indices, int num_weights, bool scale_grad_by_freq, int mode, bool sparse, Tensor? per_sample_weights) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad</span><span class="p">))(</span><span class="n">grad</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">offset2bag</span><span class="p">,</span> <span class="n">bag_size</span><span class="p">,</span> <span class="n">maximum_indices</span><span class="p">,</span> <span class="n">num_weights</span><span class="p">,</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">sparse</span><span class="p">,</span> <span class="n">per_sample_weights</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_embedding_bag_sparse_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offsets</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offset2bag</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bag_size</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_weights</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">per_sample_weights</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_embedding_bag_sparse_backward(Tensor grad, Tensor indices, Tensor offsets, Tensor offset2bag, Tensor bag_size, int num_weights, bool scale_grad_by_freq, int mode, Tensor? per_sample_weights) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad</span><span class="p">))(</span><span class="n">grad</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">offset2bag</span><span class="p">,</span> <span class="n">bag_size</span><span class="p">,</span> <span class="n">num_weights</span><span class="p">,</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">per_sample_weights</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_embedding_bag_dense_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offsets</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offset2bag</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bag_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">maximum_indices</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_weights</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">per_sample_weights</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_embedding_bag_dense_backward(Tensor grad, Tensor indices, Tensor offsets, Tensor offset2bag, Tensor bag_size, Tensor maximum_indices, int num_weights, bool scale_grad_by_freq, int mode, Tensor? per_sample_weights) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad</span><span class="p">))(</span><span class="n">grad</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">offset2bag</span><span class="p">,</span> <span class="n">bag_size</span><span class="p">,</span> <span class="n">maximum_indices</span><span class="p">,</span> <span class="n">num_weights</span><span class="p">,</span> <span class="n">scale_grad_by_freq</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">per_sample_weights</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_embedding_bag_per_sample_weights_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offsets</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">offset2bag</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_embedding_bag_per_sample_weights_backward(Tensor grad, Tensor weight, Tensor indices, Tensor offsets, Tensor offset2bag, int mode) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad</span><span class="p">))(</span><span class="n">grad</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">offset2bag</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#ifdef BUILD_NAMEDTENSOR</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">empty</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">DimnameList</span><span class="o">&gt;</span> <span class="n">names</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::empty(int[] size, *, Dimname[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">DimnameList</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">size</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">empty</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MemoryFormat</span><span class="o">&gt;</span> <span class="n">memory_format</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::empty(int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, MemoryFormat? memory_format=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MemoryFormat</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">size</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">memory_format</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_empty_affine_quantized</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">,</span> <span class="kt">double</span> <span class="n">scale</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">zero_point</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MemoryFormat</span><span class="o">&gt;</span> <span class="n">memory_format</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_empty_affine_quantized(int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, float scale=1, int zero_point=0, MemoryFormat? memory_format=contiguous_format) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MemoryFormat</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">size</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">zero_point</span><span class="p">,</span> <span class="n">memory_format</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">empty_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MemoryFormat</span><span class="o">&gt;</span> <span class="n">memory_format</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::empty(int[] size, *, MemoryFormat? memory_format=None, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MemoryFormat</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">memory_format</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">empty_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::empty_like(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">empty_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MemoryFormat</span><span class="o">&gt;</span> <span class="n">memory_format</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::empty_like(Tensor self, *, ScalarType dtype, Layout layout, Device device, bool pin_memory=False, MemoryFormat? memory_format=contiguous_format) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MemoryFormat</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">self</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">memory_format</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">empty_strided</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::empty_strided(int[] size, int[] stride, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">erf</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::erf(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">erf_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::erf_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">erf_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::erf(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">erfc</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::erfc(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">erfc_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::erfc_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">erfc_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::erfc(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">exp</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::exp(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">exp_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::exp_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">exp_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::exp(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">expm1</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::expm1(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">expm1_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::expm1_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">expm1_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::expm1(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">eye</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::eye(int n, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">n</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">eye</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::eye(int n, int m, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">eye_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::eye(int n, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">eye_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::eye(int n, int m, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">flatten</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">start_dim</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">end_dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::flatten(Tensor self, int start_dim=0, int end_dim=-1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">start_dim</span><span class="p">,</span> <span class="n">end_dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fill_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fill_(Tensor(a!) self, Scalar value) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fill_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fill_(Tensor(a!) self, Tensor value) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">floor</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::floor(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">floor_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::floor_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">floor_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::floor(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">frac</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::frac(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">frac_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::frac_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">frac_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::frac(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">full</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">fill_value</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::full(int[] size, Scalar fill_value, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">size</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">full_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">fill_value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::full(int[] size, Scalar fill_value, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">full_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">fill_value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::full_like(Tensor self, Scalar fill_value) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">full_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">fill_value</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::full_like(Tensor self, Scalar fill_value, *, ScalarType dtype, Layout layout, Device device, bool pin_memory=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">from_file</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">filename</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">shared</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::from_file(str filename, bool? shared=None, int? size=0, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">filename</span><span class="p">,</span> <span class="n">shared</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">grid_sampler</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">interpolation_mode</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::grid_sampler(Tensor input, Tensor grid, int interpolation_mode, int padding_mode) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">interpolation_mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">grid_sampler_2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">interpolation_mode</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::grid_sampler_2d(Tensor input, Tensor grid, int interpolation_mode, int padding_mode) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">interpolation_mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">grid_sampler_2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">interpolation_mode</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::grid_sampler_2d_backward(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">interpolation_mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">grid_sampler_3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">interpolation_mode</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::grid_sampler_3d(Tensor input, Tensor grid, int interpolation_mode, int padding_mode) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">interpolation_mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">grid_sampler_3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">interpolation_mode</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">padding_mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::grid_sampler_3d_backward(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">interpolation_mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">hann_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::hann_window(int window_length, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">window_length</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">hann_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">periodic</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::hann_window(int window_length, bool periodic, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">window_length</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">hamming_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::hamming_window(int window_length, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">window_length</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">hamming_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">periodic</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::hamming_window(int window_length, bool periodic, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">window_length</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">hamming_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">periodic</span><span class="p">,</span> <span class="kt">double</span> <span class="n">alpha</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::hamming_window(int window_length, bool periodic, float alpha, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">window_length</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">hamming_window</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">window_length</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">periodic</span><span class="p">,</span> <span class="kt">double</span> <span class="n">alpha</span><span class="p">,</span> <span class="kt">double</span> <span class="n">beta</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::hamming_window(int window_length, bool periodic, float alpha, float beta, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">window_length</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">hinge_embedding_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">margin</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::hinge_embedding_loss(Tensor self, Tensor target, float margin=1.0, int reduction=Mean) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">margin</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">ger</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ger(Tensor self, Tensor vec2) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">vec2</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ger_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ger(Tensor self, Tensor vec2, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">vec2</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">group_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_groups</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cudnn_enabled</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::group_norm(Tensor input, int num_groups, Tensor? weight=None, Tensor? bias=None, float eps=1e-05, bool cudnn_enabled=True) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">num_groups</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">cudnn_enabled</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">fft</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">signal_ndim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">normalized</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fft(Tensor self, int signal_ndim, bool normalized=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">signal_ndim</span><span class="p">,</span> <span class="n">normalized</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">ifft</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">signal_ndim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">normalized</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ifft(Tensor self, int signal_ndim, bool normalized=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">signal_ndim</span><span class="p">,</span> <span class="n">normalized</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">rfft</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">signal_ndim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">normalized</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">onesided</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rfft(Tensor self, int signal_ndim, bool normalized=False, bool onesided=True) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">signal_ndim</span><span class="p">,</span> <span class="n">normalized</span><span class="p">,</span> <span class="n">onesided</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">irfft</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">signal_ndim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">normalized</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">onesided</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">signal_sizes</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::irfft(Tensor self, int signal_ndim, bool normalized=False, bool onesided=True, int[] signal_sizes=[]) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">signal_ndim</span><span class="p">,</span> <span class="n">normalized</span><span class="p">,</span> <span class="n">onesided</span><span class="p">,</span> <span class="n">signal_sizes</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_fft_with_size</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">signal_ndim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">complex_input</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">complex_output</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">inverse</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">checked_signal_sizes</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">normalized</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">onesided</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_sizes</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_fft_with_size(Tensor self, int signal_ndim, bool complex_input, bool complex_output, bool inverse, int[] checked_signal_sizes, bool normalized, bool onesided, int[] output_sizes) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">signal_ndim</span><span class="p">,</span> <span class="n">complex_input</span><span class="p">,</span> <span class="n">complex_output</span><span class="p">,</span> <span class="n">inverse</span><span class="p">,</span> <span class="n">checked_signal_sizes</span><span class="p">,</span> <span class="n">normalized</span><span class="p">,</span> <span class="n">onesided</span><span class="p">,</span> <span class="n">output_sizes</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="n">_cufft_get_plan_cache_size</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">device_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cufft_get_plan_cache_size(int device_index) -&gt; int&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">int64_t</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Backend</span><span class="o">::</span><span class="n">CPU</span><span class="p">,</span> <span class="nb">false</span><span class="p">)(</span><span class="n">device_index</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="n">_cufft_get_plan_cache_max_size</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">device_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cufft_get_plan_cache_max_size(int device_index) -&gt; int&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">int64_t</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Backend</span><span class="o">::</span><span class="n">CPU</span><span class="p">,</span> <span class="nb">false</span><span class="p">)(</span><span class="n">device_index</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">_cufft_set_plan_cache_max_size</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">device_index</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">max_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cufft_set_plan_cache_max_size(int device_index, int max_size) -&gt; void&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Backend</span><span class="o">::</span><span class="n">CPU</span><span class="p">,</span> <span class="nb">false</span><span class="p">)(</span><span class="n">device_index</span><span class="p">,</span> <span class="n">max_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">_cufft_clear_plan_cache</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">device_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cufft_clear_plan_cache(int device_index) -&gt; void&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Backend</span><span class="o">::</span><span class="n">CPU</span><span class="p">,</span> <span class="nb">false</span><span class="p">)(</span><span class="n">device_index</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">index</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::index(Tensor self, Tensor?[] indices) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">index_copy</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">source</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::index_copy(Tensor self, int dim, Tensor index, Tensor source) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">source</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index_put_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">accumulate</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::index_put_(Tensor(a!) self, Tensor?[] indices, Tensor values, bool accumulate=False) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">accumulate</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">index_put</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">accumulate</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::index_put(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">accumulate</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_index_put_impl_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">accumulate</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unsafe</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_index_put_impl_(Tensor(a!) self, Tensor?[] indices, Tensor values, bool accumulate=False, bool unsafe=False) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">accumulate</span><span class="p">,</span> <span class="n">unsafe</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">instance_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">use_input_stats</span><span class="p">,</span> <span class="kt">double</span> <span class="n">momentum</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cudnn_enabled</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::instance_norm(Tensor input, Tensor? weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool use_input_stats, float momentum, float eps, bool cudnn_enabled) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">running_mean</span><span class="p">,</span> <span class="n">running_var</span><span class="p">,</span> <span class="n">use_input_stats</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">cudnn_enabled</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::inverse(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">inverse_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::inverse(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_inverse_helper</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_inverse_helper(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">isclose</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="kt">double</span> <span class="n">rtol</span><span class="p">,</span> <span class="kt">double</span> <span class="n">atol</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">equal_nan</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::isclose(Tensor self, Tensor other, float rtol=1e-05, float atol=1e-08, bool equal_nan=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">,</span> <span class="n">equal_nan</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">isnan</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::isnan(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">is_distributed</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::is_distributed(Tensor self) -&gt; bool&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">is_floating_point</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::is_floating_point(Tensor self) -&gt; bool&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">is_complex</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::is_complex(Tensor self) -&gt; bool&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">is_nonzero</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::is_nonzero(Tensor self) -&gt; bool&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">is_same_size</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::is_same_size(Tensor self, Tensor other) -&gt; bool&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">is_signed</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::is_signed(Tensor self) -&gt; bool&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">kl_div</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::kl_div(Tensor self, Tensor target, int reduction=Mean) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">kl_div_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::kl_div_backward(Tensor grad_output, Tensor self, Tensor target, int reduction=Mean) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">kthvalue</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::kthvalue(Tensor self, int k, int dim=-1, bool keepdim=False) -&gt; (Tensor values, Tensor indices)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">kthvalue_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::kthvalue(Tensor self, int k, int dim=-1, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -&gt; (Tensor(a!) values, Tensor(b!) indices)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">values</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">layer_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">normalized_shape</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cudnn_enable</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::layer_norm(Tensor input, int[] normalized_shape, Tensor? weight=None, Tensor? bias=None, float eps=1e-05, bool cudnn_enable=True) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">normalized_shape</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">cudnn_enable</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">native_layer_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">N</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::native_layer_norm(Tensor input, Tensor? weight, Tensor? bias, int M, int N, float eps) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">eps</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">native_layer_norm_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rstd</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">N</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::native_layer_norm_backward(Tensor grad_out, Tensor input, Tensor mean, Tensor rstd, Tensor? weight, int M, int N, bool[3] output_mask) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_out</span><span class="p">))(</span><span class="n">grad_out</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">rstd</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">native_layer_norm_double_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ggI</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ggW</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ggb</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">gO</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rstd</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">N</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::native_layer_norm_double_backward(Tensor? ggI, Tensor? ggW, Tensor? ggb, Tensor gO, Tensor input, Tensor mean, Tensor rstd, Tensor? weight, int M, int N, bool[3] output_mask) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">gO</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">gO</span><span class="p">))(</span><span class="n">ggI</span><span class="p">,</span> <span class="n">ggW</span><span class="p">,</span> <span class="n">ggb</span><span class="p">,</span> <span class="n">gO</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">rstd</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">linear</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::linear(Tensor input, Tensor weight, Tensor? bias=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">mkldnn_linear</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mkldnn_linear(Tensor input, Tensor weight, Tensor? bias=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">fbgemm_linear_int8_weight</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">weight_scale</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">weight_zero_point</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fbgemm_linear_int8_weight(Tensor input, Tensor weight, Tensor packed, Tensor col_offsets, Scalar weight_scale, Scalar weight_zero_point, Tensor bias) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">packed</span><span class="p">,</span> <span class="n">col_offsets</span><span class="p">,</span> <span class="n">weight_scale</span><span class="p">,</span> <span class="n">weight_zero_point</span><span class="p">,</span> <span class="n">bias</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="kt">double</span><span class="p">,</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">fbgemm_linear_quantize_weight</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fbgemm_linear_quantize_weight(Tensor input) -&gt; (Tensor, Tensor, float, int)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="kt">double</span><span class="p">,</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">fbgemm_pack_gemm_matrix_fp16</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fbgemm_pack_gemm_matrix_fp16(Tensor input) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">fbgemm_linear_fp16_weight</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fbgemm_linear_fp16_weight(Tensor input, Tensor packed_weight, Tensor bias) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">packed_weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">fbgemm_pack_quantized_matrix</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">K</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fbgemm_pack_quantized_matrix(Tensor input, int K, int N) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">fbgemm_is_cpu_supported</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fbgemm_is_cpu_supported() -&gt; bool&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">()</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Backend</span><span class="o">::</span><span class="n">CPU</span><span class="p">,</span> <span class="nb">false</span><span class="p">)();</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">linspace</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">steps</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::linspace(Scalar start, Scalar end, int steps=100, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">linspace_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">steps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::linspace(Scalar start, Scalar end, int steps=100, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">steps</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">log</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">log10</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log10(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log10_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log10_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log10_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log10(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">log1p</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log1p(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log1p_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log1p_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log1p_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log1p(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">log2</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log2(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log2_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log2_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log2_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log2(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">logdet</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::logdet(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">logspace</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">steps</span><span class="p">,</span> <span class="kt">double</span> <span class="n">base</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::logspace(Scalar start, Scalar end, int steps=100, float base=10.0, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">logspace_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">steps</span><span class="p">,</span> <span class="kt">double</span> <span class="n">base</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::logspace(Scalar start, Scalar end, int steps=100, float base=10.0, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">log_softmax</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log_softmax(Tensor self, int dim, ScalarType? dtype=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_log_softmax</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">half_to_float</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_log_softmax(Tensor self, int dim, bool half_to_float) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">half_to_float</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_log_softmax_backward_data</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_log_softmax_backward_data(Tensor grad_output, Tensor output, int dim, Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">logsumexp</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::logsumexp(Tensor self, int[1] dim, bool keepdim=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">logsumexp_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::logsumexp(Tensor self, int[1] dim, bool keepdim=False, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">margin_ranking_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">margin</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::margin_ranking_loss(Tensor input1, Tensor input2, Tensor target, float margin=0.0, int reduction=Mean) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input1</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input1</span><span class="p">))(</span><span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">margin</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">matmul</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::matmul(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">matmul_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::matmul(Tensor self, Tensor other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">matrix_rank</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">tol</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">symmetric</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::matrix_rank(Tensor self, float tol, bool symmetric=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">symmetric</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">matrix_rank</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">symmetric</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::matrix_rank(Tensor self, bool symmetric=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">symmetric</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">matrix_power</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::matrix_power(Tensor self, int n) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">max</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max(Tensor self, int dim, bool keepdim=False) -&gt; (Tensor values, Tensor indices)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">max_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_values</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) max, Tensor(b!) max_values) -&gt; (Tensor(a!) values, Tensor(b!) indices)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">max</span><span class="p">,</span> <span class="n">max_values</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">max_values</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_values(Tensor self, int[1] dim, bool keepdim=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">max_pool1d_with_indices</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_pool1d_with_indices(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, int[1] dilation=1, bool ceil_mode=False) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">max_pool1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_pool1d(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, int[1] dilation=1, bool ceil_mode=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">max_pool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_pool2d(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">mkldnn_max_pool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mkldnn_max_pool2d(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">max_pool3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_pool3d(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">mean</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mean(Tensor self, *, ScalarType? dtype=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">mean</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mean(Tensor self, int[1] dim, bool keepdim=False, *, ScalarType? dtype=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mean(Tensor self, int[1] dim, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">median</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::median(Tensor self, int dim, bool keepdim=False) -&gt; (Tensor values, Tensor indices)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">median_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::median(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -&gt; (Tensor(a!) values, Tensor(b!) indices)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">values</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">min</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::min(Tensor self, int dim, bool keepdim=False) -&gt; (Tensor values, Tensor indices)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">min_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">min_indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::min(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) min, Tensor(b!) min_indices) -&gt; (Tensor(a!) values, Tensor(b!) indices)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">min</span><span class="p">,</span> <span class="n">min_indices</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">min_values</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::min_values(Tensor self, int[1] dim, bool keepdim=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">mkldnn_convolution</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mkldnn_convolution(Tensor self, Tensor weight, Tensor? bias, int[] padding, int[] stride, int[] dilation, int groups) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">mkldnn_convolution_backward_input</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">self_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bias_defined</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mkldnn_convolution_backward_input(int[] self_size, Tensor grad_output, Tensor weight, int[] padding, int[] stride, int[] dilation, int groups, bool bias_defined) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">self_size</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">bias_defined</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">mkldnn_convolution_backward_weights</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">weight_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bias_defined</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mkldnn_convolution_backward_weights(int[] weight_size, Tensor grad_output, Tensor self, int[] padding, int[] stride, int[] dilation, int groups, bool bias_defined) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">weight_size</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">bias_defined</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">mkldnn_convolution_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mkldnn_convolution_backward(Tensor self, Tensor grad_output, Tensor weight, int[] padding, int[] stride, int[] dilation, int groups, bool[3] output_mask) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">miopen_batch_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">,</span> <span class="kt">double</span> <span class="n">exponential_average_factor</span><span class="p">,</span> <span class="kt">double</span> <span class="n">epsilon</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::miopen_batch_norm(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">running_mean</span><span class="p">,</span> <span class="n">running_var</span><span class="p">,</span> <span class="n">training</span><span class="p">,</span> <span class="n">exponential_average_factor</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">miopen_batch_norm_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">save_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">save_var</span><span class="p">,</span> <span class="kt">double</span> <span class="n">epsilon</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::miopen_batch_norm_backward(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">running_mean</span><span class="p">,</span> <span class="n">running_var</span><span class="p">,</span> <span class="n">save_mean</span><span class="p">,</span> <span class="n">save_var</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">miopen_convolution</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::miopen_convolution(Tensor self, Tensor weight, Tensor? bias, int[] padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">miopen_convolution_backward_input</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">self_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::miopen_convolution_backward_input(int[] self_size, Tensor grad_output, Tensor weight, int[] padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">self_size</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">miopen_convolution_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::miopen_convolution_backward(Tensor self, Tensor grad_output, Tensor weight, int[] padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic, bool[3] output_mask) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">miopen_convolution_backward_bias</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::miopen_convolution_backward_bias(Tensor grad_output) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">miopen_convolution_backward_weight</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">weight_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::miopen_convolution_backward_weight(int[] weight_size, Tensor grad_output, Tensor self, int[] padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">weight_size</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">miopen_convolution_transpose</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::miopen_convolution_transpose(Tensor self, Tensor weight, Tensor? bias, int[] padding, int[] output_padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">miopen_convolution_transpose_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::miopen_convolution_transpose_backward(Tensor self, Tensor grad_output, Tensor weight, int[] padding, int[] output_padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic, bool[3] output_mask) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">miopen_convolution_transpose_backward_input</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::miopen_convolution_transpose_backward_input(Tensor grad_output, Tensor weight, int[] padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">miopen_convolution_transpose_backward_weight</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">weight_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::miopen_convolution_transpose_backward_weight(int[] weight_size, Tensor grad_output, Tensor self, int[] padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">weight_size</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">miopen_depthwise_convolution</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::miopen_depthwise_convolution(Tensor self, Tensor weight, Tensor? bias, int[] padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">miopen_depthwise_convolution_backward_input</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">self_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::miopen_depthwise_convolution_backward_input(int[] self_size, Tensor grad_output, Tensor weight, int[] padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">self_size</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">miopen_depthwise_convolution_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::miopen_depthwise_convolution_backward(Tensor self, Tensor grad_output, Tensor weight, int[] padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic, bool[3] output_mask) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">miopen_depthwise_convolution_backward_weight</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">weight_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">benchmark</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">deterministic</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::miopen_depthwise_convolution_backward_weight(int[] weight_size, Tensor grad_output, Tensor self, int[] padding, int[] stride, int[] dilation, int groups, bool benchmark, bool deterministic) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">weight_size</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">mm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mm(Tensor self, Tensor mat2) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">mat2</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mm(Tensor self, Tensor mat2, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">mat2</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_sparse_mm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sparse</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">dense</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sparse_mm(Tensor sparse, Tensor dense) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">sparse</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">sparse</span><span class="p">))(</span><span class="n">sparse</span><span class="p">,</span> <span class="n">dense</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">mode</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mode(Tensor self, int dim=-1, bool keepdim=False) -&gt; (Tensor values, Tensor indices)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">mode_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mode(Tensor self, int dim=-1, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -&gt; (Tensor(a!) values, Tensor(b!) indices)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">values</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">mul</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mul(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mul_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mul(Tensor self, Tensor other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">mul</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mul(Tensor self, Scalar other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">mv</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mv(Tensor self, Tensor vec) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mv_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mv(Tensor self, Tensor vec, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">mvlgamma</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mvlgamma(Tensor self, int p) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">narrow</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::narrow(Tensor(a) self, int dim, int start, int length) -&gt; Tensor(a)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">native_batch_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">,</span> <span class="kt">double</span> <span class="n">momentum</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::native_batch_norm(Tensor input, Tensor? weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float momentum, float eps) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">running_mean</span><span class="p">,</span> <span class="n">running_var</span><span class="p">,</span> <span class="n">training</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span> <span class="n">eps</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">batch_norm_stats</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::batch_norm_stats(Tensor input, float eps) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">eps</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">batch_norm_elemt</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">invstd</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::batch_norm_elemt(Tensor input, Tensor? weight, Tensor? bias, Tensor mean, Tensor invstd, float eps) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">invstd</span><span class="p">,</span> <span class="n">eps</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">batch_norm_gather_stats</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">invstd</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">double</span> <span class="n">momentum</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::batch_norm_gather_stats(Tensor input, Tensor mean, Tensor invstd, Tensor? running_mean, Tensor? running_var, float momentum, float eps, int count) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">invstd</span><span class="p">,</span> <span class="n">running_mean</span><span class="p">,</span> <span class="n">running_var</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">batch_norm_gather_stats_with_counts</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">invstd</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">double</span> <span class="n">momentum</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">counts</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::batch_norm_gather_stats_with_counts(Tensor input, Tensor mean, Tensor invstd, Tensor? running_mean, Tensor? running_var, float momentum, float eps, int[] counts) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">invstd</span><span class="p">,</span> <span class="n">running_mean</span><span class="p">,</span> <span class="n">running_var</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">counts</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">native_batch_norm_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">save_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">save_invstd</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::native_batch_norm_backward(Tensor grad_out, Tensor input, Tensor? weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_invstd, bool train, float eps, bool[3] output_mask) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_out</span><span class="p">))(</span><span class="n">grad_out</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">running_mean</span><span class="p">,</span> <span class="n">running_var</span><span class="p">,</span> <span class="n">save_mean</span><span class="p">,</span> <span class="n">save_invstd</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">batch_norm_backward_reduce</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">invstd</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">input_g</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">weight_g</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bias_g</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::batch_norm_backward_reduce(Tensor grad_out, Tensor input, Tensor mean, Tensor invstd, bool input_g, bool weight_g, bool bias_g) -&gt; (Tensor, Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_out</span><span class="p">))(</span><span class="n">grad_out</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">invstd</span><span class="p">,</span> <span class="n">input_g</span><span class="p">,</span> <span class="n">weight_g</span><span class="p">,</span> <span class="n">bias_g</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">batch_norm_backward_elemt</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">invstd</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean_dy</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean_dy_xmu</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::batch_norm_backward_elemt(Tensor grad_out, Tensor input, Tensor mean, Tensor invstd, Tensor? weight, Tensor mean_dy, Tensor mean_dy_xmu) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_out</span><span class="p">))(</span><span class="n">grad_out</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">invstd</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">mean_dy</span><span class="p">,</span> <span class="n">mean_dy_xmu</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">batch_norm_update_stats</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">running_var</span><span class="p">,</span> <span class="kt">double</span> <span class="n">momentum</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::batch_norm_update_stats(Tensor input, Tensor? running_mean, Tensor? running_var, float momentum) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">running_mean</span><span class="p">,</span> <span class="n">running_var</span><span class="p">,</span> <span class="n">momentum</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">_nnpack_available</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_nnpack_available() -&gt; bool&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">()</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Backend</span><span class="o">::</span><span class="n">CPU</span><span class="p">,</span> <span class="nb">false</span><span class="p">)();</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_nnpack_spatial_convolution</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_nnpack_spatial_convolution(Tensor input, Tensor weight, Tensor? bias, int[2] padding) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_nnpack_spatial_convolution_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_nnpack_spatial_convolution_backward(Tensor input, Tensor grad_output, Tensor weight, int[2] padding, bool[3] output_mask) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_nnpack_spatial_convolution_backward_input</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_nnpack_spatial_convolution_backward_input(Tensor input, Tensor grad_output, Tensor weight, int[2] padding) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_nnpack_spatial_convolution_backward_weight</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">weightsize</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_nnpack_spatial_convolution_backward_weight(Tensor input, int[] weightsize, Tensor grad_output, int[2] padding) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">weightsize</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">ones</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ones(int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">size</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ones_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ones(int[] size, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">ones_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ones_like(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">ones_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ones_like(Tensor self, *, ScalarType dtype, Layout layout, Device device, bool pin_memory=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">self</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">pairwise_distance</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::pairwise_distance(Tensor x1, Tensor x2, float p=2, float eps=1e-06, bool keepdim=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">x1</span><span class="p">))(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cdist</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cdist(Tensor x1, Tensor x2, float p=2) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">x1</span><span class="p">))(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_cdist_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cdist</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cdist_backward(Tensor grad, Tensor x1, Tensor x2, float p, Tensor cdist) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad</span><span class="p">))(</span><span class="n">grad</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cdist</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">pdist</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::pdist(Tensor self, float p=2) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_pdist_forward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_pdist_forward(Tensor self, float p=2) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_pdist_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">pdist</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_pdist_backward(Tensor grad, Tensor self, float p, Tensor pdist) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pdist</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cosine_similarity</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cosine_similarity(Tensor x1, Tensor x2, int dim=1, float eps=1e-08) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">x1</span><span class="p">))(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">eps</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">pixel_shuffle</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">upscale_factor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::pixel_shuffle(Tensor self, int upscale_factor) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">upscale_factor</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">pin_memory</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::pin_memory(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">pinverse</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">rcond</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::pinverse(Tensor self, float rcond=1e-15) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">rcond</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">poisson_nll_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">log_input</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">full</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::poisson_nll_loss(Tensor input, Tensor target, bool log_input, bool full, float eps, int reduction) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">log_input</span><span class="p">,</span> <span class="n">full</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">scalar_tensor</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::scalar_tensor(Scalar s, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">s</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">rand</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rand(int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">size</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">rand</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rand(int[] size, *, Generator? generator, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">size</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rand_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rand(int[] size, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rand_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rand(int[] size, *, Generator? generator, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">rand_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rand_like(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">rand_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rand_like(Tensor self, *, ScalarType dtype, Layout layout, Device device, bool pin_memory=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">self</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">randint</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randint(int high, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">high</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">randint</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randint(int high, int[] size, *, Generator? generator, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">high</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">randint</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randint(int low, int high, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">randint</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randint(int low, int high, int[] size, *, Generator? generator, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">randint_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randint(int high, int[] size, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">randint_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randint(int high, int[] size, *, Generator? generator, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">randint_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randint(int low, int high, int[] size, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">randint_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randint(int low, int high, int[] size, *, Generator? generator, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">randint_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randint_like(Tensor self, int high) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">randint_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randint_like(Tensor self, int low, int high) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">randint_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randint_like(Tensor self, int high, *, ScalarType dtype, Layout layout, Device device, bool pin_memory=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">self</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">randint_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">high</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randint_like(Tensor self, int low, int high, *, ScalarType dtype, Layout layout, Device device, bool pin_memory=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">self</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">randn</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randn(int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">size</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">randn</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randn(int[] size, *, Generator? generator, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">size</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">randn_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randn(int[] size, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">randn_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randn(int[] size, *, Generator? generator, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">randn_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randn_like(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">randn_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randn_like(Tensor self, *, ScalarType dtype, Layout layout, Device device, bool pin_memory=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">self</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">randperm</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randperm(int n, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">n</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">randperm</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randperm(int n, *, Generator? generator, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">n</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">randperm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randperm(int n, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">randperm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::randperm(int n, *, Generator? generator, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">range</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">step</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::range(Scalar start, Scalar end, Scalar step=1, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">range</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::range(Scalar start, Scalar end, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">range_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">start</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">end</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">step</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::range(Scalar start, Scalar end, Scalar step=1, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">reciprocal</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::reciprocal(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">reciprocal_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::reciprocal_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">reciprocal_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::reciprocal(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">neg</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::neg(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">neg_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::neg_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">neg_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::neg(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">repeat_interleave</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">repeats</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::repeat_interleave(Tensor repeats) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">repeats</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">repeats</span><span class="p">))(</span><span class="n">repeats</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">repeat_interleave</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::repeat_interleave(Tensor self, Tensor repeats, int? dim=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">repeat_interleave</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::repeat_interleave(Tensor self, int repeats, int? dim=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">reshape</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">shape</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::reshape(Tensor self, int[] shape) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_mkldnn_reshape</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">shape</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_mkldnn_reshape(Tensor self, int[] shape) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">round</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::round(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">round_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::round_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">round_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::round(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">rrelu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lower</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">upper</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rrelu(Tensor self, Scalar lower=0.125, Scalar upper=0.3333333333333333, bool training=False, Generator? generator=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">training</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rrelu_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lower</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">upper</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rrelu_(Tensor(a!) self, Scalar lower=0.125, Scalar upper=0.3333333333333333, bool training=False, Generator? generator=None) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">training</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">relu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::relu(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">relu_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::relu_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">prelu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::prelu(Tensor self, Tensor weight) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">prelu_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::prelu_backward(Tensor grad_output, Tensor self, Tensor weight) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">gelu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::gelu(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">gelu_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::gelu_backward(Tensor grad, Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">hardshrink</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lambd</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::hardshrink(Tensor self, Scalar lambd=0.5) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">lambd</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">hardshrink_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lambd</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::hardshrink_backward(Tensor grad_out, Tensor self, Scalar lambd) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">lambd</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">rsqrt</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rsqrt(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rsqrt_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rsqrt_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rsqrt_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rsqrt(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#ifdef BUILD_NAMEDTENSOR</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">select</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Dimname</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::select(Tensor(a) self, Dimname dim, int index) -&gt; Tensor(a)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Dimname</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">select</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::select(Tensor(a) self, int dim, int index) -&gt; Tensor(a)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">selu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::selu(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">selu_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::selu_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">celu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::celu(Tensor self, Scalar alpha=1.0) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">celu_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::celu_(Tensor(a!) self, Scalar alpha=1.0) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">sigmoid</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sigmoid(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sigmoid_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sigmoid_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sigmoid_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sigmoid(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">sin</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sin(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sin_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sin_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sin_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sin(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">sinh</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sinh(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sinh_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sinh_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sinh_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sinh(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">detach</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::detach(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">detach_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::detach_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="n">size</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::size(Tensor self, int dim) -&gt; int&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">int64_t</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">slice</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">step</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::slice(Tensor(a) self, int dim=0, int start=0, int end=9223372036854775807, int step=1) -&gt; Tensor(a)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">slogdet</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::slogdet(Tensor self) -&gt; (Tensor sign, Tensor logabsdet)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">smm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::smm(Tensor self, Tensor mat2) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">mat2</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">softmax</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::softmax(Tensor self, int dim, ScalarType? dtype=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_softmax</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">half_to_float</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_softmax(Tensor self, int dim, bool half_to_float) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">half_to_float</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_softmax_backward_data</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_softmax_backward_data(Tensor grad_output, Tensor output, int dim, Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sparse_add_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sparse_add(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sparse_dense_add_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sparse_dense_add(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sparse_div_zerodim_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sparse_div_zerodim(Tensor self, Tensor other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sparse_div_scalar_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sparse_div_scalar(Tensor self, Scalar other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sparse_mul_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sparse_mul(Tensor self, Tensor other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sparse_mul_zerodim_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sparse_mul_zerodim(Tensor self, Tensor other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_sparse_mul_scalar_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sparse_mul_scalar(Tensor self, Scalar other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">split</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">split_size</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::split(Tensor(a) self, int split_size, int dim=0) -&gt; Tensor(a)[]&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">split_size</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">split_with_sizes</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">split_sizes</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::split_with_sizes(Tensor self, int[] split_sizes, int dim=0) -&gt; Tensor[]&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">split_sizes</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">squeeze</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::squeeze(Tensor(a) self) -&gt; Tensor(a)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">squeeze</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::squeeze(Tensor(a) self, int dim) -&gt; Tensor(a)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">sspaddmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sspaddmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sspaddmm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sspaddmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">stack</span><span class="p">(</span><span class="n">TensorList</span> <span class="n">tensors</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::stack(Tensor[] tensors, int dim=0) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">TensorList</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">tensors</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">tensors</span><span class="p">))(</span><span class="n">tensors</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">stack_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">tensors</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::stack(Tensor[] tensors, int dim=0, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">tensors</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">stft</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n_fft</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">hop_length</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">win_length</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">window</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">normalized</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">onesided</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::stft(Tensor self, int n_fft, int? hop_length=None, int? win_length=None, Tensor? window=None, bool normalized=False, bool onesided=True) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="p">,</span> <span class="n">win_length</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">normalized</span><span class="p">,</span> <span class="n">onesided</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="n">stride</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::stride(Tensor self, int dim) -&gt; int&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">int64_t</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">sum</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sum(Tensor self, *, ScalarType? dtype=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">sum</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sum(Tensor self, int[1] dim, bool keepdim=False, *, ScalarType? dtype=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sum_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sum(Tensor self, int[1] dim, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">sqrt</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sqrt(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sqrt_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sqrt_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sqrt_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sqrt(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">std</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::std(Tensor self, bool unbiased=True) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">unbiased</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">std</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::std(Tensor self, int[1] dim, bool unbiased=True, bool keepdim=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">unbiased</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">std_mean</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::std_mean(Tensor self, bool unbiased=True) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">unbiased</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">std_mean</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::std_mean(Tensor self, int[1] dim, bool unbiased=True, bool keepdim=False) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">unbiased</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">std_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::std(Tensor self, int[1] dim, bool unbiased=True, bool keepdim=False, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">unbiased</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">prod</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::prod(Tensor self, *, ScalarType? dtype=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">prod</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::prod(Tensor self, int dim, bool keepdim=False, *, ScalarType? dtype=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">prod_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::prod(Tensor self, int dim, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ScalarType</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">t</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::t(Tensor(a) self) -&gt; Tensor(a)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">tan</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::tan(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tan_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::tan_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tan_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::tan(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">tanh</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::tanh(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tanh_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::tanh_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tanh_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::tanh(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">tensordot</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dims_self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dims_other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::tensordot(Tensor self, Tensor other, int[] dims_self, int[] dims_other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">dims_self</span><span class="p">,</span> <span class="n">dims_other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">threshold</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::threshold(Tensor self, Scalar threshold, Scalar value) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">threshold_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::threshold_(Tensor(a!) self, Scalar threshold, Scalar value) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">threshold_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::threshold(Tensor self, Scalar threshold, Scalar value, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">threshold_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">threshold</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::threshold_backward(Tensor grad_output, Tensor self, Scalar threshold) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">transpose</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::transpose(Tensor(a) self, int dim0, int dim1) -&gt; Tensor(a)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim0</span><span class="p">,</span> <span class="n">dim1</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_mkldnn_transpose</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_mkldnn_transpose(Tensor self, int dim0, int dim1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim0</span><span class="p">,</span> <span class="n">dim1</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_mkldnn_transpose_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_mkldnn_transpose_(Tensor(a!) self, int dim0, int dim1) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim0</span><span class="p">,</span> <span class="n">dim1</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">one_hot</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_classes</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::one_hot(Tensor self, int num_classes=-1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">flip</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dims</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::flip(Tensor self, int[] dims) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dims</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">roll</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dims</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::roll(Tensor self, int[1] shifts, int[1] dims=[]) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">dims</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">rot90</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">k</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dims</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rot90(Tensor self, int k=1, int[] dims=[0,1]) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">dims</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">trapz</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::trapz(Tensor y, Tensor x, *, int dim=-1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">y</span><span class="p">))(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">trapz</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dx</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::trapz(Tensor y, *, float dx=1, int dim=-1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">y</span><span class="p">))(</span><span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_trilinear</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">i1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">i2</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">i3</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">expand1</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">expand2</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">expand3</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">sumdim</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">unroll_dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_trilinear(Tensor i1, Tensor i2, Tensor i3, int[] expand1, int[] expand2, int[] expand3, int[] sumdim, int unroll_dim=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">i1</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">i1</span><span class="p">))(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">i3</span><span class="p">,</span> <span class="n">expand1</span><span class="p">,</span> <span class="n">expand2</span><span class="p">,</span> <span class="n">expand3</span><span class="p">,</span> <span class="n">sumdim</span><span class="p">,</span> <span class="n">unroll_dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">triplet_margin_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">anchor</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">positive</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">negative</span><span class="p">,</span> <span class="kt">double</span> <span class="n">margin</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">swap</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::triplet_margin_loss(Tensor anchor, Tensor positive, Tensor negative, float margin=1.0, float p=2, float eps=1e-06, bool swap=False, int reduction=Mean) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">anchor</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">anchor</span><span class="p">))(</span><span class="n">anchor</span><span class="p">,</span> <span class="n">positive</span><span class="p">,</span> <span class="n">negative</span><span class="p">,</span> <span class="n">margin</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">swap</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">trunc</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::trunc(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">trunc_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::trunc_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">trunc_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::trunc(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">_has_same_tensorimpl_type</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_has_same_tensorimpl_type(Tensor self, Tensor other) -&gt; bool&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_unique</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sorted</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_inverse</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_unique(Tensor self, bool sorted=True, bool return_inverse=False) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">sorted</span><span class="p">,</span> <span class="n">return_inverse</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">unique_dim</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sorted</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_inverse</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_counts</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::unique_dim(Tensor self, int dim, bool sorted=True, bool return_inverse=False, bool return_counts=False) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">sorted</span><span class="p">,</span> <span class="n">return_inverse</span><span class="p">,</span> <span class="n">return_counts</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">unique_consecutive</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_inverse</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_counts</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::unique_consecutive(Tensor self, bool return_inverse=False, bool return_counts=False, int? dim=None) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">return_inverse</span><span class="p">,</span> <span class="n">return_counts</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">unique_dim_consecutive</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_inverse</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_counts</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::unique_dim_consecutive(Tensor self, int dim, bool return_inverse=False, bool return_counts=False) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">return_inverse</span><span class="p">,</span> <span class="n">return_counts</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_unique2</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sorted</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_inverse</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">return_counts</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_unique2(Tensor self, bool sorted=True, bool return_inverse=False, bool return_counts=False) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">sorted</span><span class="p">,</span> <span class="n">return_inverse</span><span class="p">,</span> <span class="n">return_counts</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_unsafe_view</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_unsafe_view(Tensor self, int[] size) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">unsqueeze</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::unsqueeze(Tensor(a) self, int dim) -&gt; Tensor(a)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">var</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::var(Tensor self, bool unbiased=True) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">unbiased</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">var</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::var(Tensor self, int[1] dim, bool unbiased=True, bool keepdim=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">unbiased</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">var_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::var(Tensor self, int[1] dim, bool unbiased=True, bool keepdim=False, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">unbiased</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">var_mean</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::var_mean(Tensor self, bool unbiased=True) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">unbiased</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">var_mean</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::var_mean(Tensor self, int[1] dim, bool unbiased=True, bool keepdim=False) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">unbiased</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">where</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">condition</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::where(Tensor condition, Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">condition</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">where</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::where(Tensor condition) -&gt; Tensor[]&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">condition</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">condition</span><span class="p">))(</span><span class="n">condition</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_s_where</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">condition</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_s_where(Tensor condition, Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">condition</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">norm_except_dim</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">pow</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::norm_except_dim(Tensor v, int pow=2, int dim=0) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">v</span><span class="p">))(</span><span class="n">v</span><span class="p">,</span> <span class="n">pow</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_weight_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_weight_norm(Tensor v, Tensor g, int dim=0) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">v</span><span class="p">))(</span><span class="n">v</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_weight_norm_cuda_interface</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_weight_norm_cuda_interface(Tensor v, Tensor g, int dim=0) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">v</span><span class="p">))(</span><span class="n">v</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_weight_norm_cuda_interface_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_w</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">saved_v</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">saved_g</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">saved_norms</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_weight_norm_cuda_interface_backward(Tensor grad_w, Tensor saved_v, Tensor saved_g, Tensor saved_norms, int dim) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_w</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_w</span><span class="p">))(</span><span class="n">grad_w</span><span class="p">,</span> <span class="n">saved_v</span><span class="p">,</span> <span class="n">saved_g</span><span class="p">,</span> <span class="n">saved_norms</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_weight_norm_differentiable_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_w</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">saved_v</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">saved_g</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">saved_norms</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_weight_norm_differentiable_backward(Tensor grad_w, Tensor saved_v, Tensor saved_g, Tensor saved_norms, int dim) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_w</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_w</span><span class="p">))(</span><span class="n">grad_w</span><span class="p">,</span> <span class="n">saved_v</span><span class="p">,</span> <span class="n">saved_g</span><span class="p">,</span> <span class="n">saved_norms</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">zeros</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::zeros(int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">size</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">zeros_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::zeros(int[] size, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">zeros_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::zeros_like(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">zeros_like</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::zeros_like(Tensor self, *, ScalarType dtype, Layout layout, Device device, bool pin_memory=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">self</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_standard_gamma_grad</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_standard_gamma_grad(Tensor self, Tensor output) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_standard_gamma</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_standard_gamma(Tensor self, Generator? generator=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_dirichlet_grad</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">alpha</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">total</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_dirichlet_grad(Tensor x, Tensor alpha, Tensor total) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">x</span><span class="p">))(</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_sample_dirichlet</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sample_dirichlet(Tensor self, Generator? generator=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">poisson</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::poisson(Tensor self, Generator? generator=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">native_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::native_norm(Tensor self, Scalar p=2) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_sparse_sum</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sparse_sum(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_sparse_sum</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">ScalarType</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sparse_sum(Tensor self, *, ScalarType dtype) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">ScalarType</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_sparse_sum</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sparse_sum(Tensor self, int[1] dim) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_sparse_sum</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="n">ScalarType</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sparse_sum(Tensor self, int[1] dim, *, ScalarType dtype) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">ScalarType</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_sparse_sum_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sparse_sum_backward(Tensor grad, Tensor self, int[] dim) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="n">ScalarType</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::norm(Tensor self, Scalar? p, *, ScalarType dtype) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ScalarType</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::norm(Tensor self, Scalar p=2) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">ScalarType</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::norm(Tensor self, Scalar? p, int[1] dim, bool keepdim, *, ScalarType dtype) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">ScalarType</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::norm(Tensor self, Scalar? p, int[1] dim, bool keepdim=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">norm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">ScalarType</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::norm(Tensor self, Scalar? p, int[1] dim, bool keepdim, *, ScalarType dtype, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">ScalarType</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">norm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::norm(Tensor self, Scalar? p, int[1] dim, bool keepdim=False, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">frobenius_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::frobenius_norm(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">frobenius_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::frobenius_norm(Tensor self, int[1] dim, bool keepdim=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">frobenius_norm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::frobenius_norm(Tensor self, int[1] dim, bool keepdim=False, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">nuclear_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nuclear_norm(Tensor self, bool keepdim=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">nuclear_norm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nuclear_norm(Tensor self, bool keepdim=False, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">nuclear_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nuclear_norm(Tensor self, int[2] dim, bool keepdim=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">nuclear_norm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nuclear_norm(Tensor self, int[2] dim, bool keepdim=False, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">clone</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::clone(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">resize_as_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">the_template</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::resize_as_(Tensor(a!) self, Tensor the_template) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">the_template</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">pow_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">exponent</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::pow(Tensor self, Scalar exponent, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">exponent</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">pow</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">exponent</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::pow(Tensor self, Scalar exponent) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">exponent</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">zero_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::zero_(Tensor(a!) self) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sub_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sub(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">sub</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sub(Tensor self, Tensor other, *, Scalar alpha=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">sub</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sub(Tensor self, Scalar other, Scalar alpha=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">rsub</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rsub(Tensor self, Tensor other, *, Scalar alpha=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">rsub</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rsub(Tensor self, Scalar other, Scalar alpha=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">s_native_addmm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::s_native_addmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">s_native_addmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::s_native_addmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">s_native_addmm_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::s_native_addmm_(Tensor(a!) self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_sparse_addmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sparse</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">dense</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sparse_addmm(Tensor self, Tensor sparse, Tensor dense, *, Scalar beta=1, Scalar alpha=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">sparse</span><span class="p">,</span> <span class="n">dense</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">addmm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::addmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">addmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::addmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">sparse_coo_tensor</span><span class="p">(</span><span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sparse_coo_tensor(int[] size, *, ScalarType dtype, Layout layout, Device device, bool pin_memory=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">size</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">sparse_coo_tensor</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sparse_coo_tensor(Tensor indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">sparse_coo_tensor</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sparse_coo_tensor(Tensor indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_sparse_coo_tensor_unsafe</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sparse_coo_tensor_unsafe(Tensor indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_sparse_coo_tensor_with_dims</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">sparse_dim</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dense_dim</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sparse_coo_tensor_with_dims(int sparse_dim, int dense_dim, int[] size, *, ScalarType dtype, Layout layout, Device device, bool pin_memory=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">sparse_dim</span><span class="p">,</span> <span class="n">dense_dim</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_sparse_coo_tensor_with_dims_and_tensors</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">sparse_dim</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dense_dim</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_sparse_coo_tensor_with_dims_and_tensors(int sparse_dim, int dense_dim, int[] size, Tensor indices, Tensor values, *, ScalarType dtype, Layout layout, Device device, bool pin_memory=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">sparse_dim</span><span class="p">,</span> <span class="n">dense_dim</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">to_dense_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::to_dense_backward(Tensor grad, Tensor input) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad</span><span class="p">))(</span><span class="n">grad</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hspmm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::hspmm(Tensor mat1, Tensor mat2, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">hspmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::hspmm(Tensor mat1, Tensor mat2) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">mat1</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">mat1</span><span class="p">))(</span><span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">copy_sparse_to_sparse_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">non_blocking</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::copy_sparse_to_sparse_(Tensor(a!) self, Tensor src, bool non_blocking=False) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">non_blocking</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="n">numel</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::numel(Tensor self) -&gt; int&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">int64_t</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">unbind</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::unbind(Tensor(a) self, int dim=0) -&gt; Tensor(a)[]&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">mkldnn_reorder_conv2d_weight</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">groups</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mkldnn_reorder_conv2d_weight(Tensor self, int[2] padding=0, int[2] stride=1, int[2] dilation=1, int groups=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">groups</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">to_mkldnn_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::to_mkldnn_backward(Tensor grad, Tensor input) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad</span><span class="p">))(</span><span class="n">grad</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">quantize_linear</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">scale</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">zero_point</span><span class="p">,</span> <span class="n">ScalarType</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::quantize_linear(Tensor self, float scale, int zero_point, ScalarType dtype) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">ScalarType</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">zero_point</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">quantize_linear_per_channel</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">scales</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">zero_points</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">axis</span><span class="p">,</span> <span class="n">ScalarType</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::quantize_linear_per_channel(Tensor self, Tensor scales, Tensor zero_points, int[] axis, ScalarType dtype) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">ScalarType</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">zero_points</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">dequantize</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::dequantize(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_dequantize_linear</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">scale</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">zero_point</span><span class="p">,</span> <span class="n">ScalarType</span> <span class="n">dtype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_dequantize_linear(Tensor self, float scale, int zero_point, ScalarType dtype) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">ScalarType</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">zero_point</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">double</span> <span class="n">q_scale</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::q_scale(Tensor self) -&gt; float&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">double</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span> <span class="n">q_zero_point</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::q_zero_point(Tensor self) -&gt; int&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">int64_t</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">int_repr</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::int_repr(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_per_tensor_affine_qtensor</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">double</span> <span class="n">scale</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">zero_point</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_per_tensor_affine_qtensor(Tensor self, float scale, int zero_point) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">zero_point</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">TensorList</span> <span class="n">tensors</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::meshgrid(Tensor[] tensors) -&gt; Tensor[]&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">TensorList</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">tensors</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">tensors</span><span class="p">))(</span><span class="n">tensors</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cartesian_prod</span><span class="p">(</span><span class="n">TensorList</span> <span class="n">tensors</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cartesian_prod(Tensor[] tensors) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">TensorList</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">tensors</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">tensors</span><span class="p">))(</span><span class="n">tensors</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">combinations</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">r</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">with_replacement</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::combinations(Tensor self, int r=2, bool with_replacement=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">with_replacement</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Scalar</span> <span class="n">_local_scalar_dense</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_local_scalar_dense(Tensor self) -&gt; Scalar&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Scalar</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_thnn_fused_lstm_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input_gates</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hidden_gates</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input_bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hidden_bias</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_thnn_fused_lstm_cell(Tensor input_gates, Tensor hidden_gates, Tensor cx, Tensor? input_bias=None, Tensor? hidden_bias=None) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input_gates</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input_gates</span><span class="p">))(</span><span class="n">input_gates</span><span class="p">,</span> <span class="n">hidden_gates</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">input_bias</span><span class="p">,</span> <span class="n">hidden_bias</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_thnn_fused_lstm_cell_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_hy</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_cy</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cy</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">workspace</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_bias</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_thnn_fused_lstm_cell_backward(Tensor? grad_hy, Tensor? grad_cy, Tensor cx, Tensor cy, Tensor workspace, bool has_bias) -&gt; (Tensor, Tensor, Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">cx</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">cx</span><span class="p">))(</span><span class="n">grad_hy</span><span class="p">,</span> <span class="n">grad_cy</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">workspace</span><span class="p">,</span> <span class="n">has_bias</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_thnn_fused_gru_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input_gates</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hidden_gates</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input_bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hidden_bias</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_thnn_fused_gru_cell(Tensor input_gates, Tensor hidden_gates, Tensor hx, Tensor? input_bias=None, Tensor? hidden_bias=None) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input_gates</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input_gates</span><span class="p">))(</span><span class="n">input_gates</span><span class="p">,</span> <span class="n">hidden_gates</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">input_bias</span><span class="p">,</span> <span class="n">hidden_bias</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_thnn_fused_gru_cell_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_hy</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">workspace</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_bias</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_thnn_fused_gru_cell_backward(Tensor grad_hy, Tensor workspace, bool has_bias) -&gt; (Tensor, Tensor, Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_hy</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_hy</span><span class="p">))(</span><span class="n">grad_hy</span><span class="p">,</span> <span class="n">workspace</span><span class="p">,</span> <span class="n">has_bias</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lstm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::lstm(Tensor input, Tensor[] hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional, bool batch_first) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">has_biases</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="n">batch_first</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lstm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::lstm(Tensor data, Tensor batch_sizes, Tensor[] hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">data</span><span class="p">))(</span><span class="n">data</span><span class="p">,</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">has_biases</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">bidirectional</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">gru</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::gru(Tensor input, Tensor hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional, bool batch_first) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">has_biases</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="n">batch_first</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">gru</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::gru(Tensor data, Tensor batch_sizes, Tensor hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">data</span><span class="p">))(</span><span class="n">data</span><span class="p">,</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">has_biases</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">bidirectional</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">rnn_tanh</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rnn_tanh(Tensor input, Tensor hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional, bool batch_first) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">has_biases</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="n">batch_first</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">rnn_tanh</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rnn_tanh(Tensor data, Tensor batch_sizes, Tensor hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">data</span><span class="p">))(</span><span class="n">data</span><span class="p">,</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">has_biases</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">bidirectional</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">rnn_relu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rnn_relu(Tensor input, Tensor hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional, bool batch_first) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">has_biases</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="n">batch_first</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">rnn_relu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rnn_relu(Tensor data, Tensor batch_sizes, Tensor hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">data</span><span class="p">))(</span><span class="n">data</span><span class="p">,</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">has_biases</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">bidirectional</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lstm_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_hh</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::lstm_cell(Tensor input, Tensor[] hx, Tensor w_ih, Tensor w_hh, Tensor? b_ih=None, Tensor? b_hh=None) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">w_ih</span><span class="p">,</span> <span class="n">w_hh</span><span class="p">,</span> <span class="n">b_ih</span><span class="p">,</span> <span class="n">b_hh</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">gru_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_hh</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::gru_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor? b_ih=None, Tensor? b_hh=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">w_ih</span><span class="p">,</span> <span class="n">w_hh</span><span class="p">,</span> <span class="n">b_ih</span><span class="p">,</span> <span class="n">b_hh</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">rnn_tanh_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_hh</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rnn_tanh_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor? b_ih=None, Tensor? b_hh=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">w_ih</span><span class="p">,</span> <span class="n">w_hh</span><span class="p">,</span> <span class="n">b_ih</span><span class="p">,</span> <span class="n">b_hh</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">rnn_relu_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_hh</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rnn_relu_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor? b_ih=None, Tensor? b_hh=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">w_ih</span><span class="p">,</span> <span class="n">w_hh</span><span class="p">,</span> <span class="n">b_ih</span><span class="p">,</span> <span class="n">b_hh</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">quantized_lstm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">hx</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">params</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_biases</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_layers</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dropout</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::quantized_lstm(Tensor input, Tensor[] hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional, bool batch_first) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">has_biases</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">bidirectional</span><span class="p">,</span> <span class="n">batch_first</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">quantized_lstm_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets_hh</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale_ih</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale_hh</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">zero_point_ih</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">zero_point_hh</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::quantized_lstm_cell(Tensor input, Tensor[] hx, Tensor w_ih, Tensor w_hh, Tensor b_ih, Tensor b_hh, Tensor packed_ih, Tensor packed_hh, Tensor col_offsets_ih, Tensor col_offsets_hh, Scalar scale_ih, Scalar scale_hh, Scalar zero_point_ih, Scalar zero_point_hh) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">w_ih</span><span class="p">,</span> <span class="n">w_hh</span><span class="p">,</span> <span class="n">b_ih</span><span class="p">,</span> <span class="n">b_hh</span><span class="p">,</span> <span class="n">packed_ih</span><span class="p">,</span> <span class="n">packed_hh</span><span class="p">,</span> <span class="n">col_offsets_ih</span><span class="p">,</span> <span class="n">col_offsets_hh</span><span class="p">,</span> <span class="n">scale_ih</span><span class="p">,</span> <span class="n">scale_hh</span><span class="p">,</span> <span class="n">zero_point_ih</span><span class="p">,</span> <span class="n">zero_point_hh</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">quantized_gru_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets_hh</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale_ih</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale_hh</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">zero_point_ih</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">zero_point_hh</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::quantized_gru_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor b_ih, Tensor b_hh, Tensor packed_ih, Tensor packed_hh, Tensor col_offsets_ih, Tensor col_offsets_hh, Scalar scale_ih, Scalar scale_hh, Scalar zero_point_ih, Scalar zero_point_hh) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">w_ih</span><span class="p">,</span> <span class="n">w_hh</span><span class="p">,</span> <span class="n">b_ih</span><span class="p">,</span> <span class="n">b_hh</span><span class="p">,</span> <span class="n">packed_ih</span><span class="p">,</span> <span class="n">packed_hh</span><span class="p">,</span> <span class="n">col_offsets_ih</span><span class="p">,</span> <span class="n">col_offsets_hh</span><span class="p">,</span> <span class="n">scale_ih</span><span class="p">,</span> <span class="n">scale_hh</span><span class="p">,</span> <span class="n">zero_point_ih</span><span class="p">,</span> <span class="n">zero_point_hh</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">quantized_rnn_relu_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets_hh</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale_ih</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale_hh</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">zero_point_ih</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">zero_point_hh</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::quantized_rnn_relu_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor b_ih, Tensor b_hh, Tensor packed_ih, Tensor packed_hh, Tensor col_offsets_ih, Tensor col_offsets_hh, Scalar scale_ih, Scalar scale_hh, Scalar zero_point_ih, Scalar zero_point_hh) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">w_ih</span><span class="p">,</span> <span class="n">w_hh</span><span class="p">,</span> <span class="n">b_ih</span><span class="p">,</span> <span class="n">b_hh</span><span class="p">,</span> <span class="n">packed_ih</span><span class="p">,</span> <span class="n">packed_hh</span><span class="p">,</span> <span class="n">col_offsets_ih</span><span class="p">,</span> <span class="n">col_offsets_hh</span><span class="p">,</span> <span class="n">scale_ih</span><span class="p">,</span> <span class="n">scale_hh</span><span class="p">,</span> <span class="n">zero_point_ih</span><span class="p">,</span> <span class="n">zero_point_hh</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">quantized_rnn_tanh_cell</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hx</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">w_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">b_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">packed_hh</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets_ih</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col_offsets_hh</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale_ih</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale_hh</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">zero_point_ih</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">zero_point_hh</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::quantized_rnn_tanh_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor b_ih, Tensor b_hh, Tensor packed_ih, Tensor packed_hh, Tensor col_offsets_ih, Tensor col_offsets_hh, Scalar scale_ih, Scalar scale_hh, Scalar zero_point_ih, Scalar zero_point_hh) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">hx</span><span class="p">,</span> <span class="n">w_ih</span><span class="p">,</span> <span class="n">w_hh</span><span class="p">,</span> <span class="n">b_ih</span><span class="p">,</span> <span class="n">b_hh</span><span class="p">,</span> <span class="n">packed_ih</span><span class="p">,</span> <span class="n">packed_hh</span><span class="p">,</span> <span class="n">col_offsets_ih</span><span class="p">,</span> <span class="n">col_offsets_hh</span><span class="p">,</span> <span class="n">scale_ih</span><span class="p">,</span> <span class="n">scale_hh</span><span class="p">,</span> <span class="n">zero_point_ih</span><span class="p">,</span> <span class="n">zero_point_hh</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_pack_padded_sequence</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">lengths</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_pack_padded_sequence(Tensor input, Tensor lengths, bool batch_first) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">input</span><span class="p">))(</span><span class="n">input</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">batch_first</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_pack_padded_sequence_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_pack_padded_sequence_backward(Tensor grad, int[] input_size, Tensor batch_sizes, bool batch_first) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad</span><span class="p">))(</span><span class="n">grad</span><span class="p">,</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="n">batch_first</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_pad_packed_sequence</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">batch_first</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">padding_value</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">total_length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_pad_packed_sequence(Tensor data, Tensor batch_sizes, bool batch_first, Scalar padding_value, int total_length) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">data</span><span class="p">))(</span><span class="n">data</span><span class="p">,</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="n">batch_first</span><span class="p">,</span> <span class="n">padding_value</span><span class="p">,</span> <span class="n">total_length</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">masked_fill</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::masked_fill(Tensor self, Tensor mask, Scalar value) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">masked_fill</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::masked_fill(Tensor self, Tensor mask, Tensor value) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">masked_scatter</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">source</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::masked_scatter(Tensor self, Tensor mask, Tensor source) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">source</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">index_add</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">source</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::index_add(Tensor self, int dim, Tensor index, Tensor source) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">source</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">index_fill</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::index_fill(Tensor self, int dim, Tensor index, Scalar value) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">index_fill</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::index_fill(Tensor self, int dim, Tensor index, Tensor value) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">scatter</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::scatter(Tensor self, int dim, Tensor index, Tensor src) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">scatter</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::scatter(Tensor self, int dim, Tensor index, Scalar value) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">scatter_add</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::scatter_add(Tensor self, int dim, Tensor index, Tensor src) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">__and__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::__and__(Tensor self, Scalar other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">__and__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::__and__(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">__or__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::__or__(Tensor self, Scalar other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">__or__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::__or__(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">__xor__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::__xor__(Tensor self, Scalar other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">__xor__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::__xor__(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">__lshift__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::__lshift__(Tensor self, Scalar other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">__lshift__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::__lshift__(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">__rshift__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::__rshift__(Tensor self, Scalar other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">__rshift__</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::__rshift__(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">addbmm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::addbmm(Tensor self, Tensor batch1, Tensor batch2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">batch1</span><span class="p">,</span> <span class="n">batch2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">addbmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">batch2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::addbmm(Tensor self, Tensor batch1, Tensor batch2, *, Scalar beta=1, Scalar alpha=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">batch1</span><span class="p">,</span> <span class="n">batch2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">diag_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">diagonal</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::diag(Tensor self, int diagonal=0, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">diagonal</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">diag</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">diagonal</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::diag(Tensor self, int diagonal=0) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">diagonal</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cross_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cross(Tensor self, Tensor other, int? dim=None, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cross</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cross(Tensor self, Tensor other, int? dim=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">c10</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">triu_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">diagonal</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::triu(Tensor self, int diagonal=0, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">diagonal</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">triu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">diagonal</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::triu(Tensor self, int diagonal=0) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">diagonal</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tril_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">diagonal</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::tril(Tensor self, int diagonal=0, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">diagonal</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">tril</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">diagonal</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::tril(Tensor self, int diagonal=0) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">diagonal</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">tril_indices</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">col</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::tril_indices(int row, int col, int offset=0, *, ScalarType? dtype=long, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">triu_indices</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">col</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::triu_indices(int row, int col, int offset=0, *, ScalarType? dtype=long, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">trace</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::trace(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ne_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ne(Tensor self, Scalar other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">ne</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ne(Tensor self, Scalar other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ne_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ne(Tensor self, Tensor other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">ne</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ne(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">eq_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::eq(Tensor self, Scalar other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">eq</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::eq(Tensor self, Scalar other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">eq_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::eq(Tensor self, Tensor other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">eq</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::eq(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ge_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ge(Tensor self, Scalar other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">ge</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ge(Tensor self, Scalar other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ge_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ge(Tensor self, Tensor other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">ge</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ge(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">le_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::le(Tensor self, Scalar other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">le</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::le(Tensor self, Scalar other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">le_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::le(Tensor self, Tensor other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">le</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::le(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">gt_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::gt(Tensor self, Scalar other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">gt</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::gt(Tensor self, Scalar other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">gt_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::gt(Tensor self, Tensor other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">gt</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::gt(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">lt_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::lt(Tensor self, Scalar other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">lt</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::lt(Tensor self, Scalar other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">lt_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::lt(Tensor self, Tensor other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">lt</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::lt(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">take_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::take(Tensor self, Tensor index, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">take</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::take(Tensor self, Tensor index) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index_select_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::index_select(Tensor self, int dim, Tensor index, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">index_select</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::index_select(Tensor self, int dim, Tensor index) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">masked_select_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::masked_select(Tensor self, Tensor mask, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">masked_select</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::masked_select(Tensor self, Tensor mask) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">nonzero_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nonzero(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">nonzero</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nonzero(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">nonzero_numpy</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nonzero_numpy(Tensor self) -&gt; Tensor[]&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">gather_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sparse_grad</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::gather(Tensor self, int dim, Tensor index, *, bool sparse_grad=False, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">sparse_grad</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">gather</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sparse_grad</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::gather(Tensor self, int dim, Tensor index, *, bool sparse_grad=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">sparse_grad</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_gather_sparse_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_gather_sparse_backward(Tensor self, int dim, Tensor index, Tensor grad) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">grad</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">addcmul_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::addcmul(Tensor self, Tensor tensor1, Tensor tensor2, *, Scalar value=1, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">tensor1</span><span class="p">,</span> <span class="n">tensor2</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">addcmul</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::addcmul(Tensor self, Tensor tensor1, Tensor tensor2, *, Scalar value=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">tensor1</span><span class="p">,</span> <span class="n">tensor2</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">addcdiv_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::addcdiv(Tensor self, Tensor tensor1, Tensor tensor2, *, Scalar value=1, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">tensor1</span><span class="p">,</span> <span class="n">tensor2</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">addcdiv</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tensor2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::addcdiv(Tensor self, Tensor tensor1, Tensor tensor2, *, Scalar value=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">tensor1</span><span class="p">,</span> <span class="n">tensor2</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">gels_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">X</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">qr</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::gels(Tensor self, Tensor A, *, Tensor(a!) X, Tensor(b!) qr) -&gt; (Tensor(a!) solution, Tensor(b!) QR)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">X</span><span class="p">,</span> <span class="n">qr</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">gels</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::gels(Tensor self, Tensor A) -&gt; (Tensor solution, Tensor QR)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">triangular_solve_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">X</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">M</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transpose</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unitriangular</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::triangular_solve(Tensor self, Tensor A, bool upper=True, bool transpose=False, bool unitriangular=False, *, Tensor(a!) X, Tensor(b!) M) -&gt; (Tensor(a!) solution, Tensor(b!) cloned_coefficient)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">X</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">transpose</span><span class="p">,</span> <span class="n">unitriangular</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">triangular_solve</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transpose</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unitriangular</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::triangular_solve(Tensor self, Tensor A, bool upper=True, bool transpose=False, bool unitriangular=False) -&gt; (Tensor solution, Tensor cloned_coefficient)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">transpose</span><span class="p">,</span> <span class="n">unitriangular</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_triangular_solve_helper</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transpose</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unitriangular</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_triangular_solve_helper(Tensor self, Tensor A, bool upper, bool transpose, bool unitriangular) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">transpose</span><span class="p">,</span> <span class="n">unitriangular</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">symeig_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">e</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">eigenvectors</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::symeig(Tensor self, bool eigenvectors=False, bool upper=True, *, Tensor(a!) e, Tensor(b!) V) -&gt; (Tensor(a!) eigenvalues, Tensor(b!) eigenvectors)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">e</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">eigenvectors</span><span class="p">,</span> <span class="n">upper</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">symeig</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">eigenvectors</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::symeig(Tensor self, bool eigenvectors=False, bool upper=True) -&gt; (Tensor eigenvalues, Tensor eigenvectors)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">eigenvectors</span><span class="p">,</span> <span class="n">upper</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_symeig_helper</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">eigenvectors</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_symeig_helper(Tensor self, bool eigenvectors, bool upper) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">eigenvectors</span><span class="p">,</span> <span class="n">upper</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">eig_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">e</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">eigenvectors</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::eig(Tensor self, bool eigenvectors=False, *, Tensor(a!) e, Tensor(b!) v) -&gt; (Tensor(a!) eigenvalues, Tensor(b!) eigenvectors)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">e</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">eigenvectors</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">eig</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">eigenvectors</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::eig(Tensor self, bool eigenvectors=False) -&gt; (Tensor eigenvalues, Tensor eigenvectors)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">eigenvectors</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">svd_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">U</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">S</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">some</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">compute_uv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::svd(Tensor self, bool some=True, bool compute_uv=True, *, Tensor(a!) U, Tensor(b!) S, Tensor(c!) V) -&gt; (Tensor(a!) U, Tensor(b!) S, Tensor(c!) V)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">some</span><span class="p">,</span> <span class="n">compute_uv</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">svd</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">some</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">compute_uv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::svd(Tensor self, bool some=True, bool compute_uv=True) -&gt; (Tensor U, Tensor S, Tensor V)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">some</span><span class="p">,</span> <span class="n">compute_uv</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cholesky_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cholesky(Tensor self, bool upper=False, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">upper</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cholesky</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cholesky(Tensor self, bool upper=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">upper</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_cholesky_helper</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cholesky_helper(Tensor self, bool upper) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">upper</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cholesky_solve_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cholesky_solve(Tensor self, Tensor input2, bool upper=False, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">input2</span><span class="p">,</span> <span class="n">upper</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cholesky_solve</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cholesky_solve(Tensor self, Tensor input2, bool upper=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">input2</span><span class="p">,</span> <span class="n">upper</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_cholesky_solve_helper</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cholesky_solve_helper(Tensor self, Tensor A, bool upper) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">upper</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">solve</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::solve(Tensor self, Tensor A) -&gt; (Tensor solution, Tensor LU)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">solve_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">solution</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">lu</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::solve(Tensor self, Tensor A, *, Tensor(a!) solution, Tensor(b!) lu) -&gt; (Tensor(a!) solution, Tensor(b!) LU)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">solution</span><span class="p">,</span> <span class="n">lu</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_solve_helper</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_solve_helper(Tensor self, Tensor A) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">cholesky_inverse_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cholesky_inverse(Tensor self, bool upper=False, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">upper</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">cholesky_inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::cholesky_inverse(Tensor self, bool upper=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">upper</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">pstrf_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">u</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">pivot</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">tol</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::pstrf(Tensor self, bool upper=True, Scalar tol=-1, *, Tensor(a!) u, Tensor(b!) pivot) -&gt; (Tensor(a!) u, Tensor(b!) pivot)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">u</span><span class="p">,</span> <span class="n">pivot</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">tol</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">pstrf</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upper</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">tol</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::pstrf(Tensor self, bool upper=True, Scalar tol=-1) -&gt; (Tensor u, Tensor pivot)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">tol</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">qr_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">Q</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">R</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">some</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::qr(Tensor self, bool some=True, *, Tensor(a!) Q, Tensor(b!) R) -&gt; (Tensor(a!) Q, Tensor(b!) R)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">some</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">qr</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">some</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::qr(Tensor self, bool some=True) -&gt; (Tensor Q, Tensor R)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">some</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_qr_helper</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">some</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_qr_helper(Tensor self, bool some) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">some</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">geqrf_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tau</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::geqrf(Tensor self, *, Tensor(a!) a, Tensor(b!) tau) -&gt; (Tensor(a!) a, Tensor(b!) tau)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">a</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">geqrf</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::geqrf(Tensor self) -&gt; (Tensor a, Tensor tau)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">orgqr_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::orgqr(Tensor self, Tensor input2, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">input2</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">orgqr</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::orgqr(Tensor self, Tensor input2) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">input2</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ormqr_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input3</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">left</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transpose</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ormqr(Tensor self, Tensor input2, Tensor input3, bool left=True, bool transpose=False, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">input2</span><span class="p">,</span> <span class="n">input3</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">transpose</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">ormqr</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input2</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">input3</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">left</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transpose</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::ormqr(Tensor self, Tensor input2, Tensor input3, bool left=True, bool transpose=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">input2</span><span class="p">,</span> <span class="n">input3</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">transpose</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_lu_with_info</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">pivot</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">check_errors</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_lu_with_info(Tensor self, bool pivot=True, bool check_errors=True) -&gt; (Tensor, Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">pivot</span><span class="p">,</span> <span class="n">check_errors</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">lu_solve_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">LU_data</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">LU_pivots</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::lu_solve(Tensor self, Tensor LU_data, Tensor LU_pivots, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">LU_data</span><span class="p">,</span> <span class="n">LU_pivots</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">lu_solve</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">LU_data</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">LU_pivots</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::lu_solve(Tensor self, Tensor LU_data, Tensor LU_pivots) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">LU_data</span><span class="p">,</span> <span class="n">LU_pivots</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">multinomial_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_samples</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">replacement</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::multinomial(Tensor self, int num_samples, bool replacement=False, *, Generator? generator=None, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">replacement</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">multinomial</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_samples</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">replacement</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::multinomial(Tensor self, int num_samples, bool replacement=False, *, Generator? generator=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">replacement</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_multinomial_alias_setup</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">probs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_multinomial_alias_setup(Tensor probs) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">probs</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">probs</span><span class="p">))(</span><span class="n">probs</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_multinomial_alias_draw</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">J</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">q</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_multinomial_alias_draw(Tensor J, Tensor q, int num_samples, *, Generator? generator=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">J</span><span class="p">))(</span><span class="n">J</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">lgamma_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::lgamma(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">lgamma</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::lgamma(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">digamma_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::digamma(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">digamma</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::digamma(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">polygamma_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::polygamma(int n, Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">polygamma</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::polygamma(int n, Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">n</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">erfinv_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::erfinv(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">erfinv</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::erfinv(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">dist</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::dist(Tensor self, Tensor other, Scalar p=2) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">atan2_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::atan2(Tensor self, Tensor other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">atan2</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::atan2(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">lerp_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">end</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::lerp(Tensor self, Tensor end, Scalar weight, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">lerp_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">end</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::lerp(Tensor self, Tensor end, Tensor weight, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">lerp</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">end</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::lerp(Tensor self, Tensor end, Scalar weight) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">lerp</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">end</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::lerp(Tensor self, Tensor end, Tensor weight) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">histc_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">bins</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::histc(Tensor self, int bins=100, Scalar min=0, Scalar max=0, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">histc</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">bins</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::histc(Tensor self, int bins=100, Scalar min=0, Scalar max=0) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sign_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sign(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">sign</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sign(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fmod_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fmod(Tensor self, Scalar other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">fmod</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fmod(Tensor self, Scalar other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fmod_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fmod(Tensor self, Tensor other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">fmod</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fmod(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">remainder_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::remainder(Tensor self, Scalar other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">remainder</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::remainder(Tensor self, Scalar other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">remainder_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::remainder(Tensor self, Tensor other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">remainder</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::remainder(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">min_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::min(Tensor self, Tensor other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">min</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::min(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">min</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::min(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max(Tensor self, Tensor other, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">max</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max(Tensor self, Tensor other) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">max</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">median</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::median(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">sort_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">descending</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sort(Tensor self, int dim=-1, bool descending=False, *, Tensor(a!) values, Tensor(b!) indices) -&gt; (Tensor(a!) values, Tensor(b!) indices)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">values</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">descending</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">sort</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">descending</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sort(Tensor self, int dim=-1, bool descending=False) -&gt; (Tensor values, Tensor indices)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">descending</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">argsort</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">descending</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::argsort(Tensor self, int dim=-1, bool descending=False) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">descending</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">topk_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">largest</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sorted</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::topk(Tensor self, int k, int dim=-1, bool largest=True, bool sorted=True, *, Tensor(a!) values, Tensor(b!) indices) -&gt;(Tensor(a!) values, Tensor(b!) indices)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">values</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">largest</span><span class="p">,</span> <span class="n">sorted</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">topk</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">largest</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sorted</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::topk(Tensor self, int k, int dim=-1, bool largest=True, bool sorted=True) -&gt; (Tensor values, Tensor indices)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">largest</span><span class="p">,</span> <span class="n">sorted</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">all</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::all(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">any</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::any(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">renorm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">maxnorm</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::renorm(Tensor self, Scalar p, int dim, Scalar maxnorm, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">maxnorm</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">renorm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">maxnorm</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::renorm(Tensor self, Scalar p, int dim, Scalar maxnorm) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">maxnorm</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">equal</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::equal(Tensor self, Tensor other) -&gt; bool&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">pow_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">exponent</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::pow(Tensor self, Tensor exponent, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">exponent</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">pow</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">exponent</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::pow(Tensor self, Tensor exponent) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">exponent</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">pow_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">exponent</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::pow(Scalar self, Tensor exponent, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">exponent</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">pow</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">exponent</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::pow(Scalar self, Tensor exponent) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">exponent</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">exponent</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">exponent</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">normal_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="kt">double</span> <span class="n">std</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::normal(Tensor mean, float std=1, *, Generator? generator=None, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">normal</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="kt">double</span> <span class="n">std</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::normal(Tensor mean, float std=1, *, Generator? generator=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">mean</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">mean</span><span class="p">))(</span><span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">normal_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">double</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">std</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::normal(float mean, Tensor std, *, Generator? generator=None, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">normal</span><span class="p">(</span><span class="kt">double</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">std</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::normal(float mean, Tensor std, *, Generator? generator=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">std</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">std</span><span class="p">))(</span><span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">normal_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">std</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::normal(Tensor mean, Tensor std, *, Generator? generator=None, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">normal</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mean</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">std</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::normal(Tensor mean, Tensor std, *, Generator? generator=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">mean</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">mean</span><span class="p">))(</span><span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">normal</span><span class="p">(</span><span class="kt">double</span> <span class="n">mean</span><span class="p">,</span> <span class="kt">double</span> <span class="n">std</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">globalLegacyTypeDispatch</span><span class="p">().</span><span class="n">initForBackend</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">());</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::normal(float mean, float std, int[] size, *, Generator? generator=None, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">TensorOptions</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">backend</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">is_variable</span><span class="p">())(</span><span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">normal_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">double</span> <span class="n">mean</span><span class="p">,</span> <span class="kt">double</span> <span class="n">std</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">size</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::normal(float mean, float std, int[] size, *, Generator? generator=None, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">alias</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::alias(Tensor(a) self) -&gt; Tensor(a)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_addr</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_addr(Tensor self, Tensor vec1, Tensor vec2, *, Scalar beta=1, Scalar alpha=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_addr_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_addr_(Tensor(a!) self, Tensor vec1, Tensor vec2, *, Scalar beta=1, Scalar alpha=1) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_addr_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_addr(Tensor self, Tensor vec1, Tensor vec2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_index_copy_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">source</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_index_copy_(Tensor(a!) self, int dim, Tensor index, Tensor source) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">source</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_cumsum</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cumsum(Tensor self, int dim) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_cumsum_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cumsum(Tensor self, int dim, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_cumprod</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cumprod(Tensor self, int dim) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_cumprod_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cumprod(Tensor self, int dim, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_var</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_var(Tensor self, bool unbiased=True) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">unbiased</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_std</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">unbiased</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_std(Tensor self, bool unbiased=True) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">unbiased</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_addmm_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_addmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_addmm</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_addmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_addmm_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_addmm_(Tensor(a!) self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_cat</span><span class="p">(</span><span class="n">TensorList</span> <span class="n">tensors</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cat(Tensor[] tensors, int dim=0) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="n">TensorList</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">tensors</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">tensors</span><span class="p">))(</span><span class="n">tensors</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">_cat_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">TensorList</span> <span class="n">tensors</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_cat(Tensor[] tensors, int dim=0, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TensorList</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">out</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">tensors</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_mode</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_mode(Tensor self, int dim=-1, bool keepdim=False) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">_mode_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_mode(Tensor self, int dim=-1, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -&gt; (Tensor(a!), Tensor(b!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">values</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_max</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_max(Tensor self, int dim, bool keepdim=False) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">_max_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_max(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) max, Tensor(b!) max_indices) -&gt; (Tensor(a!), Tensor(b!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">max</span><span class="p">,</span> <span class="n">max_indices</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">_min</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_min(Tensor self, int dim, bool keepdim=False) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">_min_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">min_indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keepdim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_min(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) min, Tensor(b!) min_indices) -&gt; (Tensor(a!), Tensor(b!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">min</span><span class="p">,</span> <span class="n">min_indices</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">keepdim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">binary_cross_entropy_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::binary_cross_entropy(Tensor self, Tensor target, Tensor? weight=None, int reduction=Mean, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">binary_cross_entropy</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::binary_cross_entropy(Tensor self, Tensor target, Tensor? weight=None, int reduction=Mean) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">binary_cross_entropy_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::binary_cross_entropy_backward(Tensor grad_output, Tensor self, Tensor target, Tensor? weight=None, int reduction=Mean, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">binary_cross_entropy_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::binary_cross_entropy_backward(Tensor grad_output, Tensor self, Tensor target, Tensor? weight=None, int reduction=Mean) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mse_loss_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mse_loss(Tensor self, Tensor target, int reduction=Mean, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">mse_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mse_loss(Tensor self, Tensor target, int reduction=Mean) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">mse_loss_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mse_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">mse_loss_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mse_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">l1_loss_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::l1_loss(Tensor self, Tensor target, int reduction=Mean, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">l1_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::l1_loss(Tensor self, Tensor target, int reduction=Mean) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">l1_loss_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::l1_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">l1_loss_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::l1_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">multi_margin_loss_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">margin</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::multi_margin_loss(Tensor self, Tensor target, Scalar p=1, Scalar margin=1, Tensor? weight=None, int reduction=Mean, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">margin</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">multi_margin_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">margin</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::multi_margin_loss(Tensor self, Tensor target, Scalar p=1, Scalar margin=1, Tensor? weight=None, int reduction=Mean) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">margin</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">multi_margin_loss_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">margin</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::multi_margin_loss_backward(Tensor grad_output, Tensor self, Tensor target, Scalar p, Scalar margin, Tensor? weight=None, int reduction=Mean, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">margin</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">multi_margin_loss_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">p</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">margin</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::multi_margin_loss_backward(Tensor grad_output, Tensor self, Tensor target, Scalar p, Scalar margin, Tensor? weight=None, int reduction=Mean) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">margin</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">multilabel_margin_loss_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::multilabel_margin_loss(Tensor self, Tensor target, int reduction=Mean, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">multilabel_margin_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::multilabel_margin_loss(Tensor self, Tensor target, int reduction=Mean) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">multilabel_margin_loss_forward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">is_target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::multilabel_margin_loss_forward(Tensor self, Tensor target, int reduction, *, Tensor(a!) output, Tensor(b!) is_target) -&gt; (Tensor(a!), Tensor(b!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">output</span><span class="p">,</span> <span class="n">is_target</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">multilabel_margin_loss_forward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::multilabel_margin_loss_forward(Tensor self, Tensor target, int reduction) -&gt; (Tensor output, Tensor is_target)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">multilabel_margin_loss_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">is_target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::multilabel_margin_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction, Tensor is_target, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">is_target</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">multilabel_margin_loss_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">is_target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::multilabel_margin_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction, Tensor is_target) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">is_target</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">nll_loss_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nll_loss(Tensor self, Tensor target, Tensor? weight=None, int reduction=Mean, int ignore_index=-100, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">ignore_index</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">nll_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nll_loss(Tensor self, Tensor target, Tensor? weight=None, int reduction=Mean, int ignore_index=-100) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">ignore_index</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">nll_loss_forward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">total_weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nll_loss_forward(Tensor self, Tensor target, Tensor? weight, int reduction, int ignore_index, *, Tensor(a!) output, Tensor(b!) total_weight) -&gt; (Tensor(a!), Tensor(b!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">output</span><span class="p">,</span> <span class="n">total_weight</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">ignore_index</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">nll_loss_forward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nll_loss_forward(Tensor self, Tensor target, Tensor? weight, int reduction, int ignore_index) -&gt; (Tensor output, Tensor total_weight)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">ignore_index</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">nll_loss_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">total_weight</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nll_loss_backward(Tensor grad_output, Tensor self, Tensor target, Tensor? weight, int reduction, int ignore_index, Tensor total_weight, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">ignore_index</span><span class="p">,</span> <span class="n">total_weight</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">nll_loss_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">total_weight</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nll_loss_backward(Tensor grad_output, Tensor self, Tensor target, Tensor? weight, int reduction, int ignore_index, Tensor total_weight) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">ignore_index</span><span class="p">,</span> <span class="n">total_weight</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">nll_loss2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nll_loss2d(Tensor self, Tensor target, Tensor? weight=None, int reduction=Mean, int ignore_index=-100, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">ignore_index</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">nll_loss2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nll_loss2d(Tensor self, Tensor target, Tensor? weight=None, int reduction=Mean, int ignore_index=-100) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">ignore_index</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">nll_loss2d_forward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">total_weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nll_loss2d_forward(Tensor self, Tensor target, Tensor? weight, int reduction, int ignore_index, *, Tensor(a!) output, Tensor(b!) total_weight) -&gt; (Tensor(a!), Tensor(b!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">output</span><span class="p">,</span> <span class="n">total_weight</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">ignore_index</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">nll_loss2d_forward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nll_loss2d_forward(Tensor self, Tensor target, Tensor? weight, int reduction, int ignore_index) -&gt; (Tensor output, Tensor total_weight)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">ignore_index</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">nll_loss2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">total_weight</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nll_loss2d_backward(Tensor grad_output, Tensor self, Tensor target, Tensor? weight, int reduction, int ignore_index, Tensor total_weight, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">ignore_index</span><span class="p">,</span> <span class="n">total_weight</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">nll_loss2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ignore_index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">total_weight</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::nll_loss2d_backward(Tensor grad_output, Tensor self, Tensor target, Tensor? weight, int reduction, int ignore_index, Tensor total_weight) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">ignore_index</span><span class="p">,</span> <span class="n">total_weight</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">smooth_l1_loss_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::smooth_l1_loss(Tensor self, Tensor target, int reduction=Mean, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">smooth_l1_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::smooth_l1_loss(Tensor self, Tensor target, int reduction=Mean) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">smooth_l1_loss_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::smooth_l1_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">smooth_l1_loss_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::smooth_l1_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">soft_margin_loss_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::soft_margin_loss(Tensor self, Tensor target, int reduction=Mean, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">soft_margin_loss</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::soft_margin_loss(Tensor self, Tensor target, int reduction=Mean) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">soft_margin_loss_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::soft_margin_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">soft_margin_loss_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">reduction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::soft_margin_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">elu_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">input_scale</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::elu(Tensor self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">input_scale</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">elu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">input_scale</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::elu(Tensor self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">input_scale</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">elu_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">input_scale</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::elu_backward(Tensor grad_output, Scalar alpha, Scalar scale, Scalar input_scale, Tensor output, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_input</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">input_scale</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">elu_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">input_scale</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::elu_backward(Tensor grad_output, Scalar alpha, Scalar scale, Scalar input_scale, Tensor output) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">input_scale</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">elu_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">scale</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">input_scale</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::elu_(Tensor(a!) self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">input_scale</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">glu_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::glu(Tensor self, int dim=-1, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">glu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::glu(Tensor self, int dim=-1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">glu_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::glu_backward(Tensor grad_output, Tensor self, int dim, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">glu_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::glu_backward(Tensor grad_output, Tensor self, int dim) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">int64_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hardtanh_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max_val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::hardtanh(Tensor self, Scalar min_val=-1, Scalar max_val=1, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">hardtanh</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max_val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::hardtanh(Tensor self, Scalar min_val=-1, Scalar max_val=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hardtanh_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max_val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::hardtanh_backward(Tensor grad_output, Tensor self, Scalar min_val, Scalar max_val, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">hardtanh_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max_val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::hardtanh_backward(Tensor grad_output, Tensor self, Scalar min_val, Scalar max_val) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">hardtanh_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">max_val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::hardtanh_(Tensor(a!) self, Scalar min_val=-1, Scalar max_val=1) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">leaky_relu_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">negative_slope</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::leaky_relu(Tensor self, Scalar negative_slope=0.01, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">negative_slope</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">leaky_relu</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">negative_slope</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::leaky_relu(Tensor self, Scalar negative_slope=0.01) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">negative_slope</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">leaky_relu_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">negative_slope</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::leaky_relu_backward(Tensor grad_output, Tensor self, Scalar negative_slope, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">negative_slope</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">leaky_relu_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">negative_slope</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::leaky_relu_backward(Tensor grad_output, Tensor self, Scalar negative_slope) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">negative_slope</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">leaky_relu_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">negative_slope</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::leaky_relu_(Tensor(a!) self, Scalar negative_slope=0.01) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">negative_slope</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_sigmoid_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log_sigmoid(Tensor self, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">log_sigmoid</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log_sigmoid(Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">log_sigmoid_forward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log_sigmoid_forward(Tensor self, *, Tensor(a!) output, Tensor(b!) buffer) -&gt; (Tensor(a!), Tensor(b!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">output</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">log_sigmoid_forward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log_sigmoid_forward(Tensor self) -&gt; (Tensor output, Tensor buffer)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">log_sigmoid_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log_sigmoid_backward(Tensor grad_output, Tensor self, Tensor buffer, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">log_sigmoid_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::log_sigmoid_backward(Tensor grad_output, Tensor self, Tensor buffer) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rrelu_with_noise_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">noise</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lower</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">upper</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rrelu_with_noise(Tensor self, Tensor noise, Scalar lower=0.125, Scalar upper=0.3333333333333333, bool training=False, Generator? generator=None, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">training</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">rrelu_with_noise</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">noise</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lower</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">upper</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rrelu_with_noise(Tensor self, Tensor noise, Scalar lower=0.125, Scalar upper=0.3333333333333333, bool training=False, Generator? generator=None) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">training</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rrelu_with_noise_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">noise</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lower</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">upper</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rrelu_with_noise_backward(Tensor grad_output, Tensor self, Tensor noise, Scalar lower, Scalar upper, bool training, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">training</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">rrelu_with_noise_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">noise</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lower</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">upper</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rrelu_with_noise_backward(Tensor grad_output, Tensor self, Tensor noise, Scalar lower, Scalar upper, bool training) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">training</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">rrelu_with_noise_</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">noise</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lower</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">upper</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">training</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::rrelu_with_noise_(Tensor(a!) self, Tensor noise, Scalar lower=0.125, Scalar upper=0.3333333333333333, bool training=False, Generator? generator=None) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">Generator</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">training</span><span class="p">,</span> <span class="n">generator</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">softplus_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">threshold</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::softplus(Tensor self, Scalar beta=1, Scalar threshold=20, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">threshold</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">softplus</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">threshold</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::softplus(Tensor self, Scalar beta=1, Scalar threshold=20) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">threshold</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">softplus_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">threshold</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::softplus_backward(Tensor grad_output, Tensor self, Scalar beta, Scalar threshold, Tensor output, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">softplus_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">threshold</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::softplus_backward(Tensor grad_output, Tensor self, Scalar beta, Scalar threshold, Tensor output) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">softshrink_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lambd</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::softshrink(Tensor self, Scalar lambd=0.5, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">lambd</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">softshrink</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lambd</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::softshrink(Tensor self, Scalar lambd=0.5) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">lambd</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">softshrink_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lambd</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::softshrink_backward(Tensor grad_output, Tensor self, Scalar lambd, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">lambd</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">softshrink_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">lambd</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::softshrink_backward(Tensor grad_output, Tensor self, Scalar lambd) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">lambd</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">adaptive_avg_pool2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::adaptive_avg_pool2d(Tensor self, int[2] output_size, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">adaptive_avg_pool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::adaptive_avg_pool2d(Tensor self, int[2] output_size) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">mkldnn_adaptive_avg_pool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::mkldnn_adaptive_avg_pool2d(Tensor self, int[2] output_size) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_adaptive_avg_pool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_adaptive_avg_pool2d(Tensor self, int[2] output_size) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">_adaptive_avg_pool2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::_adaptive_avg_pool2d_backward(Tensor grad_output, Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">adaptive_avg_pool3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::adaptive_avg_pool3d(Tensor self, int[3] output_size, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">adaptive_avg_pool3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::adaptive_avg_pool3d(Tensor self, int[3] output_size) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">adaptive_avg_pool3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::adaptive_avg_pool3d_backward(Tensor grad_output, Tensor self, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">adaptive_avg_pool3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::adaptive_avg_pool3d_backward(Tensor grad_output, Tensor self) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">adaptive_max_pool2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::adaptive_max_pool2d(Tensor self, int[2] output_size, *, Tensor(a!) out, Tensor(b!) indices) -&gt; (Tensor(a!), Tensor(b!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">adaptive_max_pool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::adaptive_max_pool2d(Tensor self, int[2] output_size) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">adaptive_max_pool2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::adaptive_max_pool2d_backward(Tensor grad_output, Tensor self, Tensor indices, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">adaptive_max_pool2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::adaptive_max_pool2d_backward(Tensor grad_output, Tensor self, Tensor indices) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">adaptive_max_pool3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::adaptive_max_pool3d(Tensor self, int[3] output_size, *, Tensor(a!) out, Tensor(b!) indices) -&gt; (Tensor(a!), Tensor(b!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">adaptive_max_pool3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::adaptive_max_pool3d(Tensor self, int[3] output_size) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">adaptive_max_pool3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::adaptive_max_pool3d_backward(Tensor grad_output, Tensor self, Tensor indices, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">adaptive_max_pool3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::adaptive_max_pool3d_backward(Tensor grad_output, Tensor self, Tensor indices) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">avg_pool2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::avg_pool2d(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, bool ceil_mode=False, bool count_include_pad=True, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="n">count_include_pad</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">avg_pool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::avg_pool2d(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, bool ceil_mode=False, bool count_include_pad=True) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="n">count_include_pad</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">avg_pool2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::avg_pool2d_backward(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride, int[2] padding, bool ceil_mode, bool count_include_pad, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="n">count_include_pad</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">avg_pool2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::avg_pool2d_backward(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride, int[2] padding, bool ceil_mode, bool count_include_pad) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="n">count_include_pad</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">avg_pool3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::avg_pool3d(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, bool ceil_mode=False, bool count_include_pad=True, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="n">count_include_pad</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">avg_pool3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::avg_pool3d(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, bool ceil_mode=False, bool count_include_pad=True) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="n">count_include_pad</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">avg_pool3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::avg_pool3d_backward(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] stride, int[3] padding, bool ceil_mode, bool count_include_pad, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="n">count_include_pad</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">avg_pool3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">count_include_pad</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::avg_pool3d_backward(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] stride, int[3] padding, bool ceil_mode, bool count_include_pad) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="n">count_include_pad</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">fractional_max_pool2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">random_samples</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fractional_max_pool2d(Tensor self, int[2] kernel_size, int[2] output_size, Tensor random_samples, *, Tensor(a!) output, Tensor(b!) indices) -&gt; (Tensor(a!), Tensor(b!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">output</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">random_samples</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">fractional_max_pool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">random_samples</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fractional_max_pool2d(Tensor self, int[2] kernel_size, int[2] output_size, Tensor random_samples) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">random_samples</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fractional_max_pool2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fractional_max_pool2d_backward(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] output_size, Tensor indices, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">fractional_max_pool2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fractional_max_pool2d_backward(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] output_size, Tensor indices) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">fractional_max_pool3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">random_samples</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fractional_max_pool3d(Tensor self, int[3] kernel_size, int[3] output_size, Tensor random_samples, *, Tensor(a!) output, Tensor(b!) indices) -&gt; (Tensor(a!), Tensor(b!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">output</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">random_samples</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">fractional_max_pool3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">random_samples</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fractional_max_pool3d(Tensor self, int[3] kernel_size, int[3] output_size, Tensor random_samples) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">random_samples</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fractional_max_pool3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fractional_max_pool3d_backward(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] output_size, Tensor indices, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">fractional_max_pool3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::fractional_max_pool3d_backward(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] output_size, Tensor indices) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">max_pool2d_with_indices_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_pool2d_with_indices(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False, *, Tensor(a!) out, Tensor(b!) indices) -&gt; (Tensor(a!), Tensor(b!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">max_pool2d_with_indices</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_pool2d_with_indices(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_pool2d_with_indices_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_pool2d_with_indices_backward(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride, int[2] padding, int[2] dilation, bool ceil_mode, Tensor indices, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">max_pool2d_with_indices_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_pool2d_with_indices_backward(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride, int[2] padding, int[2] dilation, bool ceil_mode, Tensor indices) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">max_pool3d_with_indices_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_pool3d_with_indices(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False, *, Tensor(a!) out, Tensor(b!) indices) -&gt; (Tensor(a!), Tensor(b!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">max_pool3d_with_indices</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_pool3d_with_indices(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False) -&gt; (Tensor, Tensor)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_pool3d_with_indices_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_pool3d_with_indices_backward(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] stride, int[3] padding, int[3] dilation, bool ceil_mode, Tensor indices, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">max_pool3d_with_indices_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_pool3d_with_indices_backward(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] stride, int[3] padding, int[3] dilation, bool ceil_mode, Tensor indices) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_unpool2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_unpool2d(Tensor self, Tensor indices, int[2] output_size, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">max_unpool2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_unpool2d(Tensor self, Tensor indices, int[2] output_size) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_unpool2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_unpool2d_backward(Tensor grad_output, Tensor self, Tensor indices, int[2] output_size, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">max_unpool2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_unpool2d_backward(Tensor grad_output, Tensor self, Tensor indices, int[2] output_size) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_unpool3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_unpool3d(Tensor self, Tensor indices, int[3] output_size, int[3] stride, int[3] padding, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">max_unpool3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_unpool3d(Tensor self, Tensor indices, int[3] output_size, int[3] stride, int[3] padding) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">max_unpool3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_unpool3d_backward(Tensor grad_output, Tensor self, Tensor indices, int[3] output_size, int[3] stride, int[3] padding, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">max_unpool3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::max_unpool3d_backward(Tensor grad_output, Tensor self, Tensor indices, int[3] output_size, int[3] stride, int[3] padding) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">reflection_pad1d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::reflection_pad1d(Tensor self, int[2] padding, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">reflection_pad1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::reflection_pad1d(Tensor self, int[2] padding) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">reflection_pad1d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::reflection_pad1d_backward(Tensor grad_output, Tensor self, int[2] padding, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">reflection_pad1d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::reflection_pad1d_backward(Tensor grad_output, Tensor self, int[2] padding) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">reflection_pad2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::reflection_pad2d(Tensor self, int[4] padding, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">reflection_pad2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::reflection_pad2d(Tensor self, int[4] padding) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">reflection_pad2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::reflection_pad2d_backward(Tensor grad_output, Tensor self, int[4] padding, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">reflection_pad2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::reflection_pad2d_backward(Tensor grad_output, Tensor self, int[4] padding) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">replication_pad1d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::replication_pad1d(Tensor self, int[2] padding, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">replication_pad1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::replication_pad1d(Tensor self, int[2] padding) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">replication_pad1d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::replication_pad1d_backward(Tensor grad_output, Tensor self, int[2] padding, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">replication_pad1d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::replication_pad1d_backward(Tensor grad_output, Tensor self, int[2] padding) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">replication_pad2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::replication_pad2d(Tensor self, int[4] padding, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">replication_pad2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::replication_pad2d(Tensor self, int[4] padding) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">replication_pad2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::replication_pad2d_backward(Tensor grad_output, Tensor self, int[4] padding, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">replication_pad2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::replication_pad2d_backward(Tensor grad_output, Tensor self, int[4] padding) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">replication_pad3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::replication_pad3d(Tensor self, int[6] padding, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">replication_pad3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::replication_pad3d(Tensor self, int[6] padding) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">replication_pad3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::replication_pad3d_backward(Tensor grad_output, Tensor self, int[6] padding, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">replication_pad3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::replication_pad3d_backward(Tensor grad_output, Tensor self, int[6] padding) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_linear1d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_linear1d(Tensor self, int[1] output_size, bool align_corners, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">upsample_linear1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_linear1d(Tensor self, int[1] output_size, bool align_corners) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_linear1d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_linear1d_backward(Tensor grad_output, int[1] output_size, int[3] input_size, bool align_corners, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_input</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">upsample_linear1d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_linear1d_backward(Tensor grad_output, int[1] output_size, int[3] input_size, bool align_corners) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_bilinear2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_bilinear2d(Tensor self, int[2] output_size, bool align_corners, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">upsample_bilinear2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_bilinear2d(Tensor self, int[2] output_size, bool align_corners) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_bilinear2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_bilinear2d_backward(Tensor grad_output, int[2] output_size, int[4] input_size, bool align_corners, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_input</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">upsample_bilinear2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_bilinear2d_backward(Tensor grad_output, int[2] output_size, int[4] input_size, bool align_corners) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_bicubic2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_bicubic2d(Tensor self, int[2] output_size, bool align_corners, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">upsample_bicubic2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_bicubic2d(Tensor self, int[2] output_size, bool align_corners) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_bicubic2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_bicubic2d_backward(Tensor grad_output, int[2] output_size, int[4] input_size, bool align_corners, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_input</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">upsample_bicubic2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_bicubic2d_backward(Tensor grad_output, int[2] output_size, int[4] input_size, bool align_corners) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_trilinear3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_trilinear3d(Tensor self, int[3] output_size, bool align_corners, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">upsample_trilinear3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_trilinear3d(Tensor self, int[3] output_size, bool align_corners) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_trilinear3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_trilinear3d_backward(Tensor grad_output, int[3] output_size, int[5] input_size, bool align_corners, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_input</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">upsample_trilinear3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">align_corners</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_trilinear3d_backward(Tensor grad_output, int[3] output_size, int[5] input_size, bool align_corners) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_nearest1d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_nearest1d(Tensor self, int[1] output_size, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">upsample_nearest1d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_nearest1d(Tensor self, int[1] output_size) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_nearest1d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_nearest1d_backward(Tensor grad_output, int[1] output_size, int[3] input_size, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_input</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">input_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">upsample_nearest1d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_nearest1d_backward(Tensor grad_output, int[1] output_size, int[3] input_size) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">input_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_nearest2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_nearest2d(Tensor self, int[2] output_size, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">upsample_nearest2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_nearest2d(Tensor self, int[2] output_size) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_nearest2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_nearest2d_backward(Tensor grad_output, int[2] output_size, int[4] input_size, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_input</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">input_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">upsample_nearest2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_nearest2d_backward(Tensor grad_output, int[2] output_size, int[4] input_size) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">input_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_nearest3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_nearest3d(Tensor self, int[3] output_size, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">upsample_nearest3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_nearest3d(Tensor self, int[3] output_size) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">upsample_nearest3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_nearest3d_backward(Tensor grad_output, int[3] output_size, int[5] input_size, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_input</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">input_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">upsample_nearest3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::upsample_nearest3d_backward(Tensor grad_output, int[3] output_size, int[5] input_size) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">input_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">sigmoid_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sigmoid_backward(Tensor grad_output, Tensor output, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_input</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">sigmoid_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::sigmoid_backward(Tensor grad_output, Tensor output) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">tanh_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::tanh_backward(Tensor grad_output, Tensor output, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_input</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">tanh_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::tanh_backward(Tensor grad_output, Tensor output) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">conv_transpose2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv_transpose2d(Tensor self, Tensor weight, int[2] kernel_size, Tensor? bias=None, int[2] stride=1, int[2] padding=0, int[2] output_padding=0, int[2] dilation=1, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">conv_transpose2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv_transpose2d(Tensor self, Tensor weight, int[2] kernel_size, Tensor? bias=None, int[2] stride=1, int[2] padding=0, int[2] output_padding=0, int[2] dilation=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">conv_transpose2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_weight</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">columns</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ones</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv_transpose2d_backward(Tensor grad_output, Tensor self, Tensor weight, int[2] kernel_size, int[2] stride, int[2] padding, int[2] output_padding, int[2] dilation, Tensor columns, Tensor ones, *, Tensor?(a!) grad_input, Tensor?(b!) grad_weight, Tensor?(c!) grad_bias) -&gt; (Tensor(a!), Tensor(b!), Tensor(c!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_weight</span><span class="p">,</span> <span class="n">grad_bias</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">ones</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">conv_transpose2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">columns</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">ones</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv_transpose2d_backward(Tensor grad_output, Tensor self, Tensor weight, int[2] kernel_size, int[2] stride, int[2] padding, int[2] output_padding, int[2] dilation, Tensor columns, Tensor ones, bool[3] output_mask) -&gt; (Tensor grad_input, Tensor grad_weight, Tensor grad_bias)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">ones</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">conv_transpose3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv_transpose3d(Tensor self, Tensor weight, int[3] kernel_size, Tensor? bias=None, int[3] stride=1, int[3] padding=0, int[3] output_padding=0, int[3] dilation=1, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">conv_transpose3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv_transpose3d(Tensor self, Tensor weight, int[3] kernel_size, Tensor? bias=None, int[3] stride=1, int[3] padding=0, int[3] output_padding=0, int[3] dilation=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">conv_transpose3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_weight</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">finput</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fgrad_input</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv_transpose3d_backward(Tensor grad_output, Tensor self, Tensor weight, int[3] kernel_size, int[3] stride, int[3] padding, int[3] output_padding, int[3] dilation, Tensor finput, Tensor fgrad_input, *, Tensor?(a!) grad_input, Tensor?(b!) grad_weight, Tensor?(c!) grad_bias) -&gt; (Tensor(a!), Tensor(b!), Tensor(c!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_weight</span><span class="p">,</span> <span class="n">grad_bias</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">finput</span><span class="p">,</span> <span class="n">fgrad_input</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">conv_transpose3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">finput</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fgrad_input</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv_transpose3d_backward(Tensor grad_output, Tensor self, Tensor weight, int[3] kernel_size, int[3] stride, int[3] padding, int[3] output_padding, int[3] dilation, Tensor finput, Tensor fgrad_input, bool[3] output_mask) -&gt; (Tensor grad_input, Tensor grad_weight, Tensor grad_bias)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">output_padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">finput</span><span class="p">,</span> <span class="n">fgrad_input</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">thnn_conv2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv2d(Tensor self, Tensor weight, int[2] kernel_size, Tensor? bias=None, int[2] stride=1, int[2] padding=0, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">thnn_conv2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv2d(Tensor self, Tensor weight, int[2] kernel_size, Tensor? bias=None, int[2] stride=1, int[2] padding=0) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">thnn_conv2d_forward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">finput</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fgrad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv2d_forward(Tensor self, Tensor weight, int[2] kernel_size, Tensor? bias, int[2] stride, int[2] padding, *, Tensor(a!) output, Tensor(b!) finput, Tensor(c!) fgrad_input) -&gt; (Tensor(a!), Tensor(b!), Tensor(c!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">output</span><span class="p">,</span> <span class="n">finput</span><span class="p">,</span> <span class="n">fgrad_input</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">thnn_conv2d_forward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv2d_forward(Tensor self, Tensor weight, int[2] kernel_size, Tensor? bias, int[2] stride, int[2] padding) -&gt; (Tensor output, Tensor finput, Tensor fgrad_input)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">thnn_conv2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_weight</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">finput</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fgrad_input</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv2d_backward(Tensor grad_output, Tensor self, Tensor weight, int[2] kernel_size, int[2] stride, int[2] padding, Tensor finput, Tensor fgrad_input, *, Tensor?(a!) grad_input, Tensor?(b!) grad_weight, Tensor?(c!) grad_bias) -&gt; (Tensor(a!), Tensor(b!), Tensor(c!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_weight</span><span class="p">,</span> <span class="n">grad_bias</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">finput</span><span class="p">,</span> <span class="n">fgrad_input</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">thnn_conv2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">finput</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fgrad_input</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv2d_backward(Tensor grad_output, Tensor self, Tensor weight, int[2] kernel_size, int[2] stride, int[2] padding, Tensor finput, Tensor fgrad_input, bool[3] output_mask) -&gt; (Tensor grad_input, Tensor grad_weight, Tensor grad_bias)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">finput</span><span class="p">,</span> <span class="n">fgrad_input</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">thnn_conv_depthwise2d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv_depthwise2d(Tensor self, Tensor weight, int[2] kernel_size, Tensor? bias=None, int[2] stride=1, int[2] padding=0, int[2] dilation=1, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">thnn_conv_depthwise2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv_depthwise2d(Tensor self, Tensor weight, int[2] kernel_size, Tensor? bias=None, int[2] stride=1, int[2] padding=0, int[2] dilation=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">thnn_conv_depthwise2d_forward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv_depthwise2d_forward(Tensor self, Tensor weight, int[2] kernel_size, Tensor? bias, int[2] stride, int[2] padding, int[2] dilation, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">thnn_conv_depthwise2d_forward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv_depthwise2d_forward(Tensor self, Tensor weight, int[2] kernel_size, Tensor? bias, int[2] stride, int[2] padding, int[2] dilation) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">thnn_conv_depthwise2d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv_depthwise2d_backward(Tensor grad_output, Tensor self, Tensor weight, int[2] kernel_size, int[2] stride, int[2] padding, int[2] dilation, *, Tensor?(a!) grad_input, Tensor?(b!) grad_weight) -&gt; (Tensor(a!), Tensor(b!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_weight</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">thnn_conv_depthwise2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv_depthwise2d_backward(Tensor grad_output, Tensor self, Tensor weight, int[2] kernel_size, int[2] stride, int[2] padding, int[2] dilation, bool[2] output_mask) -&gt; (Tensor grad_input, Tensor grad_weight)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">thnn_conv3d_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv3d(Tensor self, Tensor weight, int[3] kernel_size, Tensor? bias=None, int[3] stride=1, int[3] padding=0, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">thnn_conv3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv3d(Tensor self, Tensor weight, int[3] kernel_size, Tensor? bias=None, int[3] stride=1, int[3] padding=0) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">thnn_conv3d_forward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">finput</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fgrad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv3d_forward(Tensor self, Tensor weight, int[3] kernel_size, Tensor? bias, int[3] stride, int[3] padding, *, Tensor(a!) output, Tensor(b!) finput, Tensor(c!) fgrad_input) -&gt; (Tensor(a!), Tensor(b!), Tensor(c!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">output</span><span class="p">,</span> <span class="n">finput</span><span class="p">,</span> <span class="n">fgrad_input</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">thnn_conv3d_forward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv3d_forward(Tensor self, Tensor weight, int[3] kernel_size, Tensor? bias, int[3] stride, int[3] padding) -&gt; (Tensor output, Tensor finput, Tensor fgrad_input)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="n">thnn_conv3d_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_weight</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_bias</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">finput</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fgrad_input</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv3d_backward(Tensor grad_output, Tensor self, Tensor weight, int[3] kernel_size, int[3] stride, int[3] padding, Tensor finput, Tensor fgrad_input, *, Tensor?(a!) grad_input, Tensor?(b!) grad_weight, Tensor?(c!) grad_bias) -&gt; (Tensor(a!), Tensor(b!), Tensor(c!))&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">Tensor</span> <span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_weight</span><span class="p">,</span> <span class="n">grad_bias</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">finput</span><span class="p">,</span> <span class="n">fgrad_input</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">thnn_conv3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">finput</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">fgrad_input</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::thnn_conv3d_backward(Tensor grad_output, Tensor self, Tensor weight, int[3] kernel_size, int[3] stride, int[3] padding, Tensor finput, Tensor fgrad_input, bool[3] output_mask) -&gt; (Tensor grad_input, Tensor grad_weight, Tensor grad_bias)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">finput</span><span class="p">,</span> <span class="n">fgrad_input</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">conv_dilated2d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv_dilated2d(Tensor self, Tensor weight, int[2] kernel_size, Tensor? bias=None, int[2] stride=1, int[2] padding=0, int[2] dilation=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">conv_dilated2d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv_dilated2d_backward(Tensor grad_output, Tensor self, Tensor weight, int[2] kernel_size, int[2] stride, int[2] padding, int[2] dilation, bool[3] output_mask) -&gt; (Tensor grad_input, Tensor grad_weight, Tensor grad_bias)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">conv_dilated3d</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">bias</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv_dilated3d(Tensor self, Tensor weight, int[3] kernel_size, Tensor? bias=None, int[3] stride=1, int[3] padding=0, int[3] dilation=1) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">conv_dilated3d_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">output_mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::conv_dilated3d_backward(Tensor grad_output, Tensor self, Tensor weight, int[3] kernel_size, int[3] stride, int[3] padding, int[3] dilation, bool[3] output_mask) -&gt; (Tensor grad_input, Tensor grad_weight, Tensor grad_bias)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="p">,</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col2im_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::col2im(Tensor self, int[2] output_size, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">col2im</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::col2im(Tensor self, int[2] output_size, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">col2im_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::col2im_backward(Tensor grad_output, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_input</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">col2im_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::col2im_backward(Tensor grad_output, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">im2col_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::im2col(Tensor self, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride, *, Tensor(a!) out) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">out</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">im2col</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">self</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::im2col(Tensor self, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">self</span><span class="p">))(</span><span class="n">self</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">im2col_backward_out</span><span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_input</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::im2col_backward(Tensor grad_output, int[2] input_size, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride, *, Tensor(a!) grad_input) -&gt; Tensor(a!)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_input</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_input</span><span class="p">))(</span><span class="n">grad_input</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Tensor</span> <span class="n">im2col_backward</span><span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span> <span class="n">grad_output</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">padding</span><span class="p">,</span> <span class="n">IntArrayRef</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">table</span> <span class="o">=</span> <span class="n">globalATenDispatch</span><span class="p">().</span><span class="n">getOpTable</span><span class="p">(</span><span class="s">&quot;aten::im2col_backward(Tensor grad_output, int[2] input_size, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride) -&gt; Tensor&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">getOp</span><span class="o">&lt;</span><span class="n">Tensor</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tensor</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">,</span> <span class="n">IntArrayRef</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">grad_output</span><span class="p">),</span> <span class="n">at</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">infer_is_variable</span><span class="p">(</span><span class="n">grad_output</span><span class="p">))(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">dilation</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">stride</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
</div>


             </article>
             
            </div>
            <footer>
  

  

    <hr>

  

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Torch Contributors.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>
     

</footer>

          </div>
        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              <ul>
<li><a class="reference internal" href="#">Program Listing for File Functions.h</a></li>
</ul>

            </div>
          </div>
        </div>
      </section>
    </div>

  


  

     
       <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
         <script type="text/javascript" src="../_static/jquery.js"></script>
         <script type="text/javascript" src="../_static/underscore.js"></script>
         <script type="text/javascript" src="../_static/doctools.js"></script>
         <script type="text/javascript" src="../_static/language_data.js"></script>
         <script type="text/javascript" src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
         <script type="text/javascript" src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
     

  

  <script type="text/javascript" src="../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../_static/js/vendor/bootstrap.min.js"></script>
  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

  <!-- Begin Footer -->

  <div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
    <div class="container">
      <div class="row">
        <div class="col-md-4 text-center">
          <h2>Docs</h2>
          <p>Access comprehensive developer documentation for PyTorch</p>
          <a class="with-right-arrow" href="https://pytorch.org/docs/stable/index.html">View Docs</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Tutorials</h2>
          <p>Get in-depth tutorials for beginners and advanced developers</p>
          <a class="with-right-arrow" href="https://pytorch.org/tutorials">View Tutorials</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Resources</h2>
          <p>Find development resources and get your questions answered</p>
          <a class="with-right-arrow" href="https://pytorch.org/resources">View Resources</a>
        </div>
      </div>
    </div>
  </div>

  <footer class="site-footer">
    <div class="container footer-container">
      <div class="footer-logo-wrapper">
        <a href="https://pytorch.org/" class="footer-logo"></a>
      </div>

      <div class="footer-links-wrapper">
        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/">PyTorch</a></li>
            <li><a href="https://pytorch.org/get-started">Get Started</a></li>
            <li><a href="https://pytorch.org/features">Features</a></li>
            <li><a href="https://pytorch.org/ecosystem">Ecosystem</a></li>
            <li><a href="https://pytorch.org/blog/">Blog</a></li>
            <li><a href="https://pytorch.org/resources">Resources</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/support">Support</a></li>
            <li><a href="https://pytorch.org/tutorials">Tutorials</a></li>
            <li><a href="https://pytorch.org/docs/stable/index.html">Docs</a></li>
            <li><a href="https://discuss.pytorch.org" target="_blank">Discuss</a></li>
            <li><a href="https://github.com/pytorch/pytorch/issues" target="_blank">Github Issues</a></li>
            <li><a href="https://pytorch.slack.com" target="_blank">Slack</a></li>
            <li><a href="https://github.com/pytorch/pytorch/blob/master/CONTRIBUTING.md" target="_blank">Contributing</a></li>
          </ul>
        </div>

        <div class="footer-links-col follow-us-col">
          <ul>
            <li class="list-title">Follow Us</li>
            <li>
              <div id="mc_embed_signup">
                <form
                  action="https://twitter.us14.list-manage.com/subscribe/post?u=75419c71fe0a935e53dfa4a3f&id=91d0dccd39"
                  method="post"
                  id="mc-embedded-subscribe-form"
                  name="mc-embedded-subscribe-form"
                  class="email-subscribe-form validate"
                  target="_blank"
                  novalidate>
                  <div id="mc_embed_signup_scroll" class="email-subscribe-form-fields-wrapper">
                    <div class="mc-field-group">
                      <label for="mce-EMAIL" style="display:none;">Email Address</label>
                      <input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" placeholder="Email Address">
                    </div>

                    <div id="mce-responses" class="clear">
                      <div class="response" id="mce-error-response" style="display:none"></div>
                      <div class="response" id="mce-success-response" style="display:none"></div>
                    </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->

                    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_75419c71fe0a935e53dfa4a3f_91d0dccd39" tabindex="-1" value=""></div>

                    <div class="clear">
                      <input type="submit" value="" name="subscribe" id="mc-embedded-subscribe" class="button email-subscribe-button">
                    </div>
                  </div>
                </form>
              </div>

            </li>
          </ul>

          <div class="footer-social-icons">
            <a href="https://www.facebook.com/pytorch" target="_blank" class="facebook"></a>
            <a href="https://twitter.com/pytorch" target="_blank" class="twitter"></a>
          </div>
        </div>
      </div>
    </div>
  </footer>

  <div class="cookie-banner-wrapper">
  <div class="container">
    <p class="gdpr-notice">To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebook’s Cookies Policy applies. Learn more, including about available controls: <a href="https://www.facebook.com/policies/cookies/">Cookies Policy</a>.</p>
    <img class="close-button" src="../_static/images/pytorch-x.svg">
  </div>
</div>

  <!-- End Footer -->

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="#">Get Started</a>
          </li>

          <li>
            <a href="#">Features</a>
          </li>

          <li>
            <a href="#">Ecosystem</a>
          </li>

          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>

          <li>
            <a href="https://pytorch.org/tutorials">Tutorials</a>
          </li>

          <li class="active">
            <a href="https://pytorch.org/docs/stable/index.html">Docs</a>
          </li>

          <li>
            <a href="https://pytorch.org/resources">Resources</a>
          </li>

          <li>
            <a href="https://github.com/pytorch/pytorch">Github</a>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>