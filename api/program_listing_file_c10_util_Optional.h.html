


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File Optional.h &mdash; PyTorch master documentation</title>
  

  
  
  
  
    <link rel="canonical" href="https://pytorch.org/docs/stable/api/program_listing_file_c10_util_Optional.h.html"/>
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File ordered_dict.h" href="file_torch_csrc_api_include_torch_ordered_dict.h.html" />
    <link rel="prev" title="File Optional.h" href="file_c10_util_Optional.h.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>
</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>
          <li>
            <a href="https://pytorch.org/get-started">Get Started</a>
          </li>

          <li>
            <a href="https://pytorch.org/features">Features</a>
          </li>

          <li>
            <a href="https://pytorch.org/ecosystem">Ecosystem</a>
          </li>

          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>

          <li>
            <a href="https://pytorch.org/tutorials">Tutorials</a>
          </li>

          <li class="active">
            <a href="https://pytorch.org/docs/stable/index.html">Docs</a>
          </li>

          <li>
            <a href="https://pytorch.org/resources">Resources</a>
          </li>

          <li>
            <a href="https://github.com/pytorch/pytorch">Github</a>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>

  </div>
</div>


<body class="pytorch-body">

   

    

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">
            

            
              
              
                <div class="version">
                  master
                </div>
              
            

            


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

            
          </div>

          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installing.html">Installing C++ Distributions of PyTorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../frontend.html">The C++ Frontend</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing to PyTorch</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="library_root.html">Library API</a></li>
</ul>
<p class="caption"><span class="caption-text">Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../notes/faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notes/tensor_basics.html">Tensor Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notes/tensor_creation.html">Tensor Creation API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="../index.html">
          
            Docs
          
        </a> &gt;
      </li>

        
          <li><a href="library_root.html">Library API</a> &gt;</li>
        
          <li><a href="file_c10_util_Optional.h.html">File Optional.h</a> &gt;</li>
        
      <li>Program Listing for File Optional.h</li>
    
    
      <li class="pytorch-breadcrumbs-aside">
        
            
            
              <!-- User defined GitHub URL -->
              <a href="https://github.com/pytorch/pytorch" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">

        
          
          <div class="rst-content">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
              
  <div class="section" id="program-listing-for-file-optional-h">
<span id="program-listing-file-c10-util-optional-h"></span><h1>Program Listing for File Optional.h<a class="headerlink" href="#program-listing-for-file-optional-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_c10_util_Optional.h.html#file-c10-util-optional-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">c10/util/Optional.h</span></code>)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Copyright (C) 2011 - 2012 Andrzej Krzemienski.
//
// Use, modification, and distribution is subject to the Boost Software
// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
// The idea and interface is based on Boost.Optional library
// authored by Fernando Luis Cacciola Carballal
//
// From https://github.com/akrzemi1/Optional
//
// C10
// - Move to `c10` namespace.
// - Remove macro use in line 478 because the nvcc device compiler cannot handle
// it.
// - revise constructor logic so that it is consistent with c++ 17 standard documented
// here in (8): https://en.cppreference.com/w/cpp/utility/optional/optional, and
// could be able to support initialization of optionals from convertible type U, also
// remove two old constructors optional(const T&amp;) and optional(T&amp;&amp;) as it could be
// handled by the template&lt;U=T&gt; case with default template argument.

#ifndef C10_UTIL_OPTIONAL_H_
#define C10_UTIL_OPTIONAL_H_

#include &lt;cassert&gt;
#include &lt;functional&gt;
#include &lt;initializer_list&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;
#include &lt;utility&gt;

#define TR2_OPTIONAL_REQUIRES(...) \
  typename std::enable_if&lt;__VA_ARGS__::value, bool&gt;::type = false

#if defined __GNUC__ // NOTE: GNUC is also defined for Clang
#if (__GNUC__ == 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 8)
#define TR2_OPTIONAL_GCC_4_8_AND_HIGHER___
#elif (__GNUC__ &gt; 4)
#define TR2_OPTIONAL_GCC_4_8_AND_HIGHER___
#endif
#
#if (__GNUC__ == 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 7)
#define TR2_OPTIONAL_GCC_4_7_AND_HIGHER___
#elif (__GNUC__ &gt; 4)
#define TR2_OPTIONAL_GCC_4_7_AND_HIGHER___
#endif
#
#if (__GNUC__ == 4) &amp;&amp; (__GNUC_MINOR__ == 8) &amp;&amp; (__GNUC_PATCHLEVEL__ &gt;= 1)
#define TR2_OPTIONAL_GCC_4_8_1_AND_HIGHER___
#elif (__GNUC__ == 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 9)
#define TR2_OPTIONAL_GCC_4_8_1_AND_HIGHER___
#elif (__GNUC__ &gt; 4)
#define TR2_OPTIONAL_GCC_4_8_1_AND_HIGHER___
#endif
#endif
#
#if defined __clang_major__
#if (__clang_major__ == 3 &amp;&amp; __clang_minor__ &gt;= 5)
#define TR2_OPTIONAL_CLANG_3_5_AND_HIGHTER_
#elif (__clang_major__ &gt; 3)
#define TR2_OPTIONAL_CLANG_3_5_AND_HIGHTER_
#endif
#if defined TR2_OPTIONAL_CLANG_3_5_AND_HIGHTER_
#define TR2_OPTIONAL_CLANG_3_4_2_AND_HIGHER_
#elif ( \
    __clang_major__ == 3 &amp;&amp; __clang_minor__ == 4 &amp;&amp; __clang_patchlevel__ &gt;= 2)
#define TR2_OPTIONAL_CLANG_3_4_2_AND_HIGHER_
#endif
#endif
#
#if defined _MSC_VER
#if (_MSC_VER &gt;= 1900)
#define TR2_OPTIONAL_MSVC_2015_AND_HIGHER___
#endif
#endif

#if defined __clang__
#if (__clang_major__ &gt; 2) || (__clang_major__ == 2) &amp;&amp; (__clang_minor__ &gt;= 9)
#define OPTIONAL_HAS_THIS_RVALUE_REFS 1
#else
#define OPTIONAL_HAS_THIS_RVALUE_REFS 0
#endif
#elif defined TR2_OPTIONAL_GCC_4_8_1_AND_HIGHER___
#define OPTIONAL_HAS_THIS_RVALUE_REFS 1
#elif defined TR2_OPTIONAL_MSVC_2015_AND_HIGHER___
#define OPTIONAL_HAS_THIS_RVALUE_REFS 1
#else
#define OPTIONAL_HAS_THIS_RVALUE_REFS 0
#endif

#if defined TR2_OPTIONAL_GCC_4_8_1_AND_HIGHER___
#define OPTIONAL_HAS_CONSTEXPR_INIT_LIST 1
#define OPTIONAL_CONSTEXPR_INIT_LIST constexpr
#else
#define OPTIONAL_HAS_CONSTEXPR_INIT_LIST 0
#define OPTIONAL_CONSTEXPR_INIT_LIST
#endif

#if defined TR2_OPTIONAL_CLANG_3_5_AND_HIGHTER_ &amp;&amp; (defined __cplusplus) &amp;&amp; \
    (__cplusplus != 201103L)
#define OPTIONAL_HAS_MOVE_ACCESSORS 1
#else
#define OPTIONAL_HAS_MOVE_ACCESSORS 0
#endif

#// In C++11 constexpr implies const, so we need to make non-const members also non-constexpr
#if (defined __cplusplus) &amp;&amp; (__cplusplus == 201103L)
#define OPTIONAL_MUTABLE_CONSTEXPR
#else
#define OPTIONAL_MUTABLE_CONSTEXPR constexpr
#endif

namespace c10 {

// 20.5.4, optional for object types
template &lt;class T&gt;
class optional;

// 20.5.5, optional for lvalue reference types
template &lt;class T&gt;
class optional&lt;T&amp;&gt;;

// workaround: std utility functions aren&#39;t constexpr yet
template &lt;class T&gt;
inline constexpr T&amp;&amp; constexpr_forward(
    typename std::remove_reference&lt;T&gt;::type&amp; t) noexcept {
  return static_cast&lt;T&amp;&amp;&gt;(t);
}

template &lt;class T&gt;
inline constexpr T&amp;&amp; constexpr_forward(
    typename std::remove_reference&lt;T&gt;::type&amp;&amp; t) noexcept {
  static_assert(!std::is_lvalue_reference&lt;T&gt;::value, &quot;!!&quot;);
  return static_cast&lt;T&amp;&amp;&gt;(t);
}

template &lt;class T&gt;
inline constexpr typename std::remove_reference&lt;T&gt;::type&amp;&amp; constexpr_move(
    T&amp;&amp; t) noexcept {
  return static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);
}

#if defined NDEBUG
#define TR2_OPTIONAL_ASSERTED_EXPRESSION(CHECK, EXPR) (EXPR)
#else
#define TR2_OPTIONAL_ASSERTED_EXPRESSION(CHECK, EXPR) \
  ((CHECK) ? (EXPR) : ([] { assert(!#CHECK); }(), (EXPR)))
#endif

namespace detail_ {

// VS 2015 doesn&#39;t handle constexpr well, so we need to skip these stuff.
#if (defined _MSC_VER) &amp;&amp; (_MSC_VER &lt;= 1900)
template &lt;typename T&gt;
T* static_addressof(T&amp; ref) {
  return std::addressof(ref);
}
#else
// static_addressof: a constexpr version of addressof
template &lt;typename T&gt;
struct has_overloaded_addressof {
  template &lt;class X&gt;
  constexpr static bool has_overload(...) {
    return false;
  }

  template &lt;class X, size_t S = sizeof(std::declval&lt;X&amp;&gt;().operator&amp;())&gt;
  constexpr static bool has_overload(bool) {
    return true;
  }

  constexpr static bool value = has_overload&lt;T&gt;(true);
};

template &lt;typename T, TR2_OPTIONAL_REQUIRES(!has_overloaded_addressof&lt;T&gt;)&gt;
constexpr T* static_addressof(T&amp; ref) {
  return &amp;ref;
}

template &lt;typename T, TR2_OPTIONAL_REQUIRES(has_overloaded_addressof&lt;T&gt;)&gt;
T* static_addressof(T&amp; ref) {
  return std::addressof(ref);
}
#endif

// the call to convert&lt;A&gt;(b) has return type A and converts b to type A iff b
// decltype(b) is implicitly convertible to A
template &lt;class U&gt;
constexpr U convert(U v) {
  return v;
}

} // namespace detail_

constexpr struct trivial_init_t {
} trivial_init{};

// 20.5.6, In-place construction
constexpr struct in_place_t {
} in_place{};

// 20.5.7, Disengaged state indicator
struct nullopt_t {
  struct init {};
  constexpr explicit nullopt_t(init) {}
};
constexpr nullopt_t nullopt{nullopt_t::init()};

// 20.5.8, class bad_optional_access
class bad_optional_access : public std::logic_error {
 public:
  explicit bad_optional_access(const std::string&amp; what_arg)
      : logic_error{what_arg} {}
  explicit bad_optional_access(const char* what_arg) : logic_error{what_arg} {}
};

template &lt;class T&gt;
union storage_t {
  unsigned char dummy_;
  T value_;

  constexpr storage_t(trivial_init_t) noexcept : dummy_(){};

  template &lt;class... Args&gt;
  constexpr storage_t(Args&amp;&amp;... args)
      : value_(constexpr_forward&lt;Args&gt;(args)...) {}

  ~storage_t() {}
};

template &lt;class T&gt;
union constexpr_storage_t {
  unsigned char dummy_;
  T value_;

  constexpr constexpr_storage_t(trivial_init_t) noexcept : dummy_(){};

  template &lt;class... Args&gt;
  constexpr constexpr_storage_t(Args&amp;&amp;... args)
      : value_(constexpr_forward&lt;Args&gt;(args)...) {}

  ~constexpr_storage_t() = default;
};

template &lt;class T&gt;
struct optional_base {
  bool init_;
  storage_t&lt;T&gt; storage_;

  constexpr optional_base() noexcept : init_(false), storage_(trivial_init){};

  explicit constexpr optional_base(const T&amp; v) : init_(true), storage_(v) {}

  explicit constexpr optional_base(T&amp;&amp; v)
      : init_(true), storage_(constexpr_move(v)) {}

  template &lt;class... Args&gt;
  explicit optional_base(in_place_t, Args&amp;&amp;... args)
      : init_(true), storage_(constexpr_forward&lt;Args&gt;(args)...) {}

  template &lt;
      class U,
      class... Args,
      TR2_OPTIONAL_REQUIRES(std::is_constructible&lt;T, std::initializer_list&lt;U&gt;&gt;)&gt;
  explicit optional_base(
      in_place_t,
      std::initializer_list&lt;U&gt; il,
      Args&amp;&amp;... args)
      : init_(true), storage_(il, std::forward&lt;Args&gt;(args)...) {}

  ~optional_base() {
    if (init_)
      storage_.value_.T::~T();
  }
};

template &lt;class T&gt;
struct constexpr_optional_base {
  bool init_;
  constexpr_storage_t&lt;T&gt; storage_;

  constexpr constexpr_optional_base() noexcept
      : init_(false), storage_(trivial_init){};

  explicit constexpr constexpr_optional_base(const T&amp; v)
      : init_(true), storage_(v) {}

  explicit constexpr constexpr_optional_base(T&amp;&amp; v)
      : init_(true), storage_(constexpr_move(v)) {}

  template &lt;class... Args&gt;
  explicit constexpr constexpr_optional_base(in_place_t, Args&amp;&amp;... args)
      : init_(true), storage_(constexpr_forward&lt;Args&gt;(args)...) {}

  template &lt;
      class U,
      class... Args,
      TR2_OPTIONAL_REQUIRES(std::is_constructible&lt;T, std::initializer_list&lt;U&gt;&gt;)&gt;
  OPTIONAL_CONSTEXPR_INIT_LIST explicit constexpr_optional_base(
      in_place_t,
      std::initializer_list&lt;U&gt; il,
      Args&amp;&amp;... args)
      : init_(true), storage_(il, std::forward&lt;Args&gt;(args)...) {}

  ~constexpr_optional_base() = default;
};

template &lt;class T&gt;
using OptionalBase = typename std::conditional&lt;
    std::is_trivially_destructible&lt;T&gt;::value, // if possible
    constexpr_optional_base&lt;typename std::remove_const&lt;
        T&gt;::type&gt;, // use base with trivial destructor
    optional_base&lt;typename std::remove_const&lt;T&gt;::type&gt;&gt;::type;

template &lt;class T&gt;
class optional : private OptionalBase&lt;T&gt; {
  template &lt;class U&gt; // re-declaration for nvcc on Windows.
  using OptionalBase = typename std::conditional&lt;
      std::is_trivially_destructible&lt;U&gt;::value, // if possible
      constexpr_optional_base&lt;typename std::remove_const&lt;
          U&gt;::type&gt;, // use base with trivial destructor
      optional_base&lt;typename std::remove_const&lt;U&gt;::type&gt;&gt;::type;

  static_assert(
      !std::is_same&lt;typename std::decay&lt;T&gt;::type, nullopt_t&gt;::value,
      &quot;bad T&quot;);
  static_assert(
      !std::is_same&lt;typename std::decay&lt;T&gt;::type, in_place_t&gt;::value,
      &quot;bad T&quot;);

  constexpr bool initialized() const noexcept {
    return OptionalBase&lt;T&gt;::init_;
  }
  typename std::remove_const&lt;T&gt;::type* dataptr() {
    return std::addressof(OptionalBase&lt;T&gt;::storage_.value_);
  }
  constexpr const T* dataptr() const {
    return detail_::static_addressof(OptionalBase&lt;T&gt;::storage_.value_);
  }

#if OPTIONAL_HAS_THIS_RVALUE_REFS == 1
  constexpr const T&amp; contained_val() const&amp; {
    return OptionalBase&lt;T&gt;::storage_.value_;
  }
#if OPTIONAL_HAS_MOVE_ACCESSORS == 1
  OPTIONAL_MUTABLE_CONSTEXPR T&amp;&amp; contained_val() &amp;&amp; {
    return std::move(OptionalBase&lt;T&gt;::storage_.value_);
  }
  OPTIONAL_MUTABLE_CONSTEXPR T&amp; contained_val() &amp; {
    return OptionalBase&lt;T&gt;::storage_.value_;
  }
#else
  T&amp; contained_val() &amp; {
    return OptionalBase&lt;T&gt;::storage_.value_;
  }
  T&amp;&amp; contained_val() &amp;&amp; {
    return std::move(OptionalBase&lt;T&gt;::storage_.value_);
  }
#endif
#else
  constexpr const T&amp; contained_val() const {
    return OptionalBase&lt;T&gt;::storage_.value_;
  }
  T&amp; contained_val() {
    return OptionalBase&lt;T&gt;::storage_.value_;
  }
#endif

  void clear() noexcept {
    if (initialized())
      dataptr()-&gt;~T();
    OptionalBase&lt;T&gt;::init_ = false;
  }

  template &lt;class... Args&gt;
  void initialize(Args&amp;&amp;... args) noexcept(
      noexcept(T(std::forward&lt;Args&gt;(args)...))) {
    assert(!OptionalBase&lt;T&gt;::init_);
    ::new (static_cast&lt;void*&gt;(dataptr())) T(std::forward&lt;Args&gt;(args)...);
    OptionalBase&lt;T&gt;::init_ = true;
  }

  template &lt;class U, class... Args&gt;
  void initialize(std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args) noexcept(
      noexcept(T(il, std::forward&lt;Args&gt;(args)...))) {
    assert(!OptionalBase&lt;T&gt;::init_);
    ::new (static_cast&lt;void*&gt;(dataptr())) T(il, std::forward&lt;Args&gt;(args)...);
    OptionalBase&lt;T&gt;::init_ = true;
  }

 public:
  typedef T value_type;

  // 20.5.5.1, constructors
  constexpr optional() noexcept : OptionalBase&lt;T&gt;(){};
  constexpr optional(nullopt_t) noexcept : OptionalBase&lt;T&gt;(){};

  optional(const optional&amp; rhs) : OptionalBase&lt;T&gt;() {
    if (rhs.initialized()) {
      ::new (static_cast&lt;void*&gt;(dataptr())) T(*rhs);
      OptionalBase&lt;T&gt;::init_ = true;
    }
  }

  optional(optional&amp;&amp; rhs) noexcept(
      std::is_nothrow_move_constructible&lt;T&gt;::value)
      : OptionalBase&lt;T&gt;() {
    if (rhs.initialized()) {
      ::new (static_cast&lt;void*&gt;(dataptr())) T(std::move(*rhs));
      OptionalBase&lt;T&gt;::init_ = true;
    }
  }

  // see https://github.com/akrzemi1/Optional/issues/16
  // and https://en.cppreference.com/w/cpp/utility/optional/optional,
  // in constructor 8, the std::optional spec can allow initialization
  // of optionals from convertible type U
  //
  // 8 - implicit move construct from value
  template&lt;
      typename U = T,
      TR2_OPTIONAL_REQUIRES(
          std::is_constructible&lt;T, U&amp;&amp;&gt;::value
          &amp;&amp; !std::is_same&lt;typename std::decay&lt;U&gt;::type, in_place_t&gt;::value
          &amp;&amp; !std::is_same&lt;typename std::decay&lt;U&gt;::type, optional&lt;T&gt;&gt;::value
          &amp;&amp; std::is_convertible&lt;U&amp;&amp;, T&gt;
      )
    &gt;
  constexpr optional(U&amp;&amp; u) : OptionalBase&lt;T&gt;(std::forward&lt;U&gt;(u)) {}

  // 8 - explicit move construct from value
  template&lt;
      typename U = T,
      TR2_OPTIONAL_REQUIRES(
          std::is_constructible&lt;T, U&amp;&amp;&gt;::value
          &amp;&amp; !std::is_same&lt;typename std::decay&lt;U&gt;::type, in_place_t&gt;::value
          &amp;&amp; !std::is_same&lt;typename std::decay&lt;U&gt;::type, optional&lt;T&gt;&gt;::value
          &amp;&amp; !std::is_convertible&lt;U&amp;&amp;, T&gt;
      )
    &gt;
  explicit constexpr optional(U&amp;&amp; u) : OptionalBase&lt;T&gt;(std::forward&lt;U&gt;(u)) {}

  template &lt;class... Args&gt;
  explicit constexpr optional(in_place_t, Args&amp;&amp;... args)
      : OptionalBase&lt;T&gt;(in_place_t{}, constexpr_forward&lt;Args&gt;(args)...) {}

  template &lt;
      class U,
      class... Args,
      TR2_OPTIONAL_REQUIRES(std::is_constructible&lt;T, std::initializer_list&lt;U&gt;&gt;)&gt;
  OPTIONAL_CONSTEXPR_INIT_LIST explicit optional(
      in_place_t,
      std::initializer_list&lt;U&gt; il,
      Args&amp;&amp;... args)
      : OptionalBase&lt;T&gt;(in_place_t{}, il, constexpr_forward&lt;Args&gt;(args)...) {}

  // 20.5.4.2, Destructor
  ~optional() = default;

  // 20.5.4.3, assignment
  optional&amp; operator=(nullopt_t) noexcept {
    clear();
    return *this;
  }

  optional&amp; operator=(const optional&amp; rhs) {
    if (initialized() == true &amp;&amp; rhs.initialized() == false)
      clear();
    else if (initialized() == false &amp;&amp; rhs.initialized() == true)
      initialize(*rhs);
    else if (initialized() == true &amp;&amp; rhs.initialized() == true)
      contained_val() = *rhs;
    return *this;
  }

  optional&amp; operator=(optional&amp;&amp; rhs) noexcept(
      std::is_nothrow_move_assignable&lt;T&gt;::value&amp;&amp;
          std::is_nothrow_move_constructible&lt;T&gt;::value) {
    if (initialized() == true &amp;&amp; rhs.initialized() == false)
      clear();
    else if (initialized() == false &amp;&amp; rhs.initialized() == true)
      initialize(std::move(*rhs));
    else if (initialized() == true &amp;&amp; rhs.initialized() == true)
      contained_val() = std::move(*rhs);
    return *this;
  }

  template&lt;class U = T&gt;
  auto operator=(U&amp;&amp; v) -&gt; typename std::enable_if&lt;
          std::is_constructible&lt;T, U&gt;::value
          &amp;&amp; !std::is_same&lt;typename std::decay&lt;U&gt;::type, optional&lt;T&gt;&gt;::value
          &amp;&amp; (std::is_scalar&lt;T&gt;::value || std::is_same&lt;typename std::decay&lt;U&gt;::type, T&gt;::value)
          &amp;&amp; std::is_assignable&lt;T&amp;, U&gt;::value,
      optional&amp;&gt;::type {
    if (initialized()) {
      contained_val() = std::forward&lt;U&gt;(v);
    } else {
      initialize(std::forward&lt;U&gt;(v));
    }
    return *this;
  }

  template &lt;class... Args&gt;
  void emplace(Args&amp;&amp;... args) {
    clear();
    initialize(std::forward&lt;Args&gt;(args)...);
  }

  template &lt;class U, class... Args&gt;
  void emplace(std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args) {
    clear();
    initialize&lt;U, Args...&gt;(il, std::forward&lt;Args&gt;(args)...);
  }

  // 20.5.4.4, Swap
  void swap(optional&lt;T&gt;&amp; rhs) noexcept(
      std::is_nothrow_move_constructible&lt;T&gt;::value&amp;&amp; noexcept(
          swap(std::declval&lt;T&amp;&gt;(), std::declval&lt;T&amp;&gt;()))) {
    if (initialized() == true &amp;&amp; rhs.initialized() == false) {
      rhs.initialize(std::move(**this));
      clear();
    } else if (initialized() == false &amp;&amp; rhs.initialized() == true) {
      initialize(std::move(*rhs));
      rhs.clear();
    } else if (initialized() == true &amp;&amp; rhs.initialized() == true) {
      using std::swap;
      swap(**this, *rhs);
    }
  }

  // 20.5.4.5, Observers

  explicit constexpr operator bool() const noexcept {
    return initialized();
  }
  constexpr bool has_value() const noexcept {
    return initialized();
  }

  constexpr T const* operator-&gt;() const {
    return TR2_OPTIONAL_ASSERTED_EXPRESSION(initialized(), dataptr());
  }

#if OPTIONAL_HAS_MOVE_ACCESSORS == 1

  OPTIONAL_MUTABLE_CONSTEXPR T* operator-&gt;() {
    assert(initialized());
    return dataptr();
  }

  constexpr T const&amp; operator*() const&amp; {
    return TR2_OPTIONAL_ASSERTED_EXPRESSION(initialized(), contained_val());
  }

  OPTIONAL_MUTABLE_CONSTEXPR T&amp; operator*() &amp; {
    assert(initialized());
    return contained_val();
  }

  OPTIONAL_MUTABLE_CONSTEXPR T&amp;&amp; operator*() &amp;&amp; {
    assert(initialized());
    return constexpr_move(contained_val());
  }

  constexpr T const&amp; value() const&amp; {
    return initialized()
        ? contained_val()
        : (throw bad_optional_access(&quot;bad optional access&quot;), contained_val());
  }

  OPTIONAL_MUTABLE_CONSTEXPR T&amp; value() &amp; {
    return initialized()
        ? contained_val()
        : (throw bad_optional_access(&quot;bad optional access&quot;), contained_val());
  }

  OPTIONAL_MUTABLE_CONSTEXPR T&amp;&amp; value() &amp;&amp; {
    if (!initialized())
      throw bad_optional_access(&quot;bad optional access&quot;);
    return std::move(contained_val());
  }

#else

  T* operator-&gt;() {
    assert(initialized());
    return dataptr();
  }

  constexpr T const&amp; operator*() const {
    return contained_val();
  }

  T&amp; operator*() {
    assert(initialized());
    return contained_val();
  }

  constexpr T const&amp; value() const {
    return initialized()
        ? contained_val()
        : (throw bad_optional_access(&quot;bad optional access&quot;), contained_val());
  }

  T&amp; value() {
    return initialized()
        ? contained_val()
        : (throw bad_optional_access(&quot;bad optional access&quot;), contained_val());
  }

#endif

#if OPTIONAL_HAS_THIS_RVALUE_REFS == 1

  template &lt;class V&gt;
  constexpr T value_or(V&amp;&amp; v) const&amp; {
    return *this ? **this : detail_::convert&lt;T&gt;(constexpr_forward&lt;V&gt;(v));
  }

#if OPTIONAL_HAS_MOVE_ACCESSORS == 1

  template &lt;class V&gt;
  OPTIONAL_MUTABLE_CONSTEXPR T value_or(V&amp;&amp; v) &amp;&amp; {
    return *this
        ? constexpr_move(const_cast&lt;optional&lt;T&gt;&amp;&gt;(*this).contained_val())
        : detail_::convert&lt;T&gt;(constexpr_forward&lt;V&gt;(v));
  }

#else

  template &lt;class V&gt;
  T value_or(V&amp;&amp; v) &amp;&amp; {
    return *this
        ? constexpr_move(const_cast&lt;optional&lt;T&gt;&amp;&gt;(*this).contained_val())
        : detail_::convert&lt;T&gt;(constexpr_forward&lt;V&gt;(v));
  }

#endif

#else

  template &lt;class V&gt;
  constexpr T value_or(V&amp;&amp; v) const {
    return *this ? **this : detail_::convert&lt;T&gt;(constexpr_forward&lt;V&gt;(v));
  }

#endif

  // 20.6.3.6, modifiers
  void reset() noexcept {
    clear();
  }
};


// XXX: please refrain from using optional&lt;T&amp;&gt;, since it is being against with
// the optional standard in c++ 17, see the debate and the details here:
// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3406#rationale.refs
// if you need it, consider using optional&lt;std::reference_wrapper&lt;T&gt;&gt; or * pointer
//
// we leave the implementation here in case we want to reconsider using it in the
// future if it becomes a definitely necessary case.
template &lt;class T&gt;
class optional&lt;T&amp;&gt; {
  // add this assert to prevent user from using optional reference as indicated above
  static_assert(sizeof(T) == 0, &quot;optional references is ill-formed, \
    consider use optional of a std::reference_wrapper of type T to \
    hold a reference if you really need to&quot;);

  static_assert(!std::is_same&lt;T, nullopt_t&gt;::value, &quot;bad T&quot;);
  static_assert(!std::is_same&lt;T, in_place_t&gt;::value, &quot;bad T&quot;);
  T* ref;

 public:
  // 20.5.5.1, construction/destruction
  constexpr optional() noexcept : ref(nullptr) {}

  constexpr optional(nullopt_t) noexcept : ref(nullptr) {}

  template&lt;typename U = T&gt;
  constexpr optional(U&amp; u) noexcept : ref(detail_::static_addressof(u)) {}

  template&lt;typename U = T&gt;
  optional(U&amp;&amp;) = delete;

  constexpr optional(const optional&amp; rhs) noexcept : ref(rhs.ref) {}

  explicit constexpr optional(in_place_t, T&amp; v) noexcept
      : ref(detail_::static_addressof(v)) {}

  explicit optional(in_place_t, T&amp;&amp;) = delete;

  ~optional() = default;

  // 20.5.5.2, mutation
  optional&amp; operator=(nullopt_t) noexcept {
    ref = nullptr;
    return *this;
  }

  // optional&amp; operator=(const optional&amp; rhs) noexcept {
  // ref = rhs.ref;
  // return *this;
  // }

  // optional&amp; operator=(optional&amp;&amp; rhs) noexcept {
  // ref = rhs.ref;
  // return *this;
  // }

  template &lt;typename U&gt;
  auto operator=(U&amp;&amp; rhs) noexcept -&gt; typename std::enable_if&lt;
      std::is_same&lt;typename std::decay&lt;U&gt;::type, optional&lt;T&amp;&gt;&gt;::value,
      optional&amp;&gt;::type {
    ref = rhs.ref;
    return *this;
  }

  template &lt;typename U&gt;
  auto operator=(U&amp;&amp; rhs) noexcept -&gt; typename std::enable_if&lt;
      !std::is_same&lt;typename std::decay&lt;U&gt;::type, optional&lt;T&amp;&gt;&gt;::value,
      optional&amp;&gt;::type = delete;

  void emplace(T&amp; v) noexcept {
    ref = detail_::static_addressof(v);
  }

  void emplace(T&amp;&amp;) = delete;

  void swap(optional&lt;T&amp;&gt;&amp; rhs) noexcept {
    std::swap(ref, rhs.ref);
  }

  // 20.5.5.3, observers
  constexpr T* operator-&gt;() const {
    return TR2_OPTIONAL_ASSERTED_EXPRESSION(ref, ref);
  }

  constexpr T&amp; operator*() const {
    return TR2_OPTIONAL_ASSERTED_EXPRESSION(ref, *ref);
  }

  constexpr T&amp; value() const {
    return ref ? *ref
               : (throw bad_optional_access(&quot;bad optional access&quot;), *ref);
  }

  explicit constexpr operator bool() const noexcept {
    return ref != nullptr;
  }

  constexpr bool has_value() const noexcept {
    return ref != nullptr;
  }

  template &lt;class V&gt;
  constexpr typename std::decay&lt;T&gt;::type value_or(V&amp;&amp; v) const {
    return *this ? **this
                 : detail_::convert&lt;typename std::decay&lt;T&gt;::type&gt;(
                       constexpr_forward&lt;V&gt;(v));
  }

  // x.x.x.x, modifiers
  void reset() noexcept {
    ref = nullptr;
  }
};

template &lt;class T&gt;
class optional&lt;T&amp;&amp;&gt; {
  static_assert(sizeof(T) == 0, &quot;optional rvalue references disallowed&quot;);
};

// 20.5.8, Relational operators
template &lt;class T&gt;
constexpr bool operator==(const optional&lt;T&gt;&amp; x, const optional&lt;T&gt;&amp; y) {
  return bool(x) != bool(y) ? false : bool(x) == false ? true : *x == *y;
}

template &lt;class T&gt;
constexpr bool operator!=(const optional&lt;T&gt;&amp; x, const optional&lt;T&gt;&amp; y) {
  return !(x == y);
}

template &lt;class T&gt;
constexpr bool operator&lt;(const optional&lt;T&gt;&amp; x, const optional&lt;T&gt;&amp; y) {
  return (!y) ? false : (!x) ? true : *x &lt; *y;
}

template &lt;class T&gt;
constexpr bool operator&gt;(const optional&lt;T&gt;&amp; x, const optional&lt;T&gt;&amp; y) {
  return (y &lt; x);
}

template &lt;class T&gt;
constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; x, const optional&lt;T&gt;&amp; y) {
  return !(y &lt; x);
}

template &lt;class T&gt;
constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; x, const optional&lt;T&gt;&amp; y) {
  return !(x &lt; y);
}

// 20.5.9, Comparison with nullopt
template &lt;class T&gt;
constexpr bool operator==(const optional&lt;T&gt;&amp; x, nullopt_t) noexcept {
  return (!x);
}

template &lt;class T&gt;
constexpr bool operator==(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept {
  return (!x);
}

template &lt;class T&gt;
constexpr bool operator!=(const optional&lt;T&gt;&amp; x, nullopt_t) noexcept {
  return bool(x);
}

template &lt;class T&gt;
constexpr bool operator!=(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept {
  return bool(x);
}

template &lt;class T&gt;
constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, nullopt_t) noexcept {
  return false;
}

template &lt;class T&gt;
constexpr bool operator&lt;(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept {
  return bool(x);
}

template &lt;class T&gt;
constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; x, nullopt_t) noexcept {
  return (!x);
}

template &lt;class T&gt;
constexpr bool operator&lt;=(nullopt_t, const optional&lt;T&gt;&amp;) noexcept {
  return true;
}

template &lt;class T&gt;
constexpr bool operator&gt;(const optional&lt;T&gt;&amp; x, nullopt_t) noexcept {
  return bool(x);
}

template &lt;class T&gt;
constexpr bool operator&gt;(nullopt_t, const optional&lt;T&gt;&amp;) noexcept {
  return false;
}

template &lt;class T&gt;
constexpr bool operator&gt;=(const optional&lt;T&gt;&amp;, nullopt_t) noexcept {
  return true;
}

template &lt;class T&gt;
constexpr bool operator&gt;=(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept {
  return (!x);
}

// 20.5.10, Comparison with T
template &lt;class T&gt;
constexpr bool operator==(const optional&lt;T&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x == v : false;
}

template &lt;class T&gt;
constexpr bool operator==(const T&amp; v, const optional&lt;T&gt;&amp; x) {
  return bool(x) ? v == *x : false;
}

template &lt;class T&gt;
constexpr bool operator!=(const optional&lt;T&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x != v : true;
}

template &lt;class T&gt;
constexpr bool operator!=(const T&amp; v, const optional&lt;T&gt;&amp; x) {
  return bool(x) ? v != *x : true;
}

template &lt;class T&gt;
constexpr bool operator&lt;(const optional&lt;T&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x &lt; v : true;
}

template &lt;class T&gt;
constexpr bool operator&gt;(const T&amp; v, const optional&lt;T&gt;&amp; x) {
  return bool(x) ? v &gt; *x : true;
}

template &lt;class T&gt;
constexpr bool operator&gt;(const optional&lt;T&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x &gt; v : false;
}

template &lt;class T&gt;
constexpr bool operator&lt;(const T&amp; v, const optional&lt;T&gt;&amp; x) {
  return bool(x) ? v &lt; *x : false;
}

template &lt;class T&gt;
constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x &gt;= v : false;
}

template &lt;class T&gt;
constexpr bool operator&lt;=(const T&amp; v, const optional&lt;T&gt;&amp; x) {
  return bool(x) ? v &lt;= *x : false;
}

template &lt;class T&gt;
constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x &lt;= v : true;
}

template &lt;class T&gt;
constexpr bool operator&gt;=(const T&amp; v, const optional&lt;T&gt;&amp; x) {
  return bool(x) ? v &gt;= *x : true;
}

// Comparison of optional&lt;T&amp;&gt; with T
template &lt;class T&gt;
constexpr bool operator==(const optional&lt;T&amp;&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x == v : false;
}

template &lt;class T&gt;
constexpr bool operator==(const T&amp; v, const optional&lt;T&amp;&gt;&amp; x) {
  return bool(x) ? v == *x : false;
}

template &lt;class T&gt;
constexpr bool operator!=(const optional&lt;T&amp;&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x != v : true;
}

template &lt;class T&gt;
constexpr bool operator!=(const T&amp; v, const optional&lt;T&amp;&gt;&amp; x) {
  return bool(x) ? v != *x : true;
}

template &lt;class T&gt;
constexpr bool operator&lt;(const optional&lt;T&amp;&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x &lt; v : true;
}

template &lt;class T&gt;
constexpr bool operator&gt;(const T&amp; v, const optional&lt;T&amp;&gt;&amp; x) {
  return bool(x) ? v &gt; *x : true;
}

template &lt;class T&gt;
constexpr bool operator&gt;(const optional&lt;T&amp;&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x &gt; v : false;
}

template &lt;class T&gt;
constexpr bool operator&lt;(const T&amp; v, const optional&lt;T&amp;&gt;&amp; x) {
  return bool(x) ? v &lt; *x : false;
}

template &lt;class T&gt;
constexpr bool operator&gt;=(const optional&lt;T&amp;&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x &gt;= v : false;
}

template &lt;class T&gt;
constexpr bool operator&lt;=(const T&amp; v, const optional&lt;T&amp;&gt;&amp; x) {
  return bool(x) ? v &lt;= *x : false;
}

template &lt;class T&gt;
constexpr bool operator&lt;=(const optional&lt;T&amp;&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x &lt;= v : true;
}

template &lt;class T&gt;
constexpr bool operator&gt;=(const T&amp; v, const optional&lt;T&amp;&gt;&amp; x) {
  return bool(x) ? v &gt;= *x : true;
}

// Comparison of optional&lt;T const&amp;&gt; with T
template &lt;class T&gt;
constexpr bool operator==(const optional&lt;const T&amp;&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x == v : false;
}

template &lt;class T&gt;
constexpr bool operator==(const T&amp; v, const optional&lt;const T&amp;&gt;&amp; x) {
  return bool(x) ? v == *x : false;
}

template &lt;class T&gt;
constexpr bool operator!=(const optional&lt;const T&amp;&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x != v : true;
}

template &lt;class T&gt;
constexpr bool operator!=(const T&amp; v, const optional&lt;const T&amp;&gt;&amp; x) {
  return bool(x) ? v != *x : true;
}

template &lt;class T&gt;
constexpr bool operator&lt;(const optional&lt;const T&amp;&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x &lt; v : true;
}

template &lt;class T&gt;
constexpr bool operator&gt;(const T&amp; v, const optional&lt;const T&amp;&gt;&amp; x) {
  return bool(x) ? v &gt; *x : true;
}

template &lt;class T&gt;
constexpr bool operator&gt;(const optional&lt;const T&amp;&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x &gt; v : false;
}

template &lt;class T&gt;
constexpr bool operator&lt;(const T&amp; v, const optional&lt;const T&amp;&gt;&amp; x) {
  return bool(x) ? v &lt; *x : false;
}

template &lt;class T&gt;
constexpr bool operator&gt;=(const optional&lt;const T&amp;&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x &gt;= v : false;
}

template &lt;class T&gt;
constexpr bool operator&lt;=(const T&amp; v, const optional&lt;const T&amp;&gt;&amp; x) {
  return bool(x) ? v &lt;= *x : false;
}

template &lt;class T&gt;
constexpr bool operator&lt;=(const optional&lt;const T&amp;&gt;&amp; x, const T&amp; v) {
  return bool(x) ? *x &lt;= v : true;
}

template &lt;class T&gt;
constexpr bool operator&gt;=(const T&amp; v, const optional&lt;const T&amp;&gt;&amp; x) {
  return bool(x) ? v &gt;= *x : true;
}

// 20.5.12, Specialized algorithms
template &lt;class T&gt;
void swap(optional&lt;T&gt;&amp; x, optional&lt;T&gt;&amp; y) noexcept(noexcept(x.swap(y))) {
  x.swap(y);
}

template &lt;class T&gt;
constexpr optional&lt;typename std::decay&lt;T&gt;::type&gt; make_optional(T&amp;&amp; v) {
  return optional&lt;typename std::decay&lt;T&gt;::type&gt;(constexpr_forward&lt;T&gt;(v));
}

template &lt;class X&gt;
constexpr optional&lt;X&amp;&gt; make_optional(std::reference_wrapper&lt;X&gt; v) {
  return optional&lt;X&amp;&gt;(v.get());
}

} // namespace c10

namespace std {
template &lt;typename T&gt;
struct hash&lt;c10::optional&lt;T&gt;&gt; {
  typedef typename hash&lt;T&gt;::result_type result_type;
  typedef c10::optional&lt;T&gt; argument_type;

  constexpr result_type operator()(argument_type const&amp; arg) const {
    return arg ? std::hash&lt;T&gt;{}(*arg) : result_type{};
  }
};

template &lt;typename T&gt;
struct hash&lt;c10::optional&lt;T&amp;&gt;&gt; {
  typedef typename hash&lt;T&gt;::result_type result_type;
  typedef c10::optional&lt;T&amp;&gt; argument_type;

  constexpr result_type operator()(argument_type const&amp; arg) const {
    return arg ? std::hash&lt;T&gt;{}(*arg) : result_type{};
  }
};
} // namespace std

#undef TR2_OPTIONAL_REQUIRES
#undef TR2_OPTIONAL_ASSERTED_EXPRESSION

#endif // C10_UTIL_OPTIONAL_H_
</pre></div>
</div>
</div>


             </article>
             
            </div>
            <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_torch_csrc_api_include_torch_ordered_dict.h.html" class="btn btn-neutral float-right" title="File ordered_dict.h" accesskey="n" rel="next">Next <img src="../_static/images/chevron-right-orange.svg" class="next-page"></a>
      
      
        <a href="file_c10_util_Optional.h.html" class="btn btn-neutral" title="File Optional.h" accesskey="p" rel="prev"><img src="../_static/images/chevron-right-orange.svg" class="previous-page"> Previous</a>
      
    </div>
  

  

    <hr>

  

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Torch Contributors.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>
     

</footer>

          </div>
        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              <ul>
<li><a class="reference internal" href="#">Program Listing for File Optional.h</a></li>
</ul>

            </div>
          </div>
        </div>
      </section>
    </div>

  


  

     
       <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
         <script type="text/javascript" src="../_static/jquery.js"></script>
         <script type="text/javascript" src="../_static/underscore.js"></script>
         <script type="text/javascript" src="../_static/doctools.js"></script>
         <script type="text/javascript" src="../_static/language_data.js"></script>
         <script type="text/javascript" src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
         <script type="text/javascript" src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
     

  

  <script type="text/javascript" src="../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../_static/js/vendor/bootstrap.min.js"></script>
  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

  <!-- Begin Footer -->

  <div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
    <div class="container">
      <div class="row">
        <div class="col-md-4 text-center">
          <h2>Docs</h2>
          <p>Access comprehensive developer documentation for PyTorch</p>
          <a class="with-right-arrow" href="https://pytorch.org/docs/stable/index.html">View Docs</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Tutorials</h2>
          <p>Get in-depth tutorials for beginners and advanced developers</p>
          <a class="with-right-arrow" href="https://pytorch.org/tutorials">View Tutorials</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Resources</h2>
          <p>Find development resources and get your questions answered</p>
          <a class="with-right-arrow" href="https://pytorch.org/resources">View Resources</a>
        </div>
      </div>
    </div>
  </div>

  <footer class="site-footer">
    <div class="container footer-container">
      <div class="footer-logo-wrapper">
        <a href="https://pytorch.org/" class="footer-logo"></a>
      </div>

      <div class="footer-links-wrapper">
        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/">PyTorch</a></li>
            <li><a href="https://pytorch.org/get-started">Get Started</a></li>
            <li><a href="https://pytorch.org/features">Features</a></li>
            <li><a href="https://pytorch.org/ecosystem">Ecosystem</a></li>
            <li><a href="https://pytorch.org/blog/">Blog</a></li>
            <li><a href="https://pytorch.org/resources">Resources</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/support">Support</a></li>
            <li><a href="https://pytorch.org/tutorials">Tutorials</a></li>
            <li><a href="https://pytorch.org/docs/stable/index.html">Docs</a></li>
            <li><a href="https://discuss.pytorch.org" target="_blank">Discuss</a></li>
            <li><a href="https://github.com/pytorch/pytorch/issues" target="_blank">Github Issues</a></li>
            <li><a href="https://pytorch.slack.com" target="_blank">Slack</a></li>
            <li><a href="https://github.com/pytorch/pytorch/blob/master/CONTRIBUTING.md" target="_blank">Contributing</a></li>
          </ul>
        </div>

        <div class="footer-links-col follow-us-col">
          <ul>
            <li class="list-title">Follow Us</li>
            <li>
              <div id="mc_embed_signup">
                <form
                  action="https://twitter.us14.list-manage.com/subscribe/post?u=75419c71fe0a935e53dfa4a3f&id=91d0dccd39"
                  method="post"
                  id="mc-embedded-subscribe-form"
                  name="mc-embedded-subscribe-form"
                  class="email-subscribe-form validate"
                  target="_blank"
                  novalidate>
                  <div id="mc_embed_signup_scroll" class="email-subscribe-form-fields-wrapper">
                    <div class="mc-field-group">
                      <label for="mce-EMAIL" style="display:none;">Email Address</label>
                      <input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" placeholder="Email Address">
                    </div>

                    <div id="mce-responses" class="clear">
                      <div class="response" id="mce-error-response" style="display:none"></div>
                      <div class="response" id="mce-success-response" style="display:none"></div>
                    </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->

                    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_75419c71fe0a935e53dfa4a3f_91d0dccd39" tabindex="-1" value=""></div>

                    <div class="clear">
                      <input type="submit" value="" name="subscribe" id="mc-embedded-subscribe" class="button email-subscribe-button">
                    </div>
                  </div>
                </form>
              </div>

            </li>
          </ul>

          <div class="footer-social-icons">
            <a href="https://www.facebook.com/pytorch" target="_blank" class="facebook"></a>
            <a href="https://twitter.com/pytorch" target="_blank" class="twitter"></a>
          </div>
        </div>
      </div>
    </div>
  </footer>

  <div class="cookie-banner-wrapper">
  <div class="container">
    <p class="gdpr-notice">To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebook’s Cookies Policy applies. Learn more, including about available controls: <a href="https://www.facebook.com/policies/cookies/">Cookies Policy</a>.</p>
    <img class="close-button" src="../_static/images/pytorch-x.svg">
  </div>
</div>

  <!-- End Footer -->

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="#">Get Started</a>
          </li>

          <li>
            <a href="#">Features</a>
          </li>

          <li>
            <a href="#">Ecosystem</a>
          </li>

          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>

          <li>
            <a href="https://pytorch.org/tutorials">Tutorials</a>
          </li>

          <li class="active">
            <a href="https://pytorch.org/docs/stable/index.html">Docs</a>
          </li>

          <li>
            <a href="https://pytorch.org/resources">Resources</a>
          </li>

          <li>
            <a href="https://github.com/pytorch/pytorch">Github</a>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>